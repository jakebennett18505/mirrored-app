import "./chunk-UWR55C7Y.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  attr_dev,
  children,
  claim_svg_element,
  detach_dev,
  dispatch_dev,
  init,
  insert_hydration_dev,
  noop,
  safe_not_equal,
  svg_element,
  validate_slots
} from "./chunk-J2VQCU4O.js";
import "./chunk-Y7YSCATX.js";
import "./chunk-2B2CG5KL.js";

// node_modules/svelte-feather-icons/src/icons/ActivityIcon.svelte
var file = "node_modules/svelte-feather-icons/src/icons/ActivityIcon.svelte";
function create_fragment(ctx) {
  let svg;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "22 12 18 12 15 21 9 3 6 12 2 12");
      add_location(polyline, file, 13, 245, 529);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-activity " + /*customClass*/
      ctx[2]);
      add_location(svg, file, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-activity " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ActivityIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ActivityIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ActivityIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ActivityIcon",
      options,
      id: create_fragment.name
    });
  }
  get size() {
    throw new Error("<ActivityIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ActivityIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ActivityIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ActivityIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ActivityIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ActivityIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ActivityIcon_default = ActivityIcon;

// node_modules/svelte-feather-icons/src/icons/AirplayIcon.svelte
var file2 = "node_modules/svelte-feather-icons/src/icons/AirplayIcon.svelte";
function create_fragment2(ctx) {
  let svg;
  let path;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1");
      add_location(path, file2, 13, 244, 528);
      attr_dev(polygon, "points", "12 15 17 21 7 21 12 15");
      add_location(polygon, file2, 13, 336, 620);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-airplay " + /*customClass*/
      ctx[2]);
      add_location(svg, file2, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-airplay " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AirplayIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AirplayIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AirplayIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AirplayIcon",
      options,
      id: create_fragment2.name
    });
  }
  get size() {
    throw new Error("<AirplayIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AirplayIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AirplayIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AirplayIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AirplayIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AirplayIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AirplayIcon_default = AirplayIcon;

// node_modules/svelte-feather-icons/src/icons/AlertCircleIcon.svelte
var file3 = "node_modules/svelte-feather-icons/src/icons/AlertCircleIcon.svelte";
function create_fragment3(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file3, 13, 249, 533);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "12");
      add_location(line0, file3, 13, 289, 573);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "16");
      attr_dev(line1, "x2", "12.01");
      attr_dev(line1, "y2", "16");
      add_location(line1, file3, 13, 333, 617);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-alert-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file3, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-alert-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AlertCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AlertCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertCircleIcon",
      options,
      id: create_fragment3.name
    });
  }
  get size() {
    throw new Error("<AlertCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AlertCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AlertCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AlertCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AlertCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AlertCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertCircleIcon_default = AlertCircleIcon;

// node_modules/svelte-feather-icons/src/icons/AlertOctagonIcon.svelte
var file4 = "node_modules/svelte-feather-icons/src/icons/AlertOctagonIcon.svelte";
function create_fragment4(ctx) {
  let svg;
  let polygon;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
      add_location(polygon, file4, 13, 250, 534);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "12");
      add_location(line0, file4, 13, 349, 633);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "16");
      attr_dev(line1, "x2", "12.01");
      attr_dev(line1, "y2", "16");
      add_location(line1, file4, 13, 393, 677);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-alert-octagon " + /*customClass*/
      ctx[2]);
      add_location(svg, file4, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-alert-octagon " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertOctagonIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AlertOctagonIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AlertOctagonIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertOctagonIcon",
      options,
      id: create_fragment4.name
    });
  }
  get size() {
    throw new Error("<AlertOctagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AlertOctagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AlertOctagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AlertOctagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AlertOctagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AlertOctagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertOctagonIcon_default = AlertOctagonIcon;

// node_modules/svelte-feather-icons/src/icons/AlertTriangleIcon.svelte
var file5 = "node_modules/svelte-feather-icons/src/icons/AlertTriangleIcon.svelte";
function create_fragment5(ctx) {
  let svg;
  let path;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z");
      add_location(path, file5, 13, 251, 535);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "13");
      add_location(line0, file5, 13, 357, 641);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "17");
      attr_dev(line1, "x2", "12.01");
      attr_dev(line1, "y2", "17");
      add_location(line1, file5, 13, 401, 685);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-alert-triangle " + /*customClass*/
      ctx[2]);
      add_location(svg, file5, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-alert-triangle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlertTriangleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AlertTriangleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AlertTriangleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertTriangleIcon",
      options,
      id: create_fragment5.name
    });
  }
  get size() {
    throw new Error("<AlertTriangleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AlertTriangleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AlertTriangleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AlertTriangleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AlertTriangleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AlertTriangleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlertTriangleIcon_default = AlertTriangleIcon;

// node_modules/svelte-feather-icons/src/icons/AlignCenterIcon.svelte
var file6 = "node_modules/svelte-feather-icons/src/icons/AlignCenterIcon.svelte";
function create_fragment6(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "10");
      attr_dev(line0, "x2", "6");
      attr_dev(line0, "y2", "10");
      add_location(line0, file6, 13, 249, 533);
      attr_dev(line1, "x1", "21");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "3");
      attr_dev(line1, "y2", "6");
      add_location(line1, file6, 13, 293, 577);
      attr_dev(line2, "x1", "21");
      attr_dev(line2, "y1", "14");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "14");
      add_location(line2, file6, 13, 335, 619);
      attr_dev(line3, "x1", "18");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "6");
      attr_dev(line3, "y2", "18");
      add_location(line3, file6, 13, 379, 663);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-align-center " + /*customClass*/
      ctx[2]);
      add_location(svg, file6, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-align-center " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlignCenterIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AlignCenterIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AlignCenterIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlignCenterIcon",
      options,
      id: create_fragment6.name
    });
  }
  get size() {
    throw new Error("<AlignCenterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AlignCenterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AlignCenterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AlignCenterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AlignCenterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AlignCenterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlignCenterIcon_default = AlignCenterIcon;

// node_modules/svelte-feather-icons/src/icons/AlignJustifyIcon.svelte
var file7 = "node_modules/svelte-feather-icons/src/icons/AlignJustifyIcon.svelte";
function create_fragment7(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "21");
      attr_dev(line0, "y1", "10");
      attr_dev(line0, "x2", "3");
      attr_dev(line0, "y2", "10");
      add_location(line0, file7, 13, 250, 534);
      attr_dev(line1, "x1", "21");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "3");
      attr_dev(line1, "y2", "6");
      add_location(line1, file7, 13, 294, 578);
      attr_dev(line2, "x1", "21");
      attr_dev(line2, "y1", "14");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "14");
      add_location(line2, file7, 13, 336, 620);
      attr_dev(line3, "x1", "21");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "3");
      attr_dev(line3, "y2", "18");
      add_location(line3, file7, 13, 380, 664);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-align-justify " + /*customClass*/
      ctx[2]);
      add_location(svg, file7, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-align-justify " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlignJustifyIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AlignJustifyIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AlignJustifyIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlignJustifyIcon",
      options,
      id: create_fragment7.name
    });
  }
  get size() {
    throw new Error("<AlignJustifyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AlignJustifyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AlignJustifyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AlignJustifyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AlignJustifyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AlignJustifyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlignJustifyIcon_default = AlignJustifyIcon;

// node_modules/svelte-feather-icons/src/icons/AlignLeftIcon.svelte
var file8 = "node_modules/svelte-feather-icons/src/icons/AlignLeftIcon.svelte";
function create_fragment8(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "17");
      attr_dev(line0, "y1", "10");
      attr_dev(line0, "x2", "3");
      attr_dev(line0, "y2", "10");
      add_location(line0, file8, 13, 247, 531);
      attr_dev(line1, "x1", "21");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "3");
      attr_dev(line1, "y2", "6");
      add_location(line1, file8, 13, 291, 575);
      attr_dev(line2, "x1", "21");
      attr_dev(line2, "y1", "14");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "14");
      add_location(line2, file8, 13, 333, 617);
      attr_dev(line3, "x1", "17");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "3");
      attr_dev(line3, "y2", "18");
      add_location(line3, file8, 13, 377, 661);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-align-left " + /*customClass*/
      ctx[2]);
      add_location(svg, file8, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-align-left " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlignLeftIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AlignLeftIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AlignLeftIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlignLeftIcon",
      options,
      id: create_fragment8.name
    });
  }
  get size() {
    throw new Error("<AlignLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AlignLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AlignLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AlignLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AlignLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AlignLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlignLeftIcon_default = AlignLeftIcon;

// node_modules/svelte-feather-icons/src/icons/AlignRightIcon.svelte
var file9 = "node_modules/svelte-feather-icons/src/icons/AlignRightIcon.svelte";
function create_fragment9(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "21");
      attr_dev(line0, "y1", "10");
      attr_dev(line0, "x2", "7");
      attr_dev(line0, "y2", "10");
      add_location(line0, file9, 13, 248, 532);
      attr_dev(line1, "x1", "21");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "3");
      attr_dev(line1, "y2", "6");
      add_location(line1, file9, 13, 292, 576);
      attr_dev(line2, "x1", "21");
      attr_dev(line2, "y1", "14");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "14");
      add_location(line2, file9, 13, 334, 618);
      attr_dev(line3, "x1", "21");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "7");
      attr_dev(line3, "y2", "18");
      add_location(line3, file9, 13, 378, 662);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-align-right " + /*customClass*/
      ctx[2]);
      add_location(svg, file9, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-align-right " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlignRightIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AlignRightIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AlignRightIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlignRightIcon",
      options,
      id: create_fragment9.name
    });
  }
  get size() {
    throw new Error("<AlignRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AlignRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AlignRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AlignRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AlignRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AlignRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlignRightIcon_default = AlignRightIcon;

// node_modules/svelte-feather-icons/src/icons/AnchorIcon.svelte
var file10 = "node_modules/svelte-feather-icons/src/icons/AnchorIcon.svelte";
function create_fragment10(ctx) {
  let svg;
  let circle;
  let line;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "5");
      attr_dev(circle, "r", "3");
      add_location(circle, file10, 13, 243, 527);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "22");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "8");
      add_location(line, file10, 13, 281, 565);
      attr_dev(path, "d", "M5 12H2a10 10 0 0 0 20 0h-3");
      add_location(path, file10, 13, 325, 609);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-anchor " + /*customClass*/
      ctx[2]);
      add_location(svg, file10, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-anchor " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnchorIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AnchorIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AnchorIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnchorIcon",
      options,
      id: create_fragment10.name
    });
  }
  get size() {
    throw new Error("<AnchorIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AnchorIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AnchorIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AnchorIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AnchorIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AnchorIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnchorIcon_default = AnchorIcon;

// node_modules/svelte-feather-icons/src/icons/ApertureIcon.svelte
var file11 = "node_modules/svelte-feather-icons/src/icons/ApertureIcon.svelte";
function create_fragment11(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file11, 13, 245, 529);
      attr_dev(line0, "x1", "14.31");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "20.05");
      attr_dev(line0, "y2", "17.94");
      add_location(line0, file11, 13, 285, 569);
      attr_dev(line1, "x1", "9.69");
      attr_dev(line1, "y1", "8");
      attr_dev(line1, "x2", "21.17");
      attr_dev(line1, "y2", "8");
      add_location(line1, file11, 13, 338, 622);
      attr_dev(line2, "x1", "7.38");
      attr_dev(line2, "y1", "12");
      attr_dev(line2, "x2", "13.12");
      attr_dev(line2, "y2", "2.06");
      add_location(line2, file11, 13, 386, 670);
      attr_dev(line3, "x1", "9.69");
      attr_dev(line3, "y1", "16");
      attr_dev(line3, "x2", "3.95");
      attr_dev(line3, "y2", "6.06");
      add_location(line3, file11, 13, 438, 722);
      attr_dev(line4, "x1", "14.31");
      attr_dev(line4, "y1", "16");
      attr_dev(line4, "x2", "2.83");
      attr_dev(line4, "y2", "16");
      add_location(line4, file11, 13, 489, 773);
      attr_dev(line5, "x1", "16.62");
      attr_dev(line5, "y1", "12");
      attr_dev(line5, "x2", "10.88");
      attr_dev(line5, "y2", "21.94");
      add_location(line5, file11, 13, 539, 823);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-aperture " + /*customClass*/
      ctx[2]);
      add_location(svg, file11, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-aperture " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ApertureIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ApertureIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ApertureIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ApertureIcon",
      options,
      id: create_fragment11.name
    });
  }
  get size() {
    throw new Error("<ApertureIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ApertureIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ApertureIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ApertureIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ApertureIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ApertureIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ApertureIcon_default = ApertureIcon;

// node_modules/svelte-feather-icons/src/icons/ArchiveIcon.svelte
var file12 = "node_modules/svelte-feather-icons/src/icons/ArchiveIcon.svelte";
function create_fragment12(ctx) {
  let svg;
  let polyline;
  let rect;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "21 8 21 21 3 21 3 8");
      add_location(polyline, file12, 13, 244, 528);
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "22");
      attr_dev(rect, "height", "5");
      add_location(rect, file12, 13, 294, 578);
      attr_dev(line, "x1", "10");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "14");
      attr_dev(line, "y2", "12");
      add_location(line, file12, 13, 341, 625);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-archive " + /*customClass*/
      ctx[2]);
      add_location(svg, file12, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-archive " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArchiveIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArchiveIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArchiveIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArchiveIcon",
      options,
      id: create_fragment12.name
    });
  }
  get size() {
    throw new Error("<ArchiveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArchiveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArchiveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArchiveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArchiveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArchiveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArchiveIcon_default = ArchiveIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowDownCircleIcon.svelte
var file13 = "node_modules/svelte-feather-icons/src/icons/ArrowDownCircleIcon.svelte";
function create_fragment13(ctx) {
  let svg;
  let circle;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file13, 13, 254, 538);
      attr_dev(polyline, "points", "8 12 12 16 16 12");
      add_location(polyline, file13, 13, 294, 578);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "8");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "16");
      add_location(line, file13, 13, 341, 625);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-down-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file13, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-down-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowDownCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowDownCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowDownCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowDownCircleIcon",
      options,
      id: create_fragment13.name
    });
  }
  get size() {
    throw new Error("<ArrowDownCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowDownCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowDownCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowDownCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowDownCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowDownCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowDownCircleIcon_default = ArrowDownCircleIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowDownLeftIcon.svelte
var file14 = "node_modules/svelte-feather-icons/src/icons/ArrowDownLeftIcon.svelte";
function create_fragment14(ctx) {
  let svg;
  let line;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "17");
      attr_dev(line, "y1", "7");
      attr_dev(line, "x2", "7");
      attr_dev(line, "y2", "17");
      add_location(line, file14, 13, 252, 536);
      attr_dev(polyline, "points", "17 17 7 17 7 7");
      add_location(polyline, file14, 13, 295, 579);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-down-left " + /*customClass*/
      ctx[2]);
      add_location(svg, file14, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-down-left " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowDownLeftIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowDownLeftIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowDownLeftIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowDownLeftIcon",
      options,
      id: create_fragment14.name
    });
  }
  get size() {
    throw new Error("<ArrowDownLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowDownLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowDownLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowDownLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowDownLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowDownLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowDownLeftIcon_default = ArrowDownLeftIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowDownRightIcon.svelte
var file15 = "node_modules/svelte-feather-icons/src/icons/ArrowDownRightIcon.svelte";
function create_fragment15(ctx) {
  let svg;
  let line;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "7");
      attr_dev(line, "y1", "7");
      attr_dev(line, "x2", "17");
      attr_dev(line, "y2", "17");
      add_location(line, file15, 13, 253, 537);
      attr_dev(polyline, "points", "17 7 17 17 7 17");
      add_location(polyline, file15, 13, 296, 580);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-down-right " + /*customClass*/
      ctx[2]);
      add_location(svg, file15, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-down-right " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowDownRightIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowDownRightIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowDownRightIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowDownRightIcon",
      options,
      id: create_fragment15.name
    });
  }
  get size() {
    throw new Error("<ArrowDownRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowDownRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowDownRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowDownRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowDownRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowDownRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowDownRightIcon_default = ArrowDownRightIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowDownIcon.svelte
var file16 = "node_modules/svelte-feather-icons/src/icons/ArrowDownIcon.svelte";
function create_fragment16(ctx) {
  let svg;
  let line;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "5");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "19");
      add_location(line, file16, 13, 247, 531);
      attr_dev(polyline, "points", "19 12 12 19 5 12");
      add_location(polyline, file16, 13, 291, 575);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-down " + /*customClass*/
      ctx[2]);
      add_location(svg, file16, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-down " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowDownIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowDownIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowDownIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowDownIcon",
      options,
      id: create_fragment16.name
    });
  }
  get size() {
    throw new Error("<ArrowDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowDownIcon_default = ArrowDownIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowLeftCircleIcon.svelte
var file17 = "node_modules/svelte-feather-icons/src/icons/ArrowLeftCircleIcon.svelte";
function create_fragment17(ctx) {
  let svg;
  let circle;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file17, 13, 254, 538);
      attr_dev(polyline, "points", "12 8 8 12 12 16");
      add_location(polyline, file17, 13, 294, 578);
      attr_dev(line, "x1", "16");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "8");
      attr_dev(line, "y2", "12");
      add_location(line, file17, 13, 340, 624);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-left-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file17, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-left-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowLeftCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowLeftCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowLeftCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowLeftCircleIcon",
      options,
      id: create_fragment17.name
    });
  }
  get size() {
    throw new Error("<ArrowLeftCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowLeftCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowLeftCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowLeftCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowLeftCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowLeftCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowLeftCircleIcon_default = ArrowLeftCircleIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowLeftIcon.svelte
var file18 = "node_modules/svelte-feather-icons/src/icons/ArrowLeftIcon.svelte";
function create_fragment18(ctx) {
  let svg;
  let line;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "19");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "5");
      attr_dev(line, "y2", "12");
      add_location(line, file18, 13, 247, 531);
      attr_dev(polyline, "points", "12 19 5 12 12 5");
      add_location(polyline, file18, 13, 291, 575);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-left " + /*customClass*/
      ctx[2]);
      add_location(svg, file18, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-left " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowLeftIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowLeftIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowLeftIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowLeftIcon",
      options,
      id: create_fragment18.name
    });
  }
  get size() {
    throw new Error("<ArrowLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowLeftIcon_default = ArrowLeftIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowRightCircleIcon.svelte
var file19 = "node_modules/svelte-feather-icons/src/icons/ArrowRightCircleIcon.svelte";
function create_fragment19(ctx) {
  let svg;
  let circle;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file19, 13, 255, 539);
      attr_dev(polyline, "points", "12 16 16 12 12 8");
      add_location(polyline, file19, 13, 295, 579);
      attr_dev(line, "x1", "8");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "16");
      attr_dev(line, "y2", "12");
      add_location(line, file19, 13, 342, 626);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-right-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file19, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-right-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowRightCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowRightCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowRightCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowRightCircleIcon",
      options,
      id: create_fragment19.name
    });
  }
  get size() {
    throw new Error("<ArrowRightCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowRightCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowRightCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowRightCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowRightCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowRightCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowRightCircleIcon_default = ArrowRightCircleIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowRightIcon.svelte
var file20 = "node_modules/svelte-feather-icons/src/icons/ArrowRightIcon.svelte";
function create_fragment20(ctx) {
  let svg;
  let line;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "5");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "19");
      attr_dev(line, "y2", "12");
      add_location(line, file20, 13, 248, 532);
      attr_dev(polyline, "points", "12 5 19 12 12 19");
      add_location(polyline, file20, 13, 292, 576);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-right " + /*customClass*/
      ctx[2]);
      add_location(svg, file20, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-right " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowRightIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowRightIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowRightIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowRightIcon",
      options,
      id: create_fragment20.name
    });
  }
  get size() {
    throw new Error("<ArrowRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowRightIcon_default = ArrowRightIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowUpCircleIcon.svelte
var file21 = "node_modules/svelte-feather-icons/src/icons/ArrowUpCircleIcon.svelte";
function create_fragment21(ctx) {
  let svg;
  let circle;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file21, 13, 252, 536);
      attr_dev(polyline, "points", "16 12 12 8 8 12");
      add_location(polyline, file21, 13, 292, 576);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "16");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "8");
      add_location(line, file21, 13, 338, 622);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-up-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file21, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-up-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowUpCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowUpCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowUpCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowUpCircleIcon",
      options,
      id: create_fragment21.name
    });
  }
  get size() {
    throw new Error("<ArrowUpCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowUpCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowUpCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowUpCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowUpCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowUpCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowUpCircleIcon_default = ArrowUpCircleIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowUpLeftIcon.svelte
var file22 = "node_modules/svelte-feather-icons/src/icons/ArrowUpLeftIcon.svelte";
function create_fragment22(ctx) {
  let svg;
  let line;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "17");
      attr_dev(line, "y1", "17");
      attr_dev(line, "x2", "7");
      attr_dev(line, "y2", "7");
      add_location(line, file22, 13, 250, 534);
      attr_dev(polyline, "points", "7 17 7 7 17 7");
      add_location(polyline, file22, 13, 293, 577);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-up-left " + /*customClass*/
      ctx[2]);
      add_location(svg, file22, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-up-left " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowUpLeftIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowUpLeftIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowUpLeftIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowUpLeftIcon",
      options,
      id: create_fragment22.name
    });
  }
  get size() {
    throw new Error("<ArrowUpLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowUpLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowUpLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowUpLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowUpLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowUpLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowUpLeftIcon_default = ArrowUpLeftIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowUpRightIcon.svelte
var file23 = "node_modules/svelte-feather-icons/src/icons/ArrowUpRightIcon.svelte";
function create_fragment23(ctx) {
  let svg;
  let line;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "7");
      attr_dev(line, "y1", "17");
      attr_dev(line, "x2", "17");
      attr_dev(line, "y2", "7");
      add_location(line, file23, 13, 251, 535);
      attr_dev(polyline, "points", "7 7 17 7 17 17");
      add_location(polyline, file23, 13, 294, 578);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-up-right " + /*customClass*/
      ctx[2]);
      add_location(svg, file23, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-up-right " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowUpRightIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowUpRightIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowUpRightIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowUpRightIcon",
      options,
      id: create_fragment23.name
    });
  }
  get size() {
    throw new Error("<ArrowUpRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowUpRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowUpRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowUpRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowUpRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowUpRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowUpRightIcon_default = ArrowUpRightIcon;

// node_modules/svelte-feather-icons/src/icons/ArrowUpIcon.svelte
var file24 = "node_modules/svelte-feather-icons/src/icons/ArrowUpIcon.svelte";
function create_fragment24(ctx) {
  let svg;
  let line;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "19");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "5");
      add_location(line, file24, 13, 245, 529);
      attr_dev(polyline, "points", "5 12 12 5 19 12");
      add_location(polyline, file24, 13, 289, 573);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-arrow-up " + /*customClass*/
      ctx[2]);
      add_location(svg, file24, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-arrow-up " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowUpIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ArrowUpIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ArrowUpIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowUpIcon",
      options,
      id: create_fragment24.name
    });
  }
  get size() {
    throw new Error("<ArrowUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ArrowUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ArrowUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ArrowUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ArrowUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowUpIcon_default = ArrowUpIcon;

// node_modules/svelte-feather-icons/src/icons/AtSignIcon.svelte
var file25 = "node_modules/svelte-feather-icons/src/icons/AtSignIcon.svelte";
function create_fragment25(ctx) {
  let svg;
  let circle;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "4");
      add_location(circle, file25, 13, 244, 528);
      attr_dev(path, "d", "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94");
      add_location(path, file25, 13, 283, 567);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-at-sign " + /*customClass*/
      ctx[2]);
      add_location(svg, file25, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-at-sign " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AtSignIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AtSignIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AtSignIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AtSignIcon",
      options,
      id: create_fragment25.name
    });
  }
  get size() {
    throw new Error("<AtSignIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AtSignIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AtSignIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AtSignIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AtSignIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AtSignIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AtSignIcon_default = AtSignIcon;

// node_modules/svelte-feather-icons/src/icons/AwardIcon.svelte
var file26 = "node_modules/svelte-feather-icons/src/icons/AwardIcon.svelte";
function create_fragment26(ctx) {
  let svg;
  let circle;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "8");
      attr_dev(circle, "r", "7");
      add_location(circle, file26, 13, 242, 526);
      attr_dev(polyline, "points", "8.21 13.89 7 23 12 20 17 23 15.79 13.88");
      add_location(polyline, file26, 13, 280, 564);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-award " + /*customClass*/
      ctx[2]);
      add_location(svg, file26, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-award " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AwardIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AwardIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var AwardIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AwardIcon",
      options,
      id: create_fragment26.name
    });
  }
  get size() {
    throw new Error("<AwardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AwardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AwardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AwardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AwardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AwardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AwardIcon_default = AwardIcon;

// node_modules/svelte-feather-icons/src/icons/BarChart2Icon.svelte
var file27 = "node_modules/svelte-feather-icons/src/icons/BarChart2Icon.svelte";
function create_fragment27(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "20");
      attr_dev(line0, "x2", "18");
      attr_dev(line0, "y2", "10");
      add_location(line0, file27, 13, 248, 532);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "20");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "4");
      add_location(line1, file27, 13, 293, 577);
      attr_dev(line2, "x1", "6");
      attr_dev(line2, "y1", "20");
      attr_dev(line2, "x2", "6");
      attr_dev(line2, "y2", "14");
      add_location(line2, file27, 13, 337, 621);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-bar-chart-2 " + /*customClass*/
      ctx[2]);
      add_location(svg, file27, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-bar-chart-2 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarChart2Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BarChart2Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BarChart2Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarChart2Icon",
      options,
      id: create_fragment27.name
    });
  }
  get size() {
    throw new Error("<BarChart2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BarChart2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BarChart2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BarChart2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BarChart2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BarChart2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BarChart2Icon_default = BarChart2Icon;

// node_modules/svelte-feather-icons/src/icons/BarChartIcon.svelte
var file28 = "node_modules/svelte-feather-icons/src/icons/BarChartIcon.svelte";
function create_fragment28(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "20");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "10");
      add_location(line0, file28, 13, 246, 530);
      attr_dev(line1, "x1", "18");
      attr_dev(line1, "y1", "20");
      attr_dev(line1, "x2", "18");
      attr_dev(line1, "y2", "4");
      add_location(line1, file28, 13, 291, 575);
      attr_dev(line2, "x1", "6");
      attr_dev(line2, "y1", "20");
      attr_dev(line2, "x2", "6");
      attr_dev(line2, "y2", "16");
      add_location(line2, file28, 13, 335, 619);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-bar-chart " + /*customClass*/
      ctx[2]);
      add_location(svg, file28, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-bar-chart " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarChartIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BarChartIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BarChartIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarChartIcon",
      options,
      id: create_fragment28.name
    });
  }
  get size() {
    throw new Error("<BarChartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BarChartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BarChartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BarChartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BarChartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BarChartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BarChartIcon_default = BarChartIcon;

// node_modules/svelte-feather-icons/src/icons/BatteryChargingIcon.svelte
var file29 = "node_modules/svelte-feather-icons/src/icons/BatteryChargingIcon.svelte";
function create_fragment29(ctx) {
  let svg;
  let path;
  let line;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19");
      add_location(path, file29, 13, 253, 537);
      attr_dev(line, "x1", "23");
      attr_dev(line, "y1", "13");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "11");
      add_location(line, file29, 13, 356, 640);
      attr_dev(polyline, "points", "11 6 7 12 13 12 9 18");
      add_location(polyline, file29, 13, 401, 685);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-battery-charging " + /*customClass*/
      ctx[2]);
      add_location(svg, file29, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-battery-charging " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BatteryChargingIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BatteryChargingIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BatteryChargingIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BatteryChargingIcon",
      options,
      id: create_fragment29.name
    });
  }
  get size() {
    throw new Error("<BatteryChargingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BatteryChargingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BatteryChargingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BatteryChargingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BatteryChargingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BatteryChargingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BatteryChargingIcon_default = BatteryChargingIcon;

// node_modules/svelte-feather-icons/src/icons/BatteryIcon.svelte
var file30 = "node_modules/svelte-feather-icons/src/icons/BatteryIcon.svelte";
function create_fragment30(ctx) {
  let svg;
  let rect;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "6");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "12");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file30, 13, 244, 528);
      attr_dev(line, "x1", "23");
      attr_dev(line, "y1", "13");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "11");
      add_location(line, file30, 13, 306, 590);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-battery " + /*customClass*/
      ctx[2]);
      add_location(svg, file30, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-battery " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BatteryIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BatteryIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BatteryIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BatteryIcon",
      options,
      id: create_fragment30.name
    });
  }
  get size() {
    throw new Error("<BatteryIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BatteryIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BatteryIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BatteryIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BatteryIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BatteryIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BatteryIcon_default = BatteryIcon;

// node_modules/svelte-feather-icons/src/icons/BellOffIcon.svelte
var file31 = "node_modules/svelte-feather-icons/src/icons/BellOffIcon.svelte";
function create_fragment31(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let path3;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path3).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M13.73 21a2 2 0 0 1-3.46 0");
      add_location(path0, file31, 13, 245, 529);
      attr_dev(path1, "d", "M18.63 13A17.89 17.89 0 0 1 18 8");
      add_location(path1, file31, 13, 289, 573);
      attr_dev(path2, "d", "M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14");
      add_location(path2, file31, 13, 339, 623);
      attr_dev(path3, "d", "M18 8a6 6 0 0 0-9.33-5");
      add_location(path3, file31, 13, 402, 686);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file31, 13, 442, 726);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-bell-off " + /*customClass*/
      ctx[2]);
      add_location(svg, file31, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, path3);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-bell-off " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BellOffIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BellOffIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BellOffIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BellOffIcon",
      options,
      id: create_fragment31.name
    });
  }
  get size() {
    throw new Error("<BellOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BellOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BellOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BellOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BellOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BellOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BellOffIcon_default = BellOffIcon;

// node_modules/svelte-feather-icons/src/icons/BellIcon.svelte
var file32 = "node_modules/svelte-feather-icons/src/icons/BellIcon.svelte";
function create_fragment32(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9");
      add_location(path0, file32, 13, 241, 525);
      attr_dev(path1, "d", "M13.73 21a2 2 0 0 1-3.46 0");
      add_location(path1, file32, 13, 302, 586);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-bell " + /*customClass*/
      ctx[2]);
      add_location(svg, file32, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-bell " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BellIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BellIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BellIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BellIcon",
      options,
      id: create_fragment32.name
    });
  }
  get size() {
    throw new Error("<BellIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BellIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BellIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BellIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BellIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BellIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BellIcon_default = BellIcon;

// node_modules/svelte-feather-icons/src/icons/BluetoothIcon.svelte
var file33 = "node_modules/svelte-feather-icons/src/icons/BluetoothIcon.svelte";
function create_fragment33(ctx) {
  let svg;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5");
      add_location(polyline, file33, 13, 246, 530);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-bluetooth " + /*customClass*/
      ctx[2]);
      add_location(svg, file33, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-bluetooth " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BluetoothIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BluetoothIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BluetoothIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BluetoothIcon",
      options,
      id: create_fragment33.name
    });
  }
  get size() {
    throw new Error("<BluetoothIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BluetoothIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BluetoothIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BluetoothIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BluetoothIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BluetoothIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BluetoothIcon_default = BluetoothIcon;

// node_modules/svelte-feather-icons/src/icons/BoldIcon.svelte
var file34 = "node_modules/svelte-feather-icons/src/icons/BoldIcon.svelte";
function create_fragment34(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z");
      add_location(path0, file34, 13, 241, 525);
      attr_dev(path1, "d", "M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z");
      add_location(path1, file34, 13, 296, 580);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-bold " + /*customClass*/
      ctx[2]);
      add_location(svg, file34, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-bold " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BoldIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BoldIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BoldIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BoldIcon",
      options,
      id: create_fragment34.name
    });
  }
  get size() {
    throw new Error("<BoldIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BoldIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BoldIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BoldIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BoldIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BoldIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BoldIcon_default = BoldIcon;

// node_modules/svelte-feather-icons/src/icons/BookOpenIcon.svelte
var file35 = "node_modules/svelte-feather-icons/src/icons/BookOpenIcon.svelte";
function create_fragment35(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z");
      add_location(path0, file35, 13, 246, 530);
      attr_dev(path1, "d", "M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z");
      add_location(path1, file35, 13, 304, 588);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-book-open " + /*customClass*/
      ctx[2]);
      add_location(svg, file35, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-book-open " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BookOpenIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BookOpenIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BookOpenIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BookOpenIcon",
      options,
      id: create_fragment35.name
    });
  }
  get size() {
    throw new Error("<BookOpenIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BookOpenIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BookOpenIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BookOpenIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BookOpenIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BookOpenIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BookOpenIcon_default = BookOpenIcon;

// node_modules/svelte-feather-icons/src/icons/BookIcon.svelte
var file36 = "node_modules/svelte-feather-icons/src/icons/BookIcon.svelte";
function create_fragment36(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M4 19.5A2.5 2.5 0 0 1 6.5 17H20");
      add_location(path0, file36, 13, 241, 525);
      attr_dev(path1, "d", "M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z");
      add_location(path1, file36, 13, 290, 574);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-book " + /*customClass*/
      ctx[2]);
      add_location(svg, file36, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-book " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BookIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BookIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BookIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BookIcon",
      options,
      id: create_fragment36.name
    });
  }
  get size() {
    throw new Error("<BookIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BookIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BookIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BookIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BookIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BookIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BookIcon_default = BookIcon;

// node_modules/svelte-feather-icons/src/icons/BookmarkIcon.svelte
var file37 = "node_modules/svelte-feather-icons/src/icons/BookmarkIcon.svelte";
function create_fragment37(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z");
      add_location(path, file37, 13, 245, 529);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-bookmark " + /*customClass*/
      ctx[2]);
      add_location(svg, file37, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-bookmark " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BookmarkIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BookmarkIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BookmarkIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BookmarkIcon",
      options,
      id: create_fragment37.name
    });
  }
  get size() {
    throw new Error("<BookmarkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BookmarkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BookmarkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BookmarkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BookmarkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BookmarkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BookmarkIcon_default = BookmarkIcon;

// node_modules/svelte-feather-icons/src/icons/BoxIcon.svelte
var file38 = "node_modules/svelte-feather-icons/src/icons/BoxIcon.svelte";
function create_fragment38(ctx) {
  let svg;
  let path;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
      add_location(path, file38, 13, 240, 524);
      attr_dev(polyline, "points", "3.27 6.96 12 12.01 20.73 6.96");
      add_location(polyline, file38, 13, 379, 663);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "22.08");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "12");
      add_location(line, file38, 13, 439, 723);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-box " + /*customClass*/
      ctx[2]);
      add_location(svg, file38, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-box " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BoxIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BoxIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BoxIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BoxIcon",
      options,
      id: create_fragment38.name
    });
  }
  get size() {
    throw new Error("<BoxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BoxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BoxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BoxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BoxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BoxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BoxIcon_default = BoxIcon;

// node_modules/svelte-feather-icons/src/icons/BriefcaseIcon.svelte
var file39 = "node_modules/svelte-feather-icons/src/icons/BriefcaseIcon.svelte";
function create_fragment39(ctx) {
  let svg;
  let rect;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "7");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file39, 13, 246, 530);
      attr_dev(path, "d", "M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16");
      add_location(path, file39, 13, 308, 592);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-briefcase " + /*customClass*/
      ctx[2]);
      add_location(svg, file39, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-briefcase " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BriefcaseIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BriefcaseIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var BriefcaseIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BriefcaseIcon",
      options,
      id: create_fragment39.name
    });
  }
  get size() {
    throw new Error("<BriefcaseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<BriefcaseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<BriefcaseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<BriefcaseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BriefcaseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BriefcaseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BriefcaseIcon_default = BriefcaseIcon;

// node_modules/svelte-feather-icons/src/icons/CalendarIcon.svelte
var file40 = "node_modules/svelte-feather-icons/src/icons/CalendarIcon.svelte";
function create_fragment40(ctx) {
  let svg;
  let rect;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "4");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file40, 13, 245, 529);
      attr_dev(line0, "x1", "16");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "6");
      add_location(line0, file40, 13, 307, 591);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "2");
      attr_dev(line1, "x2", "8");
      attr_dev(line1, "y2", "6");
      add_location(line1, file40, 13, 350, 634);
      attr_dev(line2, "x1", "3");
      attr_dev(line2, "y1", "10");
      attr_dev(line2, "x2", "21");
      attr_dev(line2, "y2", "10");
      add_location(line2, file40, 13, 391, 675);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-calendar " + /*customClass*/
      ctx[2]);
      add_location(svg, file40, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-calendar " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CalendarIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CalendarIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CalendarIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CalendarIcon",
      options,
      id: create_fragment40.name
    });
  }
  get size() {
    throw new Error("<CalendarIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CalendarIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CalendarIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CalendarIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CalendarIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CalendarIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CalendarIcon_default = CalendarIcon;

// node_modules/svelte-feather-icons/src/icons/CameraOffIcon.svelte
var file41 = "node_modules/svelte-feather-icons/src/icons/CameraOffIcon.svelte";
function create_fragment41(ctx) {
  let svg;
  let line;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file41, 13, 247, 531);
      attr_dev(path, "d", "M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56");
      add_location(path, file41, 13, 290, 574);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-camera-off " + /*customClass*/
      ctx[2]);
      add_location(svg, file41, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-camera-off " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CameraOffIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CameraOffIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CameraOffIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CameraOffIcon",
      options,
      id: create_fragment41.name
    });
  }
  get size() {
    throw new Error("<CameraOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CameraOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CameraOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CameraOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CameraOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CameraOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CameraOffIcon_default = CameraOffIcon;

// node_modules/svelte-feather-icons/src/icons/CameraIcon.svelte
var file42 = "node_modules/svelte-feather-icons/src/icons/CameraIcon.svelte";
function create_fragment42(ctx) {
  let svg;
  let path;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z");
      add_location(path, file42, 13, 243, 527);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "13");
      attr_dev(circle, "r", "4");
      add_location(circle, file42, 13, 342, 626);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-camera " + /*customClass*/
      ctx[2]);
      add_location(svg, file42, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-camera " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CameraIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CameraIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CameraIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CameraIcon",
      options,
      id: create_fragment42.name
    });
  }
  get size() {
    throw new Error("<CameraIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CameraIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CameraIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CameraIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CameraIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CameraIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CameraIcon_default = CameraIcon;

// node_modules/svelte-feather-icons/src/icons/CastIcon.svelte
var file43 = "node_modules/svelte-feather-icons/src/icons/CastIcon.svelte";
function create_fragment43(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6");
      add_location(path, file43, 13, 241, 525);
      attr_dev(line, "x1", "2");
      attr_dev(line, "y1", "20");
      attr_dev(line, "x2", "2.01");
      attr_dev(line, "y2", "20");
      add_location(line, file43, 13, 366, 650);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-cast " + /*customClass*/
      ctx[2]);
      add_location(svg, file43, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-cast " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CastIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CastIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CastIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CastIcon",
      options,
      id: create_fragment43.name
    });
  }
  get size() {
    throw new Error("<CastIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CastIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CastIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CastIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CastIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CastIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CastIcon_default = CastIcon;

// node_modules/svelte-feather-icons/src/icons/CheckCircleIcon.svelte
var file44 = "node_modules/svelte-feather-icons/src/icons/CheckCircleIcon.svelte";
function create_fragment44(ctx) {
  let svg;
  let path;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 11.08V12a10 10 0 1 1-5.93-9.14");
      add_location(path, file44, 13, 249, 533);
      attr_dev(polyline, "points", "22 4 12 14.01 9 11.01");
      add_location(polyline, file44, 13, 301, 585);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-check-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file44, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-check-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CheckCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CheckCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckCircleIcon",
      options,
      id: create_fragment44.name
    });
  }
  get size() {
    throw new Error("<CheckCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CheckCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CheckCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CheckCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CheckCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CheckCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckCircleIcon_default = CheckCircleIcon;

// node_modules/svelte-feather-icons/src/icons/CheckSquareIcon.svelte
var file45 = "node_modules/svelte-feather-icons/src/icons/CheckSquareIcon.svelte";
function create_fragment45(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "9 11 12 14 22 4");
      add_location(polyline, file45, 13, 249, 533);
      attr_dev(path, "d", "M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11");
      add_location(path, file45, 13, 295, 579);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-check-square " + /*customClass*/
      ctx[2]);
      add_location(svg, file45, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-check-square " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckSquareIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CheckSquareIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CheckSquareIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckSquareIcon",
      options,
      id: create_fragment45.name
    });
  }
  get size() {
    throw new Error("<CheckSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CheckSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CheckSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CheckSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CheckSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CheckSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckSquareIcon_default = CheckSquareIcon;

// node_modules/svelte-feather-icons/src/icons/CheckIcon.svelte
var file46 = "node_modules/svelte-feather-icons/src/icons/CheckIcon.svelte";
function create_fragment46(ctx) {
  let svg;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "20 6 9 17 4 12");
      add_location(polyline, file46, 13, 242, 526);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-check " + /*customClass*/
      ctx[2]);
      add_location(svg, file46, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-check " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CheckIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CheckIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckIcon",
      options,
      id: create_fragment46.name
    });
  }
  get size() {
    throw new Error("<CheckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CheckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CheckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CheckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CheckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CheckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckIcon_default = CheckIcon;

// node_modules/svelte-feather-icons/src/icons/ChevronDownIcon.svelte
var file47 = "node_modules/svelte-feather-icons/src/icons/ChevronDownIcon.svelte";
function create_fragment47(ctx) {
  let svg;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "6 9 12 15 18 9");
      add_location(polyline, file47, 13, 249, 533);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-chevron-down " + /*customClass*/
      ctx[2]);
      add_location(svg, file47, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-chevron-down " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronDownIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronDownIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ChevronDownIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronDownIcon",
      options,
      id: create_fragment47.name
    });
  }
  get size() {
    throw new Error("<ChevronDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ChevronDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ChevronDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ChevronDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ChevronDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronDownIcon_default = ChevronDownIcon;

// node_modules/svelte-feather-icons/src/icons/ChevronLeftIcon.svelte
var file48 = "node_modules/svelte-feather-icons/src/icons/ChevronLeftIcon.svelte";
function create_fragment48(ctx) {
  let svg;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "15 18 9 12 15 6");
      add_location(polyline, file48, 13, 249, 533);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-chevron-left " + /*customClass*/
      ctx[2]);
      add_location(svg, file48, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-chevron-left " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronLeftIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronLeftIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ChevronLeftIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronLeftIcon",
      options,
      id: create_fragment48.name
    });
  }
  get size() {
    throw new Error("<ChevronLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ChevronLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ChevronLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ChevronLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ChevronLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronLeftIcon_default = ChevronLeftIcon;

// node_modules/svelte-feather-icons/src/icons/ChevronRightIcon.svelte
var file49 = "node_modules/svelte-feather-icons/src/icons/ChevronRightIcon.svelte";
function create_fragment49(ctx) {
  let svg;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "9 18 15 12 9 6");
      add_location(polyline, file49, 13, 250, 534);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-chevron-right " + /*customClass*/
      ctx[2]);
      add_location(svg, file49, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-chevron-right " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronRightIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronRightIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ChevronRightIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronRightIcon",
      options,
      id: create_fragment49.name
    });
  }
  get size() {
    throw new Error("<ChevronRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ChevronRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ChevronRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ChevronRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ChevronRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronRightIcon_default = ChevronRightIcon;

// node_modules/svelte-feather-icons/src/icons/ChevronUpIcon.svelte
var file50 = "node_modules/svelte-feather-icons/src/icons/ChevronUpIcon.svelte";
function create_fragment50(ctx) {
  let svg;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "18 15 12 9 6 15");
      add_location(polyline, file50, 13, 247, 531);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-chevron-up " + /*customClass*/
      ctx[2]);
      add_location(svg, file50, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-chevron-up " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronUpIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronUpIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ChevronUpIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronUpIcon",
      options,
      id: create_fragment50.name
    });
  }
  get size() {
    throw new Error("<ChevronUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ChevronUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ChevronUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ChevronUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ChevronUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronUpIcon_default = ChevronUpIcon;

// node_modules/svelte-feather-icons/src/icons/ChevronsDownIcon.svelte
var file51 = "node_modules/svelte-feather-icons/src/icons/ChevronsDownIcon.svelte";
function create_fragment51(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "7 13 12 18 17 13");
      add_location(polyline0, file51, 13, 250, 534);
      attr_dev(polyline1, "points", "7 6 12 11 17 6");
      add_location(polyline1, file51, 13, 297, 581);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-chevrons-down " + /*customClass*/
      ctx[2]);
      add_location(svg, file51, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-chevrons-down " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronsDownIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronsDownIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ChevronsDownIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronsDownIcon",
      options,
      id: create_fragment51.name
    });
  }
  get size() {
    throw new Error("<ChevronsDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronsDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ChevronsDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ChevronsDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ChevronsDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ChevronsDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronsDownIcon_default = ChevronsDownIcon;

// node_modules/svelte-feather-icons/src/icons/ChevronsLeftIcon.svelte
var file52 = "node_modules/svelte-feather-icons/src/icons/ChevronsLeftIcon.svelte";
function create_fragment52(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "11 17 6 12 11 7");
      add_location(polyline0, file52, 13, 250, 534);
      attr_dev(polyline1, "points", "18 17 13 12 18 7");
      add_location(polyline1, file52, 13, 296, 580);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-chevrons-left " + /*customClass*/
      ctx[2]);
      add_location(svg, file52, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-chevrons-left " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronsLeftIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronsLeftIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ChevronsLeftIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronsLeftIcon",
      options,
      id: create_fragment52.name
    });
  }
  get size() {
    throw new Error("<ChevronsLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronsLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ChevronsLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ChevronsLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ChevronsLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ChevronsLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronsLeftIcon_default = ChevronsLeftIcon;

// node_modules/svelte-feather-icons/src/icons/ChevronsRightIcon.svelte
var file53 = "node_modules/svelte-feather-icons/src/icons/ChevronsRightIcon.svelte";
function create_fragment53(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "13 17 18 12 13 7");
      add_location(polyline0, file53, 13, 251, 535);
      attr_dev(polyline1, "points", "6 17 11 12 6 7");
      add_location(polyline1, file53, 13, 298, 582);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-chevrons-right " + /*customClass*/
      ctx[2]);
      add_location(svg, file53, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-chevrons-right " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronsRightIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronsRightIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ChevronsRightIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronsRightIcon",
      options,
      id: create_fragment53.name
    });
  }
  get size() {
    throw new Error("<ChevronsRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronsRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ChevronsRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ChevronsRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ChevronsRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ChevronsRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronsRightIcon_default = ChevronsRightIcon;

// node_modules/svelte-feather-icons/src/icons/ChevronsUpIcon.svelte
var file54 = "node_modules/svelte-feather-icons/src/icons/ChevronsUpIcon.svelte";
function create_fragment54(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "17 11 12 6 7 11");
      add_location(polyline0, file54, 13, 248, 532);
      attr_dev(polyline1, "points", "17 18 12 13 7 18");
      add_location(polyline1, file54, 13, 294, 578);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-chevrons-up " + /*customClass*/
      ctx[2]);
      add_location(svg, file54, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-chevrons-up " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronsUpIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronsUpIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ChevronsUpIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronsUpIcon",
      options,
      id: create_fragment54.name
    });
  }
  get size() {
    throw new Error("<ChevronsUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronsUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ChevronsUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ChevronsUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ChevronsUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ChevronsUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronsUpIcon_default = ChevronsUpIcon;

// node_modules/svelte-feather-icons/src/icons/ChromeIcon.svelte
var file55 = "node_modules/svelte-feather-icons/src/icons/ChromeIcon.svelte";
function create_fragment55(ctx) {
  let svg;
  let circle0;
  let circle1;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "10");
      add_location(circle0, file55, 13, 243, 527);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "4");
      add_location(circle1, file55, 13, 283, 567);
      attr_dev(line0, "x1", "21.17");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "8");
      add_location(line0, file55, 13, 322, 606);
      attr_dev(line1, "x1", "3.95");
      attr_dev(line1, "y1", "6.06");
      attr_dev(line1, "x2", "8.54");
      attr_dev(line1, "y2", "14");
      add_location(line1, file55, 13, 368, 652);
      attr_dev(line2, "x1", "10.88");
      attr_dev(line2, "y1", "21.94");
      attr_dev(line2, "x2", "15.46");
      attr_dev(line2, "y2", "14");
      add_location(line2, file55, 13, 419, 703);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-chrome " + /*customClass*/
      ctx[2]);
      add_location(svg, file55, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-chrome " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChromeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChromeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ChromeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChromeIcon",
      options,
      id: create_fragment55.name
    });
  }
  get size() {
    throw new Error("<ChromeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChromeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ChromeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ChromeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ChromeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ChromeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChromeIcon_default = ChromeIcon;

// node_modules/svelte-feather-icons/src/icons/CircleIcon.svelte
var file56 = "node_modules/svelte-feather-icons/src/icons/CircleIcon.svelte";
function create_fragment56(ctx) {
  let svg;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file56, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file56, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CircleIcon",
      options,
      id: create_fragment56.name
    });
  }
  get size() {
    throw new Error("<CircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CircleIcon_default = CircleIcon;

// node_modules/svelte-feather-icons/src/icons/ClipboardIcon.svelte
var file57 = "node_modules/svelte-feather-icons/src/icons/ClipboardIcon.svelte";
function create_fragment57(ctx) {
  let svg;
  let path;
  let rect;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2");
      add_location(path, file57, 13, 246, 530);
      attr_dev(rect, "x", "8");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "8");
      attr_dev(rect, "height", "4");
      attr_dev(rect, "rx", "1");
      attr_dev(rect, "ry", "1");
      add_location(rect, file57, 13, 336, 620);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-clipboard " + /*customClass*/
      ctx[2]);
      add_location(svg, file57, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, rect);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-clipboard " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ClipboardIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ClipboardIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ClipboardIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ClipboardIcon",
      options,
      id: create_fragment57.name
    });
  }
  get size() {
    throw new Error("<ClipboardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ClipboardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ClipboardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ClipboardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ClipboardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ClipboardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ClipboardIcon_default = ClipboardIcon;

// node_modules/svelte-feather-icons/src/icons/ClockIcon.svelte
var file58 = "node_modules/svelte-feather-icons/src/icons/ClockIcon.svelte";
function create_fragment58(ctx) {
  let svg;
  let circle;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file58, 13, 242, 526);
      attr_dev(polyline, "points", "12 6 12 12 16 14");
      add_location(polyline, file58, 13, 282, 566);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-clock " + /*customClass*/
      ctx[2]);
      add_location(svg, file58, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-clock " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ClockIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ClockIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ClockIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ClockIcon",
      options,
      id: create_fragment58.name
    });
  }
  get size() {
    throw new Error("<ClockIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ClockIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ClockIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ClockIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ClockIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ClockIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ClockIcon_default = ClockIcon;

// node_modules/svelte-feather-icons/src/icons/CloudDrizzleIcon.svelte
var file59 = "node_modules/svelte-feather-icons/src/icons/CloudDrizzleIcon.svelte";
function create_fragment59(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "19");
      attr_dev(line0, "x2", "8");
      attr_dev(line0, "y2", "21");
      add_location(line0, file59, 13, 250, 534);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "13");
      attr_dev(line1, "x2", "8");
      attr_dev(line1, "y2", "15");
      add_location(line1, file59, 13, 293, 577);
      attr_dev(line2, "x1", "16");
      attr_dev(line2, "y1", "19");
      attr_dev(line2, "x2", "16");
      attr_dev(line2, "y2", "21");
      add_location(line2, file59, 13, 336, 620);
      attr_dev(line3, "x1", "16");
      attr_dev(line3, "y1", "13");
      attr_dev(line3, "x2", "16");
      attr_dev(line3, "y2", "15");
      add_location(line3, file59, 13, 381, 665);
      attr_dev(line4, "x1", "12");
      attr_dev(line4, "y1", "21");
      attr_dev(line4, "x2", "12");
      attr_dev(line4, "y2", "23");
      add_location(line4, file59, 13, 426, 710);
      attr_dev(line5, "x1", "12");
      attr_dev(line5, "y1", "15");
      attr_dev(line5, "x2", "12");
      attr_dev(line5, "y2", "17");
      add_location(line5, file59, 13, 471, 755);
      attr_dev(path, "d", "M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25");
      add_location(path, file59, 13, 516, 800);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-cloud-drizzle " + /*customClass*/
      ctx[2]);
      add_location(svg, file59, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-cloud-drizzle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance59($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CloudDrizzleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CloudDrizzleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CloudDrizzleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment59, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudDrizzleIcon",
      options,
      id: create_fragment59.name
    });
  }
  get size() {
    throw new Error("<CloudDrizzleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CloudDrizzleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CloudDrizzleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CloudDrizzleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CloudDrizzleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CloudDrizzleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CloudDrizzleIcon_default = CloudDrizzleIcon;

// node_modules/svelte-feather-icons/src/icons/CloudLightningIcon.svelte
var file60 = "node_modules/svelte-feather-icons/src/icons/CloudLightningIcon.svelte";
function create_fragment60(ctx) {
  let svg;
  let path;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9");
      add_location(path, file60, 13, 252, 536);
      attr_dev(polyline, "points", "13 11 9 17 15 17 11 23");
      add_location(polyline, file60, 13, 317, 601);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-cloud-lightning " + /*customClass*/
      ctx[2]);
      add_location(svg, file60, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-cloud-lightning " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CloudLightningIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CloudLightningIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CloudLightningIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudLightningIcon",
      options,
      id: create_fragment60.name
    });
  }
  get size() {
    throw new Error("<CloudLightningIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CloudLightningIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CloudLightningIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CloudLightningIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CloudLightningIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CloudLightningIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CloudLightningIcon_default = CloudLightningIcon;

// node_modules/svelte-feather-icons/src/icons/CloudOffIcon.svelte
var file61 = "node_modules/svelte-feather-icons/src/icons/CloudOffIcon.svelte";
function create_fragment61(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3");
      add_location(path, file61, 13, 246, 530);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file61, 13, 353, 637);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-cloud-off " + /*customClass*/
      ctx[2]);
      add_location(svg, file61, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-cloud-off " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance61($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CloudOffIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CloudOffIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CloudOffIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudOffIcon",
      options,
      id: create_fragment61.name
    });
  }
  get size() {
    throw new Error("<CloudOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CloudOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CloudOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CloudOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CloudOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CloudOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CloudOffIcon_default = CloudOffIcon;

// node_modules/svelte-feather-icons/src/icons/CloudRainIcon.svelte
var file62 = "node_modules/svelte-feather-icons/src/icons/CloudRainIcon.svelte";
function create_fragment62(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "16");
      attr_dev(line0, "y1", "13");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "21");
      add_location(line0, file62, 13, 247, 531);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "13");
      attr_dev(line1, "x2", "8");
      attr_dev(line1, "y2", "21");
      add_location(line1, file62, 13, 292, 576);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "15");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "23");
      add_location(line2, file62, 13, 335, 619);
      attr_dev(path, "d", "M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25");
      add_location(path, file62, 13, 380, 664);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-cloud-rain " + /*customClass*/
      ctx[2]);
      add_location(svg, file62, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-cloud-rain " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance62($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CloudRainIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CloudRainIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CloudRainIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudRainIcon",
      options,
      id: create_fragment62.name
    });
  }
  get size() {
    throw new Error("<CloudRainIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CloudRainIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CloudRainIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CloudRainIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CloudRainIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CloudRainIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CloudRainIcon_default = CloudRainIcon;

// node_modules/svelte-feather-icons/src/icons/CloudSnowIcon.svelte
var file63 = "node_modules/svelte-feather-icons/src/icons/CloudSnowIcon.svelte";
function create_fragment63(ctx) {
  let svg;
  let path;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25");
      add_location(path, file63, 13, 247, 531);
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "16");
      attr_dev(line0, "x2", "8.01");
      attr_dev(line0, "y2", "16");
      add_location(line0, file63, 13, 313, 597);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "20");
      attr_dev(line1, "x2", "8.01");
      attr_dev(line1, "y2", "20");
      add_location(line1, file63, 13, 359, 643);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "18");
      attr_dev(line2, "x2", "12.01");
      attr_dev(line2, "y2", "18");
      add_location(line2, file63, 13, 405, 689);
      attr_dev(line3, "x1", "12");
      attr_dev(line3, "y1", "22");
      attr_dev(line3, "x2", "12.01");
      attr_dev(line3, "y2", "22");
      add_location(line3, file63, 13, 453, 737);
      attr_dev(line4, "x1", "16");
      attr_dev(line4, "y1", "16");
      attr_dev(line4, "x2", "16.01");
      attr_dev(line4, "y2", "16");
      add_location(line4, file63, 13, 501, 785);
      attr_dev(line5, "x1", "16");
      attr_dev(line5, "y1", "20");
      attr_dev(line5, "x2", "16.01");
      attr_dev(line5, "y2", "20");
      add_location(line5, file63, 13, 549, 833);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-cloud-snow " + /*customClass*/
      ctx[2]);
      add_location(svg, file63, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-cloud-snow " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CloudSnowIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CloudSnowIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CloudSnowIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudSnowIcon",
      options,
      id: create_fragment63.name
    });
  }
  get size() {
    throw new Error("<CloudSnowIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CloudSnowIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CloudSnowIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CloudSnowIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CloudSnowIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CloudSnowIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CloudSnowIcon_default = CloudSnowIcon;

// node_modules/svelte-feather-icons/src/icons/CloudIcon.svelte
var file64 = "node_modules/svelte-feather-icons/src/icons/CloudIcon.svelte";
function create_fragment64(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z");
      add_location(path, file64, 13, 242, 526);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-cloud " + /*customClass*/
      ctx[2]);
      add_location(svg, file64, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-cloud " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CloudIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CloudIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CloudIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudIcon",
      options,
      id: create_fragment64.name
    });
  }
  get size() {
    throw new Error("<CloudIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CloudIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CloudIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CloudIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CloudIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CloudIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CloudIcon_default = CloudIcon;

// node_modules/svelte-feather-icons/src/icons/CodeIcon.svelte
var file65 = "node_modules/svelte-feather-icons/src/icons/CodeIcon.svelte";
function create_fragment65(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "16 18 22 12 16 6");
      add_location(polyline0, file65, 13, 241, 525);
      attr_dev(polyline1, "points", "8 6 2 12 8 18");
      add_location(polyline1, file65, 13, 288, 572);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-code " + /*customClass*/
      ctx[2]);
      add_location(svg, file65, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-code " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CodeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CodeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeIcon",
      options,
      id: create_fragment65.name
    });
  }
  get size() {
    throw new Error("<CodeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CodeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CodeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CodeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CodeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CodeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeIcon_default = CodeIcon;

// node_modules/svelte-feather-icons/src/icons/CodepenIcon.svelte
var file66 = "node_modules/svelte-feather-icons/src/icons/CodepenIcon.svelte";
function create_fragment66(ctx) {
  let svg;
  let polygon;
  let line0;
  let polyline0;
  let polyline1;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2");
      add_location(polygon, file66, 13, 244, 528);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "22");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "15.5");
      add_location(line0, file66, 13, 316, 600);
      attr_dev(polyline0, "points", "22 8.5 12 15.5 2 8.5");
      add_location(polyline0, file66, 13, 363, 647);
      attr_dev(polyline1, "points", "2 15.5 12 8.5 22 15.5");
      add_location(polyline1, file66, 13, 414, 698);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "2");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "8.5");
      add_location(line1, file66, 13, 466, 750);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-codepen " + /*customClass*/
      ctx[2]);
      add_location(svg, file66, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-codepen " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodepenIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CodepenIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CodepenIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodepenIcon",
      options,
      id: create_fragment66.name
    });
  }
  get size() {
    throw new Error("<CodepenIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CodepenIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CodepenIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CodepenIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CodepenIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CodepenIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodepenIcon_default = CodepenIcon;

// node_modules/svelte-feather-icons/src/icons/CodesandboxIcon.svelte
var file67 = "node_modules/svelte-feather-icons/src/icons/CodesandboxIcon.svelte";
function create_fragment67(ctx) {
  let svg;
  let path;
  let polyline0;
  let polyline1;
  let polyline2;
  let polyline3;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      polyline2 = svg_element("polyline");
      polyline3 = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      polyline2 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline2).forEach(detach_dev);
      polyline3 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline3).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
      add_location(path, file67, 13, 248, 532);
      attr_dev(polyline0, "points", "7.5 4.21 12 6.81 16.5 4.21");
      add_location(polyline0, file67, 13, 387, 671);
      attr_dev(polyline1, "points", "7.5 19.79 7.5 14.6 3 12");
      add_location(polyline1, file67, 13, 444, 728);
      attr_dev(polyline2, "points", "21 12 16.5 14.6 16.5 19.79");
      add_location(polyline2, file67, 13, 498, 782);
      attr_dev(polyline3, "points", "3.27 6.96 12 12.01 20.73 6.96");
      add_location(polyline3, file67, 13, 555, 839);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "22.08");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "12");
      add_location(line, file67, 13, 615, 899);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-codesandbox " + /*customClass*/
      ctx[2]);
      add_location(svg, file67, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
      append_hydration_dev(svg, polyline2);
      append_hydration_dev(svg, polyline3);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-codesandbox " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodesandboxIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CodesandboxIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CodesandboxIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodesandboxIcon",
      options,
      id: create_fragment67.name
    });
  }
  get size() {
    throw new Error("<CodesandboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CodesandboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CodesandboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CodesandboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CodesandboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CodesandboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodesandboxIcon_default = CodesandboxIcon;

// node_modules/svelte-feather-icons/src/icons/CoffeeIcon.svelte
var file68 = "node_modules/svelte-feather-icons/src/icons/CoffeeIcon.svelte";
function create_fragment68(ctx) {
  let svg;
  let path0;
  let path1;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M18 8h1a4 4 0 0 1 0 8h-1");
      add_location(path0, file68, 13, 243, 527);
      attr_dev(path1, "d", "M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z");
      add_location(path1, file68, 13, 285, 569);
      attr_dev(line0, "x1", "6");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "6");
      attr_dev(line0, "y2", "4");
      add_location(line0, file68, 13, 345, 629);
      attr_dev(line1, "x1", "10");
      attr_dev(line1, "y1", "1");
      attr_dev(line1, "x2", "10");
      attr_dev(line1, "y2", "4");
      add_location(line1, file68, 13, 386, 670);
      attr_dev(line2, "x1", "14");
      attr_dev(line2, "y1", "1");
      attr_dev(line2, "x2", "14");
      attr_dev(line2, "y2", "4");
      add_location(line2, file68, 13, 429, 713);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-coffee " + /*customClass*/
      ctx[2]);
      add_location(svg, file68, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-coffee " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CoffeeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CoffeeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CoffeeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment68, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CoffeeIcon",
      options,
      id: create_fragment68.name
    });
  }
  get size() {
    throw new Error("<CoffeeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CoffeeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CoffeeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CoffeeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CoffeeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CoffeeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CoffeeIcon_default = CoffeeIcon;

// node_modules/svelte-feather-icons/src/icons/ColumnsIcon.svelte
var file69 = "node_modules/svelte-feather-icons/src/icons/ColumnsIcon.svelte";
function create_fragment69(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18");
      add_location(path, file69, 13, 244, 528);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-columns " + /*customClass*/
      ctx[2]);
      add_location(svg, file69, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-columns " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ColumnsIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ColumnsIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ColumnsIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ColumnsIcon",
      options,
      id: create_fragment69.name
    });
  }
  get size() {
    throw new Error("<ColumnsIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ColumnsIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ColumnsIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ColumnsIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ColumnsIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ColumnsIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ColumnsIcon_default = ColumnsIcon;

// node_modules/svelte-feather-icons/src/icons/CommandIcon.svelte
var file70 = "node_modules/svelte-feather-icons/src/icons/CommandIcon.svelte";
function create_fragment70(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z");
      add_location(path, file70, 13, 244, 528);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-command " + /*customClass*/
      ctx[2]);
      add_location(svg, file70, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-command " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance70($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CommandIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CommandIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CommandIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance70, create_fragment70, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CommandIcon",
      options,
      id: create_fragment70.name
    });
  }
  get size() {
    throw new Error("<CommandIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CommandIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CommandIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CommandIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CommandIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CommandIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CommandIcon_default = CommandIcon;

// node_modules/svelte-feather-icons/src/icons/CompassIcon.svelte
var file71 = "node_modules/svelte-feather-icons/src/icons/CompassIcon.svelte";
function create_fragment71(ctx) {
  let svg;
  let circle;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file71, 13, 244, 528);
      attr_dev(polygon, "points", "16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76");
      add_location(polygon, file71, 13, 284, 568);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-compass " + /*customClass*/
      ctx[2]);
      add_location(svg, file71, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-compass " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CompassIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CompassIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CompassIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CompassIcon",
      options,
      id: create_fragment71.name
    });
  }
  get size() {
    throw new Error("<CompassIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CompassIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CompassIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CompassIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CompassIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CompassIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CompassIcon_default = CompassIcon;

// node_modules/svelte-feather-icons/src/icons/CopyIcon.svelte
var file72 = "node_modules/svelte-feather-icons/src/icons/CopyIcon.svelte";
function create_fragment72(ctx) {
  let svg;
  let rect;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "9");
      attr_dev(rect, "y", "9");
      attr_dev(rect, "width", "13");
      attr_dev(rect, "height", "13");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file72, 13, 241, 525);
      attr_dev(path, "d", "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1");
      add_location(path, file72, 13, 303, 587);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-copy " + /*customClass*/
      ctx[2]);
      add_location(svg, file72, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-copy " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance72($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CopyIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CopyIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CopyIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance72, create_fragment72, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CopyIcon",
      options,
      id: create_fragment72.name
    });
  }
  get size() {
    throw new Error("<CopyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CopyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CopyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CopyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CopyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CopyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CopyIcon_default = CopyIcon;

// node_modules/svelte-feather-icons/src/icons/CornerDownLeftIcon.svelte
var file73 = "node_modules/svelte-feather-icons/src/icons/CornerDownLeftIcon.svelte";
function create_fragment73(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "9 10 4 15 9 20");
      add_location(polyline, file73, 13, 253, 537);
      attr_dev(path, "d", "M20 4v7a4 4 0 0 1-4 4H4");
      add_location(path, file73, 13, 298, 582);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-corner-down-left " + /*customClass*/
      ctx[2]);
      add_location(svg, file73, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-corner-down-left " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance73($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CornerDownLeftIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CornerDownLeftIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CornerDownLeftIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerDownLeftIcon",
      options,
      id: create_fragment73.name
    });
  }
  get size() {
    throw new Error("<CornerDownLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CornerDownLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CornerDownLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CornerDownLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CornerDownLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CornerDownLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CornerDownLeftIcon_default = CornerDownLeftIcon;

// node_modules/svelte-feather-icons/src/icons/CornerDownRightIcon.svelte
var file74 = "node_modules/svelte-feather-icons/src/icons/CornerDownRightIcon.svelte";
function create_fragment74(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "15 10 20 15 15 20");
      add_location(polyline, file74, 13, 254, 538);
      attr_dev(path, "d", "M4 4v7a4 4 0 0 0 4 4h12");
      add_location(path, file74, 13, 302, 586);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-corner-down-right " + /*customClass*/
      ctx[2]);
      add_location(svg, file74, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-corner-down-right " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance74($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CornerDownRightIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CornerDownRightIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CornerDownRightIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance74, create_fragment74, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerDownRightIcon",
      options,
      id: create_fragment74.name
    });
  }
  get size() {
    throw new Error("<CornerDownRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CornerDownRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CornerDownRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CornerDownRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CornerDownRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CornerDownRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CornerDownRightIcon_default = CornerDownRightIcon;

// node_modules/svelte-feather-icons/src/icons/CornerLeftDownIcon.svelte
var file75 = "node_modules/svelte-feather-icons/src/icons/CornerLeftDownIcon.svelte";
function create_fragment75(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "14 15 9 20 4 15");
      add_location(polyline, file75, 13, 253, 537);
      attr_dev(path, "d", "M20 4h-7a4 4 0 0 0-4 4v12");
      add_location(path, file75, 13, 299, 583);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-corner-left-down " + /*customClass*/
      ctx[2]);
      add_location(svg, file75, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-corner-left-down " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance75($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CornerLeftDownIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CornerLeftDownIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CornerLeftDownIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerLeftDownIcon",
      options,
      id: create_fragment75.name
    });
  }
  get size() {
    throw new Error("<CornerLeftDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CornerLeftDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CornerLeftDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CornerLeftDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CornerLeftDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CornerLeftDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CornerLeftDownIcon_default = CornerLeftDownIcon;

// node_modules/svelte-feather-icons/src/icons/CornerLeftUpIcon.svelte
var file76 = "node_modules/svelte-feather-icons/src/icons/CornerLeftUpIcon.svelte";
function create_fragment76(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "14 9 9 4 4 9");
      add_location(polyline, file76, 13, 251, 535);
      attr_dev(path, "d", "M20 20h-7a4 4 0 0 1-4-4V4");
      add_location(path, file76, 13, 294, 578);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-corner-left-up " + /*customClass*/
      ctx[2]);
      add_location(svg, file76, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-corner-left-up " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance76($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CornerLeftUpIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CornerLeftUpIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CornerLeftUpIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance76, create_fragment76, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerLeftUpIcon",
      options,
      id: create_fragment76.name
    });
  }
  get size() {
    throw new Error("<CornerLeftUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CornerLeftUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CornerLeftUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CornerLeftUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CornerLeftUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CornerLeftUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CornerLeftUpIcon_default = CornerLeftUpIcon;

// node_modules/svelte-feather-icons/src/icons/CornerRightDownIcon.svelte
var file77 = "node_modules/svelte-feather-icons/src/icons/CornerRightDownIcon.svelte";
function create_fragment77(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "10 15 15 20 20 15");
      add_location(polyline, file77, 13, 254, 538);
      attr_dev(path, "d", "M4 4h7a4 4 0 0 1 4 4v12");
      add_location(path, file77, 13, 302, 586);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-corner-right-down " + /*customClass*/
      ctx[2]);
      add_location(svg, file77, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-corner-right-down " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance77($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CornerRightDownIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CornerRightDownIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CornerRightDownIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment77, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerRightDownIcon",
      options,
      id: create_fragment77.name
    });
  }
  get size() {
    throw new Error("<CornerRightDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CornerRightDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CornerRightDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CornerRightDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CornerRightDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CornerRightDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CornerRightDownIcon_default = CornerRightDownIcon;

// node_modules/svelte-feather-icons/src/icons/CornerRightUpIcon.svelte
var file78 = "node_modules/svelte-feather-icons/src/icons/CornerRightUpIcon.svelte";
function create_fragment78(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "10 9 15 4 20 9");
      add_location(polyline, file78, 13, 252, 536);
      attr_dev(path, "d", "M4 20h7a4 4 0 0 0 4-4V4");
      add_location(path, file78, 13, 297, 581);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-corner-right-up " + /*customClass*/
      ctx[2]);
      add_location(svg, file78, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-corner-right-up " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance78($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CornerRightUpIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CornerRightUpIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CornerRightUpIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment78, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerRightUpIcon",
      options,
      id: create_fragment78.name
    });
  }
  get size() {
    throw new Error("<CornerRightUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CornerRightUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CornerRightUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CornerRightUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CornerRightUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CornerRightUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CornerRightUpIcon_default = CornerRightUpIcon;

// node_modules/svelte-feather-icons/src/icons/CornerUpLeftIcon.svelte
var file79 = "node_modules/svelte-feather-icons/src/icons/CornerUpLeftIcon.svelte";
function create_fragment79(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "9 14 4 9 9 4");
      add_location(polyline, file79, 13, 251, 535);
      attr_dev(path, "d", "M20 20v-7a4 4 0 0 0-4-4H4");
      add_location(path, file79, 13, 294, 578);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-corner-up-left " + /*customClass*/
      ctx[2]);
      add_location(svg, file79, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-corner-up-left " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance79($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CornerUpLeftIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CornerUpLeftIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CornerUpLeftIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance79, create_fragment79, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerUpLeftIcon",
      options,
      id: create_fragment79.name
    });
  }
  get size() {
    throw new Error("<CornerUpLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CornerUpLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CornerUpLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CornerUpLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CornerUpLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CornerUpLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CornerUpLeftIcon_default = CornerUpLeftIcon;

// node_modules/svelte-feather-icons/src/icons/CornerUpRightIcon.svelte
var file80 = "node_modules/svelte-feather-icons/src/icons/CornerUpRightIcon.svelte";
function create_fragment80(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "15 14 20 9 15 4");
      add_location(polyline, file80, 13, 252, 536);
      attr_dev(path, "d", "M4 20v-7a4 4 0 0 1 4-4h12");
      add_location(path, file80, 13, 298, 582);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-corner-up-right " + /*customClass*/
      ctx[2]);
      add_location(svg, file80, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-corner-up-right " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance80($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CornerUpRightIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CornerUpRightIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CornerUpRightIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerUpRightIcon",
      options,
      id: create_fragment80.name
    });
  }
  get size() {
    throw new Error("<CornerUpRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CornerUpRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CornerUpRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CornerUpRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CornerUpRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CornerUpRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CornerUpRightIcon_default = CornerUpRightIcon;

// node_modules/svelte-feather-icons/src/icons/CpuIcon.svelte
var file81 = "node_modules/svelte-feather-icons/src/icons/CpuIcon.svelte";
function create_fragment81(ctx) {
  let svg;
  let rect0;
  let rect1;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let line6;
  let line7;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      line6 = svg_element("line");
      line7 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect0 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect0).forEach(detach_dev);
      rect1 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect1).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      line6 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line6).forEach(detach_dev);
      line7 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line7).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect0, "x", "4");
      attr_dev(rect0, "y", "4");
      attr_dev(rect0, "width", "16");
      attr_dev(rect0, "height", "16");
      attr_dev(rect0, "rx", "2");
      attr_dev(rect0, "ry", "2");
      add_location(rect0, file81, 13, 240, 524);
      attr_dev(rect1, "x", "9");
      attr_dev(rect1, "y", "9");
      attr_dev(rect1, "width", "6");
      attr_dev(rect1, "height", "6");
      add_location(rect1, file81, 13, 302, 586);
      attr_dev(line0, "x1", "9");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "9");
      attr_dev(line0, "y2", "4");
      add_location(line0, file81, 13, 348, 632);
      attr_dev(line1, "x1", "15");
      attr_dev(line1, "y1", "1");
      attr_dev(line1, "x2", "15");
      attr_dev(line1, "y2", "4");
      add_location(line1, file81, 13, 389, 673);
      attr_dev(line2, "x1", "9");
      attr_dev(line2, "y1", "20");
      attr_dev(line2, "x2", "9");
      attr_dev(line2, "y2", "23");
      add_location(line2, file81, 13, 432, 716);
      attr_dev(line3, "x1", "15");
      attr_dev(line3, "y1", "20");
      attr_dev(line3, "x2", "15");
      attr_dev(line3, "y2", "23");
      add_location(line3, file81, 13, 475, 759);
      attr_dev(line4, "x1", "20");
      attr_dev(line4, "y1", "9");
      attr_dev(line4, "x2", "23");
      attr_dev(line4, "y2", "9");
      add_location(line4, file81, 13, 520, 804);
      attr_dev(line5, "x1", "20");
      attr_dev(line5, "y1", "14");
      attr_dev(line5, "x2", "23");
      attr_dev(line5, "y2", "14");
      add_location(line5, file81, 13, 563, 847);
      attr_dev(line6, "x1", "1");
      attr_dev(line6, "y1", "9");
      attr_dev(line6, "x2", "4");
      attr_dev(line6, "y2", "9");
      add_location(line6, file81, 13, 608, 892);
      attr_dev(line7, "x1", "1");
      attr_dev(line7, "y1", "14");
      attr_dev(line7, "x2", "4");
      attr_dev(line7, "y2", "14");
      add_location(line7, file81, 13, 649, 933);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-cpu " + /*customClass*/
      ctx[2]);
      add_location(svg, file81, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect0);
      append_hydration_dev(svg, rect1);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
      append_hydration_dev(svg, line6);
      append_hydration_dev(svg, line7);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-cpu " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance81($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CpuIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CpuIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CpuIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance81, create_fragment81, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CpuIcon",
      options,
      id: create_fragment81.name
    });
  }
  get size() {
    throw new Error("<CpuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CpuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CpuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CpuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CpuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CpuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CpuIcon_default = CpuIcon;

// node_modules/svelte-feather-icons/src/icons/CreditCardIcon.svelte
var file82 = "node_modules/svelte-feather-icons/src/icons/CreditCardIcon.svelte";
function create_fragment82(ctx) {
  let svg;
  let rect;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "4");
      attr_dev(rect, "width", "22");
      attr_dev(rect, "height", "16");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file82, 13, 248, 532);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "10");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "10");
      add_location(line, file82, 13, 310, 594);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-credit-card " + /*customClass*/
      ctx[2]);
      add_location(svg, file82, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-credit-card " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CreditCardIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CreditCardIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CreditCardIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment82, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CreditCardIcon",
      options,
      id: create_fragment82.name
    });
  }
  get size() {
    throw new Error("<CreditCardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CreditCardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CreditCardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CreditCardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CreditCardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CreditCardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CreditCardIcon_default = CreditCardIcon;

// node_modules/svelte-feather-icons/src/icons/CropIcon.svelte
var file83 = "node_modules/svelte-feather-icons/src/icons/CropIcon.svelte";
function create_fragment83(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M6.13 1L6 16a2 2 0 0 0 2 2h15");
      add_location(path0, file83, 13, 241, 525);
      attr_dev(path1, "d", "M1 6.13L16 6a2 2 0 0 1 2 2v15");
      add_location(path1, file83, 13, 288, 572);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-crop " + /*customClass*/
      ctx[2]);
      add_location(svg, file83, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-crop " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance83($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CropIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CropIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CropIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment83, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CropIcon",
      options,
      id: create_fragment83.name
    });
  }
  get size() {
    throw new Error("<CropIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CropIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CropIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CropIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CropIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CropIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CropIcon_default = CropIcon;

// node_modules/svelte-feather-icons/src/icons/CrosshairIcon.svelte
var file84 = "node_modules/svelte-feather-icons/src/icons/CrosshairIcon.svelte";
function create_fragment84(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let line2;
  let line3;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file84, 13, 246, 530);
      attr_dev(line0, "x1", "22");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "18");
      attr_dev(line0, "y2", "12");
      add_location(line0, file84, 13, 286, 570);
      attr_dev(line1, "x1", "6");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "2");
      attr_dev(line1, "y2", "12");
      add_location(line1, file84, 13, 331, 615);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "6");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "2");
      add_location(line2, file84, 13, 374, 658);
      attr_dev(line3, "x1", "12");
      attr_dev(line3, "y1", "22");
      attr_dev(line3, "x2", "12");
      attr_dev(line3, "y2", "18");
      add_location(line3, file84, 13, 417, 701);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-crosshair " + /*customClass*/
      ctx[2]);
      add_location(svg, file84, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-crosshair " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance84($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CrosshairIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CrosshairIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var CrosshairIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance84, create_fragment84, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CrosshairIcon",
      options,
      id: create_fragment84.name
    });
  }
  get size() {
    throw new Error("<CrosshairIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CrosshairIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<CrosshairIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<CrosshairIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CrosshairIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CrosshairIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CrosshairIcon_default = CrosshairIcon;

// node_modules/svelte-feather-icons/src/icons/DatabaseIcon.svelte
var file85 = "node_modules/svelte-feather-icons/src/icons/DatabaseIcon.svelte";
function create_fragment85(ctx) {
  let svg;
  let ellipse;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      ellipse = svg_element("ellipse");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      ellipse = claim_svg_element(svg_nodes, "ellipse", { cx: true, cy: true, rx: true, ry: true });
      children(ellipse).forEach(detach_dev);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ellipse, "cx", "12");
      attr_dev(ellipse, "cy", "5");
      attr_dev(ellipse, "rx", "9");
      attr_dev(ellipse, "ry", "3");
      add_location(ellipse, file85, 13, 245, 529);
      attr_dev(path0, "d", "M21 12c0 1.66-4 3-9 3s-9-1.34-9-3");
      add_location(path0, file85, 13, 293, 577);
      attr_dev(path1, "d", "M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5");
      add_location(path1, file85, 13, 344, 628);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-database " + /*customClass*/
      ctx[2]);
      add_location(svg, file85, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, ellipse);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-database " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance85($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DatabaseIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DatabaseIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DatabaseIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment85, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DatabaseIcon",
      options,
      id: create_fragment85.name
    });
  }
  get size() {
    throw new Error("<DatabaseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DatabaseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DatabaseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DatabaseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DatabaseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DatabaseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DatabaseIcon_default = DatabaseIcon;

// node_modules/svelte-feather-icons/src/icons/DeleteIcon.svelte
var file86 = "node_modules/svelte-feather-icons/src/icons/DeleteIcon.svelte";
function create_fragment86(ctx) {
  let svg;
  let path;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z");
      add_location(path, file86, 13, 243, 527);
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "15");
      add_location(line0, file86, 13, 311, 595);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "18");
      attr_dev(line1, "y2", "15");
      add_location(line1, file86, 13, 355, 639);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-delete " + /*customClass*/
      ctx[2]);
      add_location(svg, file86, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-delete " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance86($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DeleteIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DeleteIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DeleteIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DeleteIcon",
      options,
      id: create_fragment86.name
    });
  }
  get size() {
    throw new Error("<DeleteIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DeleteIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DeleteIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DeleteIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DeleteIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DeleteIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DeleteIcon_default = DeleteIcon;

// node_modules/svelte-feather-icons/src/icons/DiscIcon.svelte
var file87 = "node_modules/svelte-feather-icons/src/icons/DiscIcon.svelte";
function create_fragment87(ctx) {
  let svg;
  let circle0;
  let circle1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "10");
      add_location(circle0, file87, 13, 241, 525);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file87, 13, 281, 565);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-disc " + /*customClass*/
      ctx[2]);
      add_location(svg, file87, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-disc " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance87($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DiscIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DiscIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DiscIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance87, create_fragment87, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DiscIcon",
      options,
      id: create_fragment87.name
    });
  }
  get size() {
    throw new Error("<DiscIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DiscIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DiscIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DiscIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DiscIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DiscIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DiscIcon_default = DiscIcon;

// node_modules/svelte-feather-icons/src/icons/DivideCircleIcon.svelte
var file88 = "node_modules/svelte-feather-icons/src/icons/DivideCircleIcon.svelte";
function create_fragment88(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "12");
      add_location(line0, file88, 13, 250, 534);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "16");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "16");
      add_location(line1, file88, 13, 294, 578);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "8");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "8");
      add_location(line2, file88, 13, 339, 623);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file88, 13, 382, 666);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-divide-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file88, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-divide-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance88($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DivideCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DivideCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DivideCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DivideCircleIcon",
      options,
      id: create_fragment88.name
    });
  }
  get size() {
    throw new Error("<DivideCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DivideCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DivideCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DivideCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DivideCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DivideCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DivideCircleIcon_default = DivideCircleIcon;

// node_modules/svelte-feather-icons/src/icons/DivideSquareIcon.svelte
var file89 = "node_modules/svelte-feather-icons/src/icons/DivideSquareIcon.svelte";
function create_fragment89(ctx) {
  let svg;
  let rect;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file89, 13, 250, 534);
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "12");
      add_location(line0, file89, 13, 312, 596);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "16");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "16");
      add_location(line1, file89, 13, 356, 640);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "8");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "8");
      add_location(line2, file89, 13, 401, 685);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-divide-square " + /*customClass*/
      ctx[2]);
      add_location(svg, file89, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-divide-square " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance89($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DivideSquareIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DivideSquareIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DivideSquareIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance89, create_fragment89, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DivideSquareIcon",
      options,
      id: create_fragment89.name
    });
  }
  get size() {
    throw new Error("<DivideSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DivideSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DivideSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DivideSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DivideSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DivideSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DivideSquareIcon_default = DivideSquareIcon;

// node_modules/svelte-feather-icons/src/icons/DivideIcon.svelte
var file90 = "node_modules/svelte-feather-icons/src/icons/DivideIcon.svelte";
function create_fragment90(ctx) {
  let svg;
  let circle0;
  let line;
  let circle1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      line = svg_element("line");
      circle1 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "6");
      attr_dev(circle0, "r", "2");
      add_location(circle0, file90, 13, 243, 527);
      attr_dev(line, "x1", "5");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "19");
      attr_dev(line, "y2", "12");
      add_location(line, file90, 13, 281, 565);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "18");
      attr_dev(circle1, "r", "2");
      add_location(circle1, file90, 13, 325, 609);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-divide " + /*customClass*/
      ctx[2]);
      add_location(svg, file90, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, circle1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-divide " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance90($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DivideIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DivideIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DivideIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance90, create_fragment90, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DivideIcon",
      options,
      id: create_fragment90.name
    });
  }
  get size() {
    throw new Error("<DivideIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DivideIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DivideIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DivideIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DivideIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DivideIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DivideIcon_default = DivideIcon;

// node_modules/svelte-feather-icons/src/icons/DollarSignIcon.svelte
var file91 = "node_modules/svelte-feather-icons/src/icons/DollarSignIcon.svelte";
function create_fragment91(ctx) {
  let svg;
  let line;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "23");
      add_location(line, file91, 13, 248, 532);
      attr_dev(path, "d", "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6");
      add_location(path, file91, 13, 292, 576);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-dollar-sign " + /*customClass*/
      ctx[2]);
      add_location(svg, file91, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-dollar-sign " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment91.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance91($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DollarSignIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DollarSignIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DollarSignIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance91, create_fragment91, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DollarSignIcon",
      options,
      id: create_fragment91.name
    });
  }
  get size() {
    throw new Error("<DollarSignIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DollarSignIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DollarSignIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DollarSignIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DollarSignIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DollarSignIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DollarSignIcon_default = DollarSignIcon;

// node_modules/svelte-feather-icons/src/icons/DownloadCloudIcon.svelte
var file92 = "node_modules/svelte-feather-icons/src/icons/DownloadCloudIcon.svelte";
function create_fragment92(ctx) {
  let svg;
  let polyline;
  let line;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "8 17 12 21 16 17");
      add_location(polyline, file92, 13, 251, 535);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "21");
      add_location(line, file92, 13, 298, 582);
      attr_dev(path, "d", "M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29");
      add_location(path, file92, 13, 343, 627);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-download-cloud " + /*customClass*/
      ctx[2]);
      add_location(svg, file92, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-download-cloud " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment92.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance92($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DownloadCloudIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DownloadCloudIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DownloadCloudIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance92, create_fragment92, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DownloadCloudIcon",
      options,
      id: create_fragment92.name
    });
  }
  get size() {
    throw new Error("<DownloadCloudIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DownloadCloudIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DownloadCloudIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DownloadCloudIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DownloadCloudIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DownloadCloudIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DownloadCloudIcon_default = DownloadCloudIcon;

// node_modules/svelte-feather-icons/src/icons/DownloadIcon.svelte
var file93 = "node_modules/svelte-feather-icons/src/icons/DownloadIcon.svelte";
function create_fragment93(ctx) {
  let svg;
  let path;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
      add_location(path, file93, 13, 245, 529);
      attr_dev(polyline, "points", "7 10 12 15 17 10");
      add_location(polyline, file93, 13, 304, 588);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "15");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "3");
      add_location(line, file93, 13, 351, 635);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-download " + /*customClass*/
      ctx[2]);
      add_location(svg, file93, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-download " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment93.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance93($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DownloadIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DownloadIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DownloadIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance93, create_fragment93, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DownloadIcon",
      options,
      id: create_fragment93.name
    });
  }
  get size() {
    throw new Error("<DownloadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DownloadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DownloadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DownloadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DownloadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DownloadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DownloadIcon_default = DownloadIcon;

// node_modules/svelte-feather-icons/src/icons/DribbbleIcon.svelte
var file94 = "node_modules/svelte-feather-icons/src/icons/DribbbleIcon.svelte";
function create_fragment94(ctx) {
  let svg;
  let circle;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file94, 13, 245, 529);
      attr_dev(path, "d", "M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32");
      add_location(path, file94, 13, 285, 569);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-dribbble " + /*customClass*/
      ctx[2]);
      add_location(svg, file94, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-dribbble " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment94.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance94($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DribbbleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DribbbleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DribbbleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance94, create_fragment94, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DribbbleIcon",
      options,
      id: create_fragment94.name
    });
  }
  get size() {
    throw new Error("<DribbbleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DribbbleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DribbbleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DribbbleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DribbbleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DribbbleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DribbbleIcon_default = DribbbleIcon;

// node_modules/svelte-feather-icons/src/icons/DropletIcon.svelte
var file95 = "node_modules/svelte-feather-icons/src/icons/DropletIcon.svelte";
function create_fragment95(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z");
      add_location(path, file95, 13, 244, 528);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-droplet " + /*customClass*/
      ctx[2]);
      add_location(svg, file95, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-droplet " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment95.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance95($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropletIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DropletIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var DropletIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance95, create_fragment95, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropletIcon",
      options,
      id: create_fragment95.name
    });
  }
  get size() {
    throw new Error("<DropletIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DropletIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<DropletIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<DropletIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DropletIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DropletIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropletIcon_default = DropletIcon;

// node_modules/svelte-feather-icons/src/icons/Edit2Icon.svelte
var file96 = "node_modules/svelte-feather-icons/src/icons/Edit2Icon.svelte";
function create_fragment96(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z");
      add_location(path, file96, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-edit-2 " + /*customClass*/
      ctx[2]);
      add_location(svg, file96, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-edit-2 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment96.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance96($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Edit2Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Edit2Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var Edit2Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance96, create_fragment96, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Edit2Icon",
      options,
      id: create_fragment96.name
    });
  }
  get size() {
    throw new Error("<Edit2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Edit2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Edit2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Edit2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Edit2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Edit2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Edit2Icon_default = Edit2Icon;

// node_modules/svelte-feather-icons/src/icons/Edit3Icon.svelte
var file97 = "node_modules/svelte-feather-icons/src/icons/Edit3Icon.svelte";
function create_fragment97(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12 20h9");
      add_location(path0, file97, 13, 243, 527);
      attr_dev(path1, "d", "M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z");
      add_location(path1, file97, 13, 269, 553);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-edit-3 " + /*customClass*/
      ctx[2]);
      add_location(svg, file97, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-edit-3 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment97.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance97($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Edit3Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Edit3Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var Edit3Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance97, create_fragment97, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Edit3Icon",
      options,
      id: create_fragment97.name
    });
  }
  get size() {
    throw new Error("<Edit3Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Edit3Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Edit3Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Edit3Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Edit3Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Edit3Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Edit3Icon_default = Edit3Icon;

// node_modules/svelte-feather-icons/src/icons/EditIcon.svelte
var file98 = "node_modules/svelte-feather-icons/src/icons/EditIcon.svelte";
function create_fragment98(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7");
      add_location(path0, file98, 13, 241, 525);
      attr_dev(path1, "d", "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z");
      add_location(path1, file98, 13, 317, 601);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-edit " + /*customClass*/
      ctx[2]);
      add_location(svg, file98, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-edit " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment98.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance98($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EditIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EditIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var EditIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance98, create_fragment98, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EditIcon",
      options,
      id: create_fragment98.name
    });
  }
  get size() {
    throw new Error("<EditIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<EditIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<EditIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<EditIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<EditIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<EditIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EditIcon_default = EditIcon;

// node_modules/svelte-feather-icons/src/icons/ExternalLinkIcon.svelte
var file99 = "node_modules/svelte-feather-icons/src/icons/ExternalLinkIcon.svelte";
function create_fragment99(ctx) {
  let svg;
  let path;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6");
      add_location(path, file99, 13, 250, 534);
      attr_dev(polyline, "points", "15 3 21 3 21 9");
      add_location(polyline, file99, 13, 324, 608);
      attr_dev(line, "x1", "10");
      attr_dev(line, "y1", "14");
      attr_dev(line, "x2", "21");
      attr_dev(line, "y2", "3");
      add_location(line, file99, 13, 369, 653);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-external-link " + /*customClass*/
      ctx[2]);
      add_location(svg, file99, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-external-link " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment99.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance99($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ExternalLinkIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ExternalLinkIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ExternalLinkIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance99, create_fragment99, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ExternalLinkIcon",
      options,
      id: create_fragment99.name
    });
  }
  get size() {
    throw new Error("<ExternalLinkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ExternalLinkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ExternalLinkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ExternalLinkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ExternalLinkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ExternalLinkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ExternalLinkIcon_default = ExternalLinkIcon;

// node_modules/svelte-feather-icons/src/icons/EyeOffIcon.svelte
var file100 = "node_modules/svelte-feather-icons/src/icons/EyeOffIcon.svelte";
function create_fragment100(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24");
      add_location(path, file100, 13, 244, 528);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file100, 13, 442, 726);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-eye-off " + /*customClass*/
      ctx[2]);
      add_location(svg, file100, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-eye-off " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment100.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance100($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EyeOffIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EyeOffIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var EyeOffIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance100, create_fragment100, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EyeOffIcon",
      options,
      id: create_fragment100.name
    });
  }
  get size() {
    throw new Error("<EyeOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<EyeOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<EyeOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<EyeOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<EyeOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<EyeOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EyeOffIcon_default = EyeOffIcon;

// node_modules/svelte-feather-icons/src/icons/EyeIcon.svelte
var file101 = "node_modules/svelte-feather-icons/src/icons/EyeIcon.svelte";
function create_fragment101(ctx) {
  let svg;
  let path;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z");
      add_location(path, file101, 13, 240, 524);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "3");
      add_location(circle, file101, 13, 302, 586);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-eye " + /*customClass*/
      ctx[2]);
      add_location(svg, file101, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-eye " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment101.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance101($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EyeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EyeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var EyeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance101, create_fragment101, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EyeIcon",
      options,
      id: create_fragment101.name
    });
  }
  get size() {
    throw new Error("<EyeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<EyeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<EyeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<EyeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<EyeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<EyeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EyeIcon_default = EyeIcon;

// node_modules/svelte-feather-icons/src/icons/FacebookIcon.svelte
var file102 = "node_modules/svelte-feather-icons/src/icons/FacebookIcon.svelte";
function create_fragment102(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z");
      add_location(path, file102, 13, 245, 529);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-facebook " + /*customClass*/
      ctx[2]);
      add_location(svg, file102, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-facebook " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment102.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance102($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FacebookIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FacebookIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FacebookIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance102, create_fragment102, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FacebookIcon",
      options,
      id: create_fragment102.name
    });
  }
  get size() {
    throw new Error("<FacebookIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FacebookIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FacebookIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FacebookIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FacebookIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FacebookIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FacebookIcon_default = FacebookIcon;

// node_modules/svelte-feather-icons/src/icons/FastForwardIcon.svelte
var file103 = "node_modules/svelte-feather-icons/src/icons/FastForwardIcon.svelte";
function create_fragment103(ctx) {
  let svg;
  let polygon0;
  let polygon1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon0 = svg_element("polygon");
      polygon1 = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon0 = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon0).forEach(detach_dev);
      polygon1 = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon0, "points", "13 19 22 12 13 5 13 19");
      add_location(polygon0, file103, 13, 249, 533);
      attr_dev(polygon1, "points", "2 19 11 12 2 5 2 19");
      add_location(polygon1, file103, 13, 300, 584);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-fast-forward " + /*customClass*/
      ctx[2]);
      add_location(svg, file103, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon0);
      append_hydration_dev(svg, polygon1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-fast-forward " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment103.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance103($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FastForwardIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FastForwardIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FastForwardIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance103, create_fragment103, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FastForwardIcon",
      options,
      id: create_fragment103.name
    });
  }
  get size() {
    throw new Error("<FastForwardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FastForwardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FastForwardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FastForwardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FastForwardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FastForwardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FastForwardIcon_default = FastForwardIcon;

// node_modules/svelte-feather-icons/src/icons/FeatherIcon.svelte
var file104 = "node_modules/svelte-feather-icons/src/icons/FeatherIcon.svelte";
function create_fragment104(ctx) {
  let svg;
  let path;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z");
      add_location(path, file104, 13, 244, 528);
      attr_dev(line0, "x1", "16");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "2");
      attr_dev(line0, "y2", "22");
      add_location(line0, file104, 13, 309, 593);
      attr_dev(line1, "x1", "17.5");
      attr_dev(line1, "y1", "15");
      attr_dev(line1, "x2", "9");
      attr_dev(line1, "y2", "15");
      add_location(line1, file104, 13, 352, 636);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-feather " + /*customClass*/
      ctx[2]);
      add_location(svg, file104, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-feather " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment104.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance104($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FeatherIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FeatherIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FeatherIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance104, create_fragment104, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FeatherIcon",
      options,
      id: create_fragment104.name
    });
  }
  get size() {
    throw new Error("<FeatherIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FeatherIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FeatherIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FeatherIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FeatherIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FeatherIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FeatherIcon_default = FeatherIcon;

// node_modules/svelte-feather-icons/src/icons/FigmaIcon.svelte
var file105 = "node_modules/svelte-feather-icons/src/icons/FigmaIcon.svelte";
function create_fragment105(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let path3;
  let path4;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path3).forEach(detach_dev);
      path4 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path4).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z");
      add_location(path0, file105, 13, 242, 526);
      attr_dev(path1, "d", "M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z");
      add_location(path1, file105, 13, 316, 600);
      attr_dev(path2, "d", "M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z");
      add_location(path2, file105, 13, 367, 651);
      attr_dev(path3, "d", "M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z");
      add_location(path3, file105, 13, 430, 714);
      attr_dev(path4, "d", "M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z");
      add_location(path4, file105, 13, 502, 786);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-figma " + /*customClass*/
      ctx[2]);
      add_location(svg, file105, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, path3);
      append_hydration_dev(svg, path4);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-figma " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment105.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance105($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FigmaIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FigmaIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FigmaIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance105, create_fragment105, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FigmaIcon",
      options,
      id: create_fragment105.name
    });
  }
  get size() {
    throw new Error("<FigmaIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FigmaIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FigmaIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FigmaIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FigmaIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FigmaIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FigmaIcon_default = FigmaIcon;

// node_modules/svelte-feather-icons/src/icons/FileMinusIcon.svelte
var file106 = "node_modules/svelte-feather-icons/src/icons/FileMinusIcon.svelte";
function create_fragment106(ctx) {
  let svg;
  let path;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
      add_location(path, file106, 13, 247, 531);
      attr_dev(polyline, "points", "14 2 14 8 20 8");
      add_location(polyline, file106, 13, 323, 607);
      attr_dev(line, "x1", "9");
      attr_dev(line, "y1", "15");
      attr_dev(line, "x2", "15");
      attr_dev(line, "y2", "15");
      add_location(line, file106, 13, 368, 652);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-file-minus " + /*customClass*/
      ctx[2]);
      add_location(svg, file106, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-file-minus " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment106.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance106($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileMinusIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FileMinusIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FileMinusIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance106, create_fragment106, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileMinusIcon",
      options,
      id: create_fragment106.name
    });
  }
  get size() {
    throw new Error("<FileMinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FileMinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FileMinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FileMinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FileMinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FileMinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileMinusIcon_default = FileMinusIcon;

// node_modules/svelte-feather-icons/src/icons/FilePlusIcon.svelte
var file107 = "node_modules/svelte-feather-icons/src/icons/FilePlusIcon.svelte";
function create_fragment107(ctx) {
  let svg;
  let path;
  let polyline;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
      add_location(path, file107, 13, 246, 530);
      attr_dev(polyline, "points", "14 2 14 8 20 8");
      add_location(polyline, file107, 13, 322, 606);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "18");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "12");
      add_location(line0, file107, 13, 367, 651);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "15");
      attr_dev(line1, "x2", "15");
      attr_dev(line1, "y2", "15");
      add_location(line1, file107, 13, 412, 696);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-file-plus " + /*customClass*/
      ctx[2]);
      add_location(svg, file107, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-file-plus " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment107.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance107($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FilePlusIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FilePlusIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FilePlusIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance107, create_fragment107, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FilePlusIcon",
      options,
      id: create_fragment107.name
    });
  }
  get size() {
    throw new Error("<FilePlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FilePlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FilePlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FilePlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FilePlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FilePlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FilePlusIcon_default = FilePlusIcon;

// node_modules/svelte-feather-icons/src/icons/FileTextIcon.svelte
var file108 = "node_modules/svelte-feather-icons/src/icons/FileTextIcon.svelte";
function create_fragment108(ctx) {
  let svg;
  let path;
  let polyline0;
  let line0;
  let line1;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline0 = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
      add_location(path, file108, 13, 246, 530);
      attr_dev(polyline0, "points", "14 2 14 8 20 8");
      add_location(polyline0, file108, 13, 322, 606);
      attr_dev(line0, "x1", "16");
      attr_dev(line0, "y1", "13");
      attr_dev(line0, "x2", "8");
      attr_dev(line0, "y2", "13");
      add_location(line0, file108, 13, 367, 651);
      attr_dev(line1, "x1", "16");
      attr_dev(line1, "y1", "17");
      attr_dev(line1, "x2", "8");
      attr_dev(line1, "y2", "17");
      add_location(line1, file108, 13, 411, 695);
      attr_dev(polyline1, "points", "10 9 9 9 8 9");
      add_location(polyline1, file108, 13, 455, 739);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-file-text " + /*customClass*/
      ctx[2]);
      add_location(svg, file108, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-file-text " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment108.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance108($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileTextIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FileTextIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FileTextIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance108, create_fragment108, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileTextIcon",
      options,
      id: create_fragment108.name
    });
  }
  get size() {
    throw new Error("<FileTextIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FileTextIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FileTextIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FileTextIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FileTextIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FileTextIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileTextIcon_default = FileTextIcon;

// node_modules/svelte-feather-icons/src/icons/FileIcon.svelte
var file109 = "node_modules/svelte-feather-icons/src/icons/FileIcon.svelte";
function create_fragment109(ctx) {
  let svg;
  let path;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z");
      add_location(path, file109, 13, 241, 525);
      attr_dev(polyline, "points", "13 2 13 9 20 9");
      add_location(polyline, file109, 13, 317, 601);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-file " + /*customClass*/
      ctx[2]);
      add_location(svg, file109, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-file " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment109.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance109($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FileIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FileIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance109, create_fragment109, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileIcon",
      options,
      id: create_fragment109.name
    });
  }
  get size() {
    throw new Error("<FileIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FileIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FileIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FileIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FileIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FileIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileIcon_default = FileIcon;

// node_modules/svelte-feather-icons/src/icons/FilmIcon.svelte
var file110 = "node_modules/svelte-feather-icons/src/icons/FilmIcon.svelte";
function create_fragment110(ctx) {
  let svg;
  let rect;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let line6;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      line6 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      line6 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line6).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "20");
      attr_dev(rect, "rx", "2.18");
      attr_dev(rect, "ry", "2.18");
      add_location(rect, file110, 13, 241, 525);
      attr_dev(line0, "x1", "7");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "7");
      attr_dev(line0, "y2", "22");
      add_location(line0, file110, 13, 309, 593);
      attr_dev(line1, "x1", "17");
      attr_dev(line1, "y1", "2");
      attr_dev(line1, "x2", "17");
      attr_dev(line1, "y2", "22");
      add_location(line1, file110, 13, 351, 635);
      attr_dev(line2, "x1", "2");
      attr_dev(line2, "y1", "12");
      attr_dev(line2, "x2", "22");
      attr_dev(line2, "y2", "12");
      add_location(line2, file110, 13, 395, 679);
      attr_dev(line3, "x1", "2");
      attr_dev(line3, "y1", "7");
      attr_dev(line3, "x2", "7");
      attr_dev(line3, "y2", "7");
      add_location(line3, file110, 13, 439, 723);
      attr_dev(line4, "x1", "2");
      attr_dev(line4, "y1", "17");
      attr_dev(line4, "x2", "7");
      attr_dev(line4, "y2", "17");
      add_location(line4, file110, 13, 480, 764);
      attr_dev(line5, "x1", "17");
      attr_dev(line5, "y1", "17");
      attr_dev(line5, "x2", "22");
      attr_dev(line5, "y2", "17");
      add_location(line5, file110, 13, 523, 807);
      attr_dev(line6, "x1", "17");
      attr_dev(line6, "y1", "7");
      attr_dev(line6, "x2", "22");
      attr_dev(line6, "y2", "7");
      add_location(line6, file110, 13, 568, 852);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-film " + /*customClass*/
      ctx[2]);
      add_location(svg, file110, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
      append_hydration_dev(svg, line6);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-film " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment110.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance110($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FilmIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FilmIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FilmIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance110, create_fragment110, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FilmIcon",
      options,
      id: create_fragment110.name
    });
  }
  get size() {
    throw new Error("<FilmIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FilmIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FilmIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FilmIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FilmIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FilmIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FilmIcon_default = FilmIcon;

// node_modules/svelte-feather-icons/src/icons/FilterIcon.svelte
var file111 = "node_modules/svelte-feather-icons/src/icons/FilterIcon.svelte";
function create_fragment111(ctx) {
  let svg;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3");
      add_location(polygon, file111, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-filter " + /*customClass*/
      ctx[2]);
      add_location(svg, file111, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-filter " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment111.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance111($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FilterIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FilterIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FilterIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance111, create_fragment111, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FilterIcon",
      options,
      id: create_fragment111.name
    });
  }
  get size() {
    throw new Error("<FilterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FilterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FilterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FilterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FilterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FilterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FilterIcon_default = FilterIcon;

// node_modules/svelte-feather-icons/src/icons/FlagIcon.svelte
var file112 = "node_modules/svelte-feather-icons/src/icons/FlagIcon.svelte";
function create_fragment112(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z");
      add_location(path, file112, 13, 241, 525);
      attr_dev(line, "x1", "4");
      attr_dev(line, "y1", "22");
      attr_dev(line, "x2", "4");
      attr_dev(line, "y2", "15");
      add_location(line, file112, 13, 316, 600);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-flag " + /*customClass*/
      ctx[2]);
      add_location(svg, file112, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-flag " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment112.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance112($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FlagIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FlagIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FlagIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance112, create_fragment112, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FlagIcon",
      options,
      id: create_fragment112.name
    });
  }
  get size() {
    throw new Error("<FlagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FlagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FlagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FlagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FlagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FlagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FlagIcon_default = FlagIcon;

// node_modules/svelte-feather-icons/src/icons/FolderMinusIcon.svelte
var file113 = "node_modules/svelte-feather-icons/src/icons/FolderMinusIcon.svelte";
function create_fragment113(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
      add_location(path, file113, 13, 249, 533);
      attr_dev(line, "x1", "9");
      attr_dev(line, "y1", "14");
      attr_dev(line, "x2", "15");
      attr_dev(line, "y2", "14");
      add_location(line, file113, 13, 342, 626);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-folder-minus " + /*customClass*/
      ctx[2]);
      add_location(svg, file113, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-folder-minus " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment113.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance113($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FolderMinusIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FolderMinusIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FolderMinusIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance113, create_fragment113, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FolderMinusIcon",
      options,
      id: create_fragment113.name
    });
  }
  get size() {
    throw new Error("<FolderMinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FolderMinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FolderMinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FolderMinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FolderMinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FolderMinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FolderMinusIcon_default = FolderMinusIcon;

// node_modules/svelte-feather-icons/src/icons/FolderPlusIcon.svelte
var file114 = "node_modules/svelte-feather-icons/src/icons/FolderPlusIcon.svelte";
function create_fragment114(ctx) {
  let svg;
  let path;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
      add_location(path, file114, 13, 248, 532);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "11");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "17");
      add_location(line0, file114, 13, 341, 625);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "14");
      attr_dev(line1, "x2", "15");
      attr_dev(line1, "y2", "14");
      add_location(line1, file114, 13, 386, 670);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-folder-plus " + /*customClass*/
      ctx[2]);
      add_location(svg, file114, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-folder-plus " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment114.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance114($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FolderPlusIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FolderPlusIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FolderPlusIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance114, create_fragment114, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FolderPlusIcon",
      options,
      id: create_fragment114.name
    });
  }
  get size() {
    throw new Error("<FolderPlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FolderPlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FolderPlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FolderPlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FolderPlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FolderPlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FolderPlusIcon_default = FolderPlusIcon;

// node_modules/svelte-feather-icons/src/icons/FolderIcon.svelte
var file115 = "node_modules/svelte-feather-icons/src/icons/FolderIcon.svelte";
function create_fragment115(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
      add_location(path, file115, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-folder " + /*customClass*/
      ctx[2]);
      add_location(svg, file115, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-folder " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment115.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance115($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FolderIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FolderIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FolderIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance115, create_fragment115, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FolderIcon",
      options,
      id: create_fragment115.name
    });
  }
  get size() {
    throw new Error("<FolderIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FolderIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FolderIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FolderIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FolderIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FolderIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FolderIcon_default = FolderIcon;

// node_modules/svelte-feather-icons/src/icons/FramerIcon.svelte
var file116 = "node_modules/svelte-feather-icons/src/icons/FramerIcon.svelte";
function create_fragment116(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7");
      add_location(path, file116, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-framer " + /*customClass*/
      ctx[2]);
      add_location(svg, file116, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-framer " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment116.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance116($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FramerIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FramerIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FramerIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance116, create_fragment116, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FramerIcon",
      options,
      id: create_fragment116.name
    });
  }
  get size() {
    throw new Error("<FramerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FramerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FramerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FramerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FramerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FramerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FramerIcon_default = FramerIcon;

// node_modules/svelte-feather-icons/src/icons/FrownIcon.svelte
var file117 = "node_modules/svelte-feather-icons/src/icons/FrownIcon.svelte";
function create_fragment117(ctx) {
  let svg;
  let circle;
  let path;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file117, 13, 242, 526);
      attr_dev(path, "d", "M16 16s-1.5-2-4-2-4 2-4 2");
      add_location(path, file117, 13, 282, 566);
      attr_dev(line0, "x1", "9");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "9.01");
      attr_dev(line0, "y2", "9");
      add_location(line0, file117, 13, 325, 609);
      attr_dev(line1, "x1", "15");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "15.01");
      attr_dev(line1, "y2", "9");
      add_location(line1, file117, 13, 369, 653);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-frown " + /*customClass*/
      ctx[2]);
      add_location(svg, file117, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-frown " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment117.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance117($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FrownIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FrownIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var FrownIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance117, create_fragment117, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FrownIcon",
      options,
      id: create_fragment117.name
    });
  }
  get size() {
    throw new Error("<FrownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FrownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FrownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FrownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FrownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FrownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FrownIcon_default = FrownIcon;

// node_modules/svelte-feather-icons/src/icons/GiftIcon.svelte
var file118 = "node_modules/svelte-feather-icons/src/icons/GiftIcon.svelte";
function create_fragment118(ctx) {
  let svg;
  let polyline;
  let rect;
  let line;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      rect = svg_element("rect");
      line = svg_element("line");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "20 12 20 22 4 22 4 12");
      add_location(polyline, file118, 13, 241, 525);
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "7");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "5");
      add_location(rect, file118, 13, 293, 577);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "22");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "7");
      add_location(line, file118, 13, 340, 624);
      attr_dev(path0, "d", "M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z");
      add_location(path0, file118, 13, 384, 668);
      attr_dev(path1, "d", "M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z");
      add_location(path1, file118, 13, 445, 729);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-gift " + /*customClass*/
      ctx[2]);
      add_location(svg, file118, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-gift " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment118.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance118($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GiftIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GiftIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var GiftIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance118, create_fragment118, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GiftIcon",
      options,
      id: create_fragment118.name
    });
  }
  get size() {
    throw new Error("<GiftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<GiftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<GiftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<GiftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<GiftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<GiftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GiftIcon_default = GiftIcon;

// node_modules/svelte-feather-icons/src/icons/GitBranchIcon.svelte
var file119 = "node_modules/svelte-feather-icons/src/icons/GitBranchIcon.svelte";
function create_fragment119(ctx) {
  let svg;
  let line;
  let circle0;
  let circle1;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "6");
      attr_dev(line, "y1", "3");
      attr_dev(line, "x2", "6");
      attr_dev(line, "y2", "15");
      add_location(line, file119, 13, 247, 531);
      attr_dev(circle0, "cx", "18");
      attr_dev(circle0, "cy", "6");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file119, 13, 289, 573);
      attr_dev(circle1, "cx", "6");
      attr_dev(circle1, "cy", "18");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file119, 13, 327, 611);
      attr_dev(path, "d", "M18 9a9 9 0 0 1-9 9");
      add_location(path, file119, 13, 365, 649);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-git-branch " + /*customClass*/
      ctx[2]);
      add_location(svg, file119, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-git-branch " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment119.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance119($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GitBranchIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GitBranchIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var GitBranchIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance119, create_fragment119, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GitBranchIcon",
      options,
      id: create_fragment119.name
    });
  }
  get size() {
    throw new Error("<GitBranchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<GitBranchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<GitBranchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<GitBranchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<GitBranchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<GitBranchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GitBranchIcon_default = GitBranchIcon;

// node_modules/svelte-feather-icons/src/icons/GitCommitIcon.svelte
var file120 = "node_modules/svelte-feather-icons/src/icons/GitCommitIcon.svelte";
function create_fragment120(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "4");
      add_location(circle, file120, 13, 247, 531);
      attr_dev(line0, "x1", "1.05");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "7");
      attr_dev(line0, "y2", "12");
      add_location(line0, file120, 13, 286, 570);
      attr_dev(line1, "x1", "17.01");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "22.96");
      attr_dev(line1, "y2", "12");
      add_location(line1, file120, 13, 332, 616);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-git-commit " + /*customClass*/
      ctx[2]);
      add_location(svg, file120, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-git-commit " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment120.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance120($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GitCommitIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GitCommitIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var GitCommitIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance120, create_fragment120, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GitCommitIcon",
      options,
      id: create_fragment120.name
    });
  }
  get size() {
    throw new Error("<GitCommitIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<GitCommitIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<GitCommitIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<GitCommitIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<GitCommitIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<GitCommitIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GitCommitIcon_default = GitCommitIcon;

// node_modules/svelte-feather-icons/src/icons/GitMergeIcon.svelte
var file121 = "node_modules/svelte-feather-icons/src/icons/GitMergeIcon.svelte";
function create_fragment121(ctx) {
  let svg;
  let circle0;
  let circle1;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "18");
      attr_dev(circle0, "cy", "18");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file121, 13, 246, 530);
      attr_dev(circle1, "cx", "6");
      attr_dev(circle1, "cy", "6");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file121, 13, 285, 569);
      attr_dev(path, "d", "M6 21V9a9 9 0 0 0 9 9");
      add_location(path, file121, 13, 322, 606);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-git-merge " + /*customClass*/
      ctx[2]);
      add_location(svg, file121, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-git-merge " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment121.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance121($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GitMergeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GitMergeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var GitMergeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance121, create_fragment121, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GitMergeIcon",
      options,
      id: create_fragment121.name
    });
  }
  get size() {
    throw new Error("<GitMergeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<GitMergeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<GitMergeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<GitMergeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<GitMergeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<GitMergeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GitMergeIcon_default = GitMergeIcon;

// node_modules/svelte-feather-icons/src/icons/GitPullRequestIcon.svelte
var file122 = "node_modules/svelte-feather-icons/src/icons/GitPullRequestIcon.svelte";
function create_fragment122(ctx) {
  let svg;
  let circle0;
  let circle1;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "18");
      attr_dev(circle0, "cy", "18");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file122, 13, 253, 537);
      attr_dev(circle1, "cx", "6");
      attr_dev(circle1, "cy", "6");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file122, 13, 292, 576);
      attr_dev(path, "d", "M13 6h3a2 2 0 0 1 2 2v7");
      add_location(path, file122, 13, 329, 613);
      attr_dev(line, "x1", "6");
      attr_dev(line, "y1", "9");
      attr_dev(line, "x2", "6");
      attr_dev(line, "y2", "21");
      add_location(line, file122, 13, 370, 654);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-git-pull-request " + /*customClass*/
      ctx[2]);
      add_location(svg, file122, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-git-pull-request " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment122.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance122($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GitPullRequestIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GitPullRequestIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var GitPullRequestIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance122, create_fragment122, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GitPullRequestIcon",
      options,
      id: create_fragment122.name
    });
  }
  get size() {
    throw new Error("<GitPullRequestIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<GitPullRequestIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<GitPullRequestIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<GitPullRequestIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<GitPullRequestIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<GitPullRequestIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GitPullRequestIcon_default = GitPullRequestIcon;

// node_modules/svelte-feather-icons/src/icons/GithubIcon.svelte
var file123 = "node_modules/svelte-feather-icons/src/icons/GithubIcon.svelte";
function create_fragment123(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22");
      add_location(path, file123, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-github " + /*customClass*/
      ctx[2]);
      add_location(svg, file123, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-github " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment123.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance123($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GithubIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GithubIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var GithubIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance123, create_fragment123, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GithubIcon",
      options,
      id: create_fragment123.name
    });
  }
  get size() {
    throw new Error("<GithubIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<GithubIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<GithubIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<GithubIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<GithubIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<GithubIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GithubIcon_default = GithubIcon;

// node_modules/svelte-feather-icons/src/icons/GitlabIcon.svelte
var file124 = "node_modules/svelte-feather-icons/src/icons/GitlabIcon.svelte";
function create_fragment124(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z");
      add_location(path, file124, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-gitlab " + /*customClass*/
      ctx[2]);
      add_location(svg, file124, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-gitlab " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment124.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance124($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GitlabIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GitlabIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var GitlabIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance124, create_fragment124, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GitlabIcon",
      options,
      id: create_fragment124.name
    });
  }
  get size() {
    throw new Error("<GitlabIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<GitlabIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<GitlabIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<GitlabIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<GitlabIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<GitlabIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GitlabIcon_default = GitlabIcon;

// node_modules/svelte-feather-icons/src/icons/GlobeIcon.svelte
var file125 = "node_modules/svelte-feather-icons/src/icons/GlobeIcon.svelte";
function create_fragment125(ctx) {
  let svg;
  let circle;
  let line;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file125, 13, 242, 526);
      attr_dev(line, "x1", "2");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "22");
      attr_dev(line, "y2", "12");
      add_location(line, file125, 13, 282, 566);
      attr_dev(path, "d", "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z");
      add_location(path, file125, 13, 326, 610);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-globe " + /*customClass*/
      ctx[2]);
      add_location(svg, file125, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-globe " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment125.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance125($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GlobeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GlobeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var GlobeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance125, create_fragment125, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GlobeIcon",
      options,
      id: create_fragment125.name
    });
  }
  get size() {
    throw new Error("<GlobeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<GlobeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<GlobeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<GlobeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<GlobeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<GlobeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GlobeIcon_default = GlobeIcon;

// node_modules/svelte-feather-icons/src/icons/GridIcon.svelte
var file126 = "node_modules/svelte-feather-icons/src/icons/GridIcon.svelte";
function create_fragment126(ctx) {
  let svg;
  let rect0;
  let rect1;
  let rect2;
  let rect3;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      rect2 = svg_element("rect");
      rect3 = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect0 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect0).forEach(detach_dev);
      rect1 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect1).forEach(detach_dev);
      rect2 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect2).forEach(detach_dev);
      rect3 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect3).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect0, "x", "3");
      attr_dev(rect0, "y", "3");
      attr_dev(rect0, "width", "7");
      attr_dev(rect0, "height", "7");
      add_location(rect0, file126, 13, 241, 525);
      attr_dev(rect1, "x", "14");
      attr_dev(rect1, "y", "3");
      attr_dev(rect1, "width", "7");
      attr_dev(rect1, "height", "7");
      add_location(rect1, file126, 13, 287, 571);
      attr_dev(rect2, "x", "14");
      attr_dev(rect2, "y", "14");
      attr_dev(rect2, "width", "7");
      attr_dev(rect2, "height", "7");
      add_location(rect2, file126, 13, 334, 618);
      attr_dev(rect3, "x", "3");
      attr_dev(rect3, "y", "14");
      attr_dev(rect3, "width", "7");
      attr_dev(rect3, "height", "7");
      add_location(rect3, file126, 13, 382, 666);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-grid " + /*customClass*/
      ctx[2]);
      add_location(svg, file126, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect0);
      append_hydration_dev(svg, rect1);
      append_hydration_dev(svg, rect2);
      append_hydration_dev(svg, rect3);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-grid " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment126.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance126($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GridIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GridIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var GridIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance126, create_fragment126, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GridIcon",
      options,
      id: create_fragment126.name
    });
  }
  get size() {
    throw new Error("<GridIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<GridIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<GridIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<GridIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<GridIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<GridIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GridIcon_default = GridIcon;

// node_modules/svelte-feather-icons/src/icons/HardDriveIcon.svelte
var file127 = "node_modules/svelte-feather-icons/src/icons/HardDriveIcon.svelte";
function create_fragment127(ctx) {
  let svg;
  let line0;
  let path;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      path = svg_element("path");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "22");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "2");
      attr_dev(line0, "y2", "12");
      add_location(line0, file127, 13, 247, 531);
      attr_dev(path, "d", "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z");
      add_location(path, file127, 13, 291, 575);
      attr_dev(line1, "x1", "6");
      attr_dev(line1, "y1", "16");
      attr_dev(line1, "x2", "6.01");
      attr_dev(line1, "y2", "16");
      add_location(line1, file127, 13, 415, 699);
      attr_dev(line2, "x1", "10");
      attr_dev(line2, "y1", "16");
      attr_dev(line2, "x2", "10.01");
      attr_dev(line2, "y2", "16");
      add_location(line2, file127, 13, 461, 745);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-hard-drive " + /*customClass*/
      ctx[2]);
      add_location(svg, file127, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-hard-drive " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment127.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance127($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HardDriveIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HardDriveIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var HardDriveIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance127, create_fragment127, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HardDriveIcon",
      options,
      id: create_fragment127.name
    });
  }
  get size() {
    throw new Error("<HardDriveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<HardDriveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<HardDriveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<HardDriveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<HardDriveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<HardDriveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HardDriveIcon_default = HardDriveIcon;

// node_modules/svelte-feather-icons/src/icons/HashIcon.svelte
var file128 = "node_modules/svelte-feather-icons/src/icons/HashIcon.svelte";
function create_fragment128(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "4");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "20");
      attr_dev(line0, "y2", "9");
      add_location(line0, file128, 13, 241, 525);
      attr_dev(line1, "x1", "4");
      attr_dev(line1, "y1", "15");
      attr_dev(line1, "x2", "20");
      attr_dev(line1, "y2", "15");
      add_location(line1, file128, 13, 283, 567);
      attr_dev(line2, "x1", "10");
      attr_dev(line2, "y1", "3");
      attr_dev(line2, "x2", "8");
      attr_dev(line2, "y2", "21");
      add_location(line2, file128, 13, 327, 611);
      attr_dev(line3, "x1", "16");
      attr_dev(line3, "y1", "3");
      attr_dev(line3, "x2", "14");
      attr_dev(line3, "y2", "21");
      add_location(line3, file128, 13, 370, 654);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-hash " + /*customClass*/
      ctx[2]);
      add_location(svg, file128, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-hash " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment128.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance128($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HashIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HashIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var HashIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance128, create_fragment128, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HashIcon",
      options,
      id: create_fragment128.name
    });
  }
  get size() {
    throw new Error("<HashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<HashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<HashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<HashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<HashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<HashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HashIcon_default = HashIcon;

// node_modules/svelte-feather-icons/src/icons/HeadphonesIcon.svelte
var file129 = "node_modules/svelte-feather-icons/src/icons/HeadphonesIcon.svelte";
function create_fragment129(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M3 18v-6a9 9 0 0 1 18 0v6");
      add_location(path0, file129, 13, 247, 531);
      attr_dev(path1, "d", "M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z");
      add_location(path1, file129, 13, 290, 574);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-headphones " + /*customClass*/
      ctx[2]);
      add_location(svg, file129, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-headphones " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment129.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance129($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeadphonesIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HeadphonesIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var HeadphonesIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance129, create_fragment129, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeadphonesIcon",
      options,
      id: create_fragment129.name
    });
  }
  get size() {
    throw new Error("<HeadphonesIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<HeadphonesIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<HeadphonesIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<HeadphonesIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<HeadphonesIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<HeadphonesIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeadphonesIcon_default = HeadphonesIcon;

// node_modules/svelte-feather-icons/src/icons/HeartIcon.svelte
var file130 = "node_modules/svelte-feather-icons/src/icons/HeartIcon.svelte";
function create_fragment130(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z");
      add_location(path, file130, 13, 242, 526);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-heart " + /*customClass*/
      ctx[2]);
      add_location(svg, file130, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-heart " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment130.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance130($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeartIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HeartIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var HeartIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance130, create_fragment130, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeartIcon",
      options,
      id: create_fragment130.name
    });
  }
  get size() {
    throw new Error("<HeartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<HeartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<HeartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<HeartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<HeartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<HeartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeartIcon_default = HeartIcon;

// node_modules/svelte-feather-icons/src/icons/HelpCircleIcon.svelte
var file131 = "node_modules/svelte-feather-icons/src/icons/HelpCircleIcon.svelte";
function create_fragment131(ctx) {
  let svg;
  let circle;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file131, 13, 248, 532);
      attr_dev(path, "d", "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3");
      add_location(path, file131, 13, 288, 572);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "17");
      attr_dev(line, "x2", "12.01");
      attr_dev(line, "y2", "17");
      add_location(line, file131, 13, 342, 626);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-help-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file131, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-help-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment131.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance131($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HelpCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HelpCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var HelpCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance131, create_fragment131, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HelpCircleIcon",
      options,
      id: create_fragment131.name
    });
  }
  get size() {
    throw new Error("<HelpCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<HelpCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<HelpCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<HelpCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<HelpCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<HelpCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HelpCircleIcon_default = HelpCircleIcon;

// node_modules/svelte-feather-icons/src/icons/HexagonIcon.svelte
var file132 = "node_modules/svelte-feather-icons/src/icons/HexagonIcon.svelte";
function create_fragment132(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
      add_location(path, file132, 13, 244, 528);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-hexagon " + /*customClass*/
      ctx[2]);
      add_location(svg, file132, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-hexagon " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment132.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance132($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HexagonIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HexagonIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var HexagonIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance132, create_fragment132, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HexagonIcon",
      options,
      id: create_fragment132.name
    });
  }
  get size() {
    throw new Error("<HexagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<HexagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<HexagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<HexagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<HexagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<HexagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HexagonIcon_default = HexagonIcon;

// node_modules/svelte-feather-icons/src/icons/HomeIcon.svelte
var file133 = "node_modules/svelte-feather-icons/src/icons/HomeIcon.svelte";
function create_fragment133(ctx) {
  let svg;
  let path;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z");
      add_location(path, file133, 13, 241, 525);
      attr_dev(polyline, "points", "9 22 9 12 15 12 15 22");
      add_location(polyline, file133, 13, 305, 589);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-home " + /*customClass*/
      ctx[2]);
      add_location(svg, file133, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-home " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment133.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance133($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HomeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HomeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var HomeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance133, create_fragment133, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HomeIcon",
      options,
      id: create_fragment133.name
    });
  }
  get size() {
    throw new Error("<HomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<HomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<HomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<HomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<HomeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<HomeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HomeIcon_default = HomeIcon;

// node_modules/svelte-feather-icons/src/icons/ImageIcon.svelte
var file134 = "node_modules/svelte-feather-icons/src/icons/ImageIcon.svelte";
function create_fragment134(ctx) {
  let svg;
  let rect;
  let circle;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file134, 13, 242, 526);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "8.5");
      attr_dev(circle, "r", "1.5");
      add_location(circle, file134, 13, 304, 588);
      attr_dev(polyline, "points", "21 15 16 10 5 21");
      add_location(polyline, file134, 13, 347, 631);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-image " + /*customClass*/
      ctx[2]);
      add_location(svg, file134, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-image " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment134.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance134($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ImageIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ImageIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance134, create_fragment134, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageIcon",
      options,
      id: create_fragment134.name
    });
  }
  get size() {
    throw new Error("<ImageIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ImageIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ImageIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ImageIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ImageIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ImageIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageIcon_default = ImageIcon;

// node_modules/svelte-feather-icons/src/icons/InboxIcon.svelte
var file135 = "node_modules/svelte-feather-icons/src/icons/InboxIcon.svelte";
function create_fragment135(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "22 12 16 12 14 15 10 15 8 12 2 12");
      add_location(polyline, file135, 13, 242, 526);
      attr_dev(path, "d", "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z");
      add_location(path, file135, 13, 306, 590);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-inbox " + /*customClass*/
      ctx[2]);
      add_location(svg, file135, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-inbox " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment135.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance135($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InboxIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InboxIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var InboxIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance135, create_fragment135, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InboxIcon",
      options,
      id: create_fragment135.name
    });
  }
  get size() {
    throw new Error("<InboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<InboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<InboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<InboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InboxIcon_default = InboxIcon;

// node_modules/svelte-feather-icons/src/icons/InfoIcon.svelte
var file136 = "node_modules/svelte-feather-icons/src/icons/InfoIcon.svelte";
function create_fragment136(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file136, 13, 241, 525);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "16");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "12");
      add_location(line0, file136, 13, 281, 565);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "8");
      attr_dev(line1, "x2", "12.01");
      attr_dev(line1, "y2", "8");
      add_location(line1, file136, 13, 326, 610);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-info " + /*customClass*/
      ctx[2]);
      add_location(svg, file136, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-info " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment136.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance136($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InfoIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InfoIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var InfoIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance136, create_fragment136, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InfoIcon",
      options,
      id: create_fragment136.name
    });
  }
  get size() {
    throw new Error("<InfoIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InfoIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<InfoIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<InfoIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<InfoIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InfoIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InfoIcon_default = InfoIcon;

// node_modules/svelte-feather-icons/src/icons/InstagramIcon.svelte
var file137 = "node_modules/svelte-feather-icons/src/icons/InstagramIcon.svelte";
function create_fragment137(ctx) {
  let svg;
  let rect;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "20");
      attr_dev(rect, "rx", "5");
      attr_dev(rect, "ry", "5");
      add_location(rect, file137, 13, 246, 530);
      attr_dev(path, "d", "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z");
      add_location(path, file137, 13, 308, 592);
      attr_dev(line, "x1", "17.5");
      attr_dev(line, "y1", "6.5");
      attr_dev(line, "x2", "17.51");
      attr_dev(line, "y2", "6.5");
      add_location(line, file137, 13, 373, 657);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-instagram " + /*customClass*/
      ctx[2]);
      add_location(svg, file137, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-instagram " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment137.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance137($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InstagramIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InstagramIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var InstagramIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance137, create_fragment137, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InstagramIcon",
      options,
      id: create_fragment137.name
    });
  }
  get size() {
    throw new Error("<InstagramIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InstagramIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<InstagramIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<InstagramIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<InstagramIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InstagramIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InstagramIcon_default = InstagramIcon;

// node_modules/svelte-feather-icons/src/icons/ItalicIcon.svelte
var file138 = "node_modules/svelte-feather-icons/src/icons/ItalicIcon.svelte";
function create_fragment138(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "19");
      attr_dev(line0, "y1", "4");
      attr_dev(line0, "x2", "10");
      attr_dev(line0, "y2", "4");
      add_location(line0, file138, 13, 243, 527);
      attr_dev(line1, "x1", "14");
      attr_dev(line1, "y1", "20");
      attr_dev(line1, "x2", "5");
      attr_dev(line1, "y2", "20");
      add_location(line1, file138, 13, 286, 570);
      attr_dev(line2, "x1", "15");
      attr_dev(line2, "y1", "4");
      attr_dev(line2, "x2", "9");
      attr_dev(line2, "y2", "20");
      add_location(line2, file138, 13, 330, 614);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-italic " + /*customClass*/
      ctx[2]);
      add_location(svg, file138, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-italic " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment138.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance138($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ItalicIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ItalicIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ItalicIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance138, create_fragment138, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ItalicIcon",
      options,
      id: create_fragment138.name
    });
  }
  get size() {
    throw new Error("<ItalicIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ItalicIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ItalicIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ItalicIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ItalicIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ItalicIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ItalicIcon_default = ItalicIcon;

// node_modules/svelte-feather-icons/src/icons/KeyIcon.svelte
var file139 = "node_modules/svelte-feather-icons/src/icons/KeyIcon.svelte";
function create_fragment139(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4");
      add_location(path, file139, 13, 240, 524);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-key " + /*customClass*/
      ctx[2]);
      add_location(svg, file139, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-key " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment139.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance139($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("KeyIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<KeyIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var KeyIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance139, create_fragment139, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "KeyIcon",
      options,
      id: create_fragment139.name
    });
  }
  get size() {
    throw new Error("<KeyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<KeyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<KeyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<KeyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<KeyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<KeyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var KeyIcon_default = KeyIcon;

// node_modules/svelte-feather-icons/src/icons/LayersIcon.svelte
var file140 = "node_modules/svelte-feather-icons/src/icons/LayersIcon.svelte";
function create_fragment140(ctx) {
  let svg;
  let polygon;
  let polyline0;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "12 2 2 7 12 12 22 7 12 2");
      add_location(polygon, file140, 13, 243, 527);
      attr_dev(polyline0, "points", "2 17 12 22 22 17");
      add_location(polyline0, file140, 13, 296, 580);
      attr_dev(polyline1, "points", "2 12 12 17 22 12");
      add_location(polyline1, file140, 13, 343, 627);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-layers " + /*customClass*/
      ctx[2]);
      add_location(svg, file140, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-layers " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment140.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance140($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LayersIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LayersIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var LayersIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance140, create_fragment140, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LayersIcon",
      options,
      id: create_fragment140.name
    });
  }
  get size() {
    throw new Error("<LayersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<LayersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LayersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LayersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LayersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LayersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LayersIcon_default = LayersIcon;

// node_modules/svelte-feather-icons/src/icons/LayoutIcon.svelte
var file141 = "node_modules/svelte-feather-icons/src/icons/LayoutIcon.svelte";
function create_fragment141(ctx) {
  let svg;
  let rect;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file141, 13, 243, 527);
      attr_dev(line0, "x1", "3");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "21");
      attr_dev(line0, "y2", "9");
      add_location(line0, file141, 13, 305, 589);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "21");
      attr_dev(line1, "x2", "9");
      attr_dev(line1, "y2", "9");
      add_location(line1, file141, 13, 347, 631);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-layout " + /*customClass*/
      ctx[2]);
      add_location(svg, file141, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-layout " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment141.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance141($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LayoutIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LayoutIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var LayoutIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance141, create_fragment141, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LayoutIcon",
      options,
      id: create_fragment141.name
    });
  }
  get size() {
    throw new Error("<LayoutIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<LayoutIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LayoutIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LayoutIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LayoutIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LayoutIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LayoutIcon_default = LayoutIcon;

// node_modules/svelte-feather-icons/src/icons/LifeBuoyIcon.svelte
var file142 = "node_modules/svelte-feather-icons/src/icons/LifeBuoyIcon.svelte";
function create_fragment142(ctx) {
  let svg;
  let circle0;
  let circle1;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "10");
      add_location(circle0, file142, 13, 246, 530);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "4");
      add_location(circle1, file142, 13, 286, 570);
      attr_dev(line0, "x1", "4.93");
      attr_dev(line0, "y1", "4.93");
      attr_dev(line0, "x2", "9.17");
      attr_dev(line0, "y2", "9.17");
      add_location(line0, file142, 13, 325, 609);
      attr_dev(line1, "x1", "14.83");
      attr_dev(line1, "y1", "14.83");
      attr_dev(line1, "x2", "19.07");
      attr_dev(line1, "y2", "19.07");
      add_location(line1, file142, 13, 378, 662);
      attr_dev(line2, "x1", "14.83");
      attr_dev(line2, "y1", "9.17");
      attr_dev(line2, "x2", "19.07");
      attr_dev(line2, "y2", "4.93");
      add_location(line2, file142, 13, 435, 719);
      attr_dev(line3, "x1", "14.83");
      attr_dev(line3, "y1", "9.17");
      attr_dev(line3, "x2", "18.36");
      attr_dev(line3, "y2", "5.64");
      add_location(line3, file142, 13, 490, 774);
      attr_dev(line4, "x1", "4.93");
      attr_dev(line4, "y1", "19.07");
      attr_dev(line4, "x2", "9.17");
      attr_dev(line4, "y2", "14.83");
      add_location(line4, file142, 13, 545, 829);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-life-buoy " + /*customClass*/
      ctx[2]);
      add_location(svg, file142, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-life-buoy " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment142.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance142($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LifeBuoyIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LifeBuoyIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var LifeBuoyIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance142, create_fragment142, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LifeBuoyIcon",
      options,
      id: create_fragment142.name
    });
  }
  get size() {
    throw new Error("<LifeBuoyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<LifeBuoyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LifeBuoyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LifeBuoyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LifeBuoyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LifeBuoyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LifeBuoyIcon_default = LifeBuoyIcon;

// node_modules/svelte-feather-icons/src/icons/Link2Icon.svelte
var file143 = "node_modules/svelte-feather-icons/src/icons/Link2Icon.svelte";
function create_fragment143(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3");
      add_location(path, file143, 13, 243, 527);
      attr_dev(line, "x1", "8");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "16");
      attr_dev(line, "y2", "12");
      add_location(line, file143, 13, 336, 620);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-link-2 " + /*customClass*/
      ctx[2]);
      add_location(svg, file143, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-link-2 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment143.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance143($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Link2Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Link2Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var Link2Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance143, create_fragment143, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link2Icon",
      options,
      id: create_fragment143.name
    });
  }
  get size() {
    throw new Error("<Link2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Link2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Link2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Link2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Link2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Link2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Link2Icon_default = Link2Icon;

// node_modules/svelte-feather-icons/src/icons/LinkIcon.svelte
var file144 = "node_modules/svelte-feather-icons/src/icons/LinkIcon.svelte";
function create_fragment144(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71");
      add_location(path0, file144, 13, 241, 525);
      attr_dev(path1, "d", "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71");
      add_location(path1, file144, 13, 318, 602);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-link " + /*customClass*/
      ctx[2]);
      add_location(svg, file144, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-link " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment144.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance144($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinkIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LinkIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var LinkIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance144, create_fragment144, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinkIcon",
      options,
      id: create_fragment144.name
    });
  }
  get size() {
    throw new Error("<LinkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<LinkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LinkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LinkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LinkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LinkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinkIcon_default = LinkIcon;

// node_modules/svelte-feather-icons/src/icons/LinkedinIcon.svelte
var file145 = "node_modules/svelte-feather-icons/src/icons/LinkedinIcon.svelte";
function create_fragment145(ctx) {
  let svg;
  let path;
  let rect;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      rect = svg_element("rect");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z");
      add_location(path, file145, 13, 245, 529);
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "9");
      attr_dev(rect, "width", "4");
      attr_dev(rect, "height", "12");
      add_location(rect, file145, 13, 341, 625);
      attr_dev(circle, "cx", "4");
      attr_dev(circle, "cy", "4");
      attr_dev(circle, "r", "2");
      add_location(circle, file145, 13, 388, 672);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-linkedin " + /*customClass*/
      ctx[2]);
      add_location(svg, file145, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-linkedin " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment145.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance145($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinkedinIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LinkedinIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var LinkedinIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance145, create_fragment145, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinkedinIcon",
      options,
      id: create_fragment145.name
    });
  }
  get size() {
    throw new Error("<LinkedinIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<LinkedinIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LinkedinIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LinkedinIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LinkedinIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LinkedinIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinkedinIcon_default = LinkedinIcon;

// node_modules/svelte-feather-icons/src/icons/ListIcon.svelte
var file146 = "node_modules/svelte-feather-icons/src/icons/ListIcon.svelte";
function create_fragment146(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "6");
      attr_dev(line0, "x2", "21");
      attr_dev(line0, "y2", "6");
      add_location(line0, file146, 13, 241, 525);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "21");
      attr_dev(line1, "y2", "12");
      add_location(line1, file146, 13, 283, 567);
      attr_dev(line2, "x1", "8");
      attr_dev(line2, "y1", "18");
      attr_dev(line2, "x2", "21");
      attr_dev(line2, "y2", "18");
      add_location(line2, file146, 13, 327, 611);
      attr_dev(line3, "x1", "3");
      attr_dev(line3, "y1", "6");
      attr_dev(line3, "x2", "3.01");
      attr_dev(line3, "y2", "6");
      add_location(line3, file146, 13, 371, 655);
      attr_dev(line4, "x1", "3");
      attr_dev(line4, "y1", "12");
      attr_dev(line4, "x2", "3.01");
      attr_dev(line4, "y2", "12");
      add_location(line4, file146, 13, 415, 699);
      attr_dev(line5, "x1", "3");
      attr_dev(line5, "y1", "18");
      attr_dev(line5, "x2", "3.01");
      attr_dev(line5, "y2", "18");
      add_location(line5, file146, 13, 461, 745);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-list " + /*customClass*/
      ctx[2]);
      add_location(svg, file146, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-list " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment146.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance146($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ListIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ListIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance146, create_fragment146, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListIcon",
      options,
      id: create_fragment146.name
    });
  }
  get size() {
    throw new Error("<ListIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ListIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ListIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ListIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ListIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListIcon_default = ListIcon;

// node_modules/svelte-feather-icons/src/icons/LoaderIcon.svelte
var file147 = "node_modules/svelte-feather-icons/src/icons/LoaderIcon.svelte";
function create_fragment147(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let line6;
  let line7;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      line6 = svg_element("line");
      line7 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      line6 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line6).forEach(detach_dev);
      line7 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line7).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "6");
      add_location(line0, file147, 13, 243, 527);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "18");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "22");
      add_location(line1, file147, 13, 286, 570);
      attr_dev(line2, "x1", "4.93");
      attr_dev(line2, "y1", "4.93");
      attr_dev(line2, "x2", "7.76");
      attr_dev(line2, "y2", "7.76");
      add_location(line2, file147, 13, 331, 615);
      attr_dev(line3, "x1", "16.24");
      attr_dev(line3, "y1", "16.24");
      attr_dev(line3, "x2", "19.07");
      attr_dev(line3, "y2", "19.07");
      add_location(line3, file147, 13, 384, 668);
      attr_dev(line4, "x1", "2");
      attr_dev(line4, "y1", "12");
      attr_dev(line4, "x2", "6");
      attr_dev(line4, "y2", "12");
      add_location(line4, file147, 13, 441, 725);
      attr_dev(line5, "x1", "18");
      attr_dev(line5, "y1", "12");
      attr_dev(line5, "x2", "22");
      attr_dev(line5, "y2", "12");
      add_location(line5, file147, 13, 484, 768);
      attr_dev(line6, "x1", "4.93");
      attr_dev(line6, "y1", "19.07");
      attr_dev(line6, "x2", "7.76");
      attr_dev(line6, "y2", "16.24");
      add_location(line6, file147, 13, 529, 813);
      attr_dev(line7, "x1", "16.24");
      attr_dev(line7, "y1", "7.76");
      attr_dev(line7, "x2", "19.07");
      attr_dev(line7, "y2", "4.93");
      add_location(line7, file147, 13, 584, 868);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-loader " + /*customClass*/
      ctx[2]);
      add_location(svg, file147, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
      append_hydration_dev(svg, line6);
      append_hydration_dev(svg, line7);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-loader " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment147.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance147($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LoaderIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LoaderIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var LoaderIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance147, create_fragment147, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LoaderIcon",
      options,
      id: create_fragment147.name
    });
  }
  get size() {
    throw new Error("<LoaderIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<LoaderIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LoaderIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LoaderIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LoaderIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LoaderIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LoaderIcon_default = LoaderIcon;

// node_modules/svelte-feather-icons/src/icons/LockIcon.svelte
var file148 = "node_modules/svelte-feather-icons/src/icons/LockIcon.svelte";
function create_fragment148(ctx) {
  let svg;
  let rect;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "11");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "11");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file148, 13, 241, 525);
      attr_dev(path, "d", "M7 11V7a5 5 0 0 1 10 0v4");
      add_location(path, file148, 13, 304, 588);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-lock " + /*customClass*/
      ctx[2]);
      add_location(svg, file148, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-lock " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment148.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance148($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LockIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LockIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var LockIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance148, create_fragment148, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LockIcon",
      options,
      id: create_fragment148.name
    });
  }
  get size() {
    throw new Error("<LockIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<LockIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LockIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LockIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LockIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LockIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LockIcon_default = LockIcon;

// node_modules/svelte-feather-icons/src/icons/LogInIcon.svelte
var file149 = "node_modules/svelte-feather-icons/src/icons/LogInIcon.svelte";
function create_fragment149(ctx) {
  let svg;
  let path;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4");
      add_location(path, file149, 13, 243, 527);
      attr_dev(polyline, "points", "10 17 15 12 10 7");
      add_location(polyline, file149, 13, 302, 586);
      attr_dev(line, "x1", "15");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "3");
      attr_dev(line, "y2", "12");
      add_location(line, file149, 13, 349, 633);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-log-in " + /*customClass*/
      ctx[2]);
      add_location(svg, file149, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-log-in " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment149.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance149($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LogInIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LogInIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var LogInIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance149, create_fragment149, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LogInIcon",
      options,
      id: create_fragment149.name
    });
  }
  get size() {
    throw new Error("<LogInIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<LogInIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LogInIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LogInIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LogInIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LogInIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LogInIcon_default = LogInIcon;

// node_modules/svelte-feather-icons/src/icons/LogOutIcon.svelte
var file150 = "node_modules/svelte-feather-icons/src/icons/LogOutIcon.svelte";
function create_fragment150(ctx) {
  let svg;
  let path;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4");
      add_location(path, file150, 13, 244, 528);
      attr_dev(polyline, "points", "16 17 21 12 16 7");
      add_location(polyline, file150, 13, 301, 585);
      attr_dev(line, "x1", "21");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "9");
      attr_dev(line, "y2", "12");
      add_location(line, file150, 13, 348, 632);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-log-out " + /*customClass*/
      ctx[2]);
      add_location(svg, file150, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-log-out " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment150.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance150($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LogOutIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LogOutIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var LogOutIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance150, create_fragment150, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LogOutIcon",
      options,
      id: create_fragment150.name
    });
  }
  get size() {
    throw new Error("<LogOutIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<LogOutIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LogOutIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LogOutIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LogOutIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LogOutIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LogOutIcon_default = LogOutIcon;

// node_modules/svelte-feather-icons/src/icons/MailIcon.svelte
var file151 = "node_modules/svelte-feather-icons/src/icons/MailIcon.svelte";
function create_fragment151(ctx) {
  let svg;
  let path;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z");
      add_location(path, file151, 13, 241, 525);
      attr_dev(polyline, "points", "22,6 12,13 2,6");
      add_location(polyline, file151, 13, 334, 618);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-mail " + /*customClass*/
      ctx[2]);
      add_location(svg, file151, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-mail " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment151.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance151($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MailIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MailIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MailIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance151, create_fragment151, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MailIcon",
      options,
      id: create_fragment151.name
    });
  }
  get size() {
    throw new Error("<MailIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MailIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MailIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MailIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MailIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MailIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MailIcon_default = MailIcon;

// node_modules/svelte-feather-icons/src/icons/MapPinIcon.svelte
var file152 = "node_modules/svelte-feather-icons/src/icons/MapPinIcon.svelte";
function create_fragment152(ctx) {
  let svg;
  let path;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z");
      add_location(path, file152, 13, 244, 528);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "10");
      attr_dev(circle, "r", "3");
      add_location(circle, file152, 13, 308, 592);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-map-pin " + /*customClass*/
      ctx[2]);
      add_location(svg, file152, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-map-pin " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment152.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance152($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MapPinIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MapPinIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MapPinIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance152, create_fragment152, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MapPinIcon",
      options,
      id: create_fragment152.name
    });
  }
  get size() {
    throw new Error("<MapPinIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MapPinIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MapPinIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MapPinIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MapPinIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MapPinIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MapPinIcon_default = MapPinIcon;

// node_modules/svelte-feather-icons/src/icons/MapIcon.svelte
var file153 = "node_modules/svelte-feather-icons/src/icons/MapIcon.svelte";
function create_fragment153(ctx) {
  let svg;
  let polygon;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6");
      add_location(polygon, file153, 13, 240, 524);
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "8");
      attr_dev(line0, "y2", "18");
      add_location(line0, file153, 13, 312, 596);
      attr_dev(line1, "x1", "16");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "16");
      attr_dev(line1, "y2", "22");
      add_location(line1, file153, 13, 354, 638);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-map " + /*customClass*/
      ctx[2]);
      add_location(svg, file153, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-map " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment153.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance153($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MapIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MapIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MapIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance153, create_fragment153, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MapIcon",
      options,
      id: create_fragment153.name
    });
  }
  get size() {
    throw new Error("<MapIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MapIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MapIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MapIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MapIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MapIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MapIcon_default = MapIcon;

// node_modules/svelte-feather-icons/src/icons/Maximize2Icon.svelte
var file154 = "node_modules/svelte-feather-icons/src/icons/Maximize2Icon.svelte";
function create_fragment154(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "15 3 21 3 21 9");
      add_location(polyline0, file154, 13, 247, 531);
      attr_dev(polyline1, "points", "9 21 3 21 3 15");
      add_location(polyline1, file154, 13, 292, 576);
      attr_dev(line0, "x1", "21");
      attr_dev(line0, "y1", "3");
      attr_dev(line0, "x2", "14");
      attr_dev(line0, "y2", "10");
      add_location(line0, file154, 13, 337, 621);
      attr_dev(line1, "x1", "3");
      attr_dev(line1, "y1", "21");
      attr_dev(line1, "x2", "10");
      attr_dev(line1, "y2", "14");
      add_location(line1, file154, 13, 381, 665);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-maximize-2 " + /*customClass*/
      ctx[2]);
      add_location(svg, file154, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-maximize-2 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment154.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance154($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Maximize2Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Maximize2Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var Maximize2Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance154, create_fragment154, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Maximize2Icon",
      options,
      id: create_fragment154.name
    });
  }
  get size() {
    throw new Error("<Maximize2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Maximize2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Maximize2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Maximize2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Maximize2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Maximize2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Maximize2Icon_default = Maximize2Icon;

// node_modules/svelte-feather-icons/src/icons/MaximizeIcon.svelte
var file155 = "node_modules/svelte-feather-icons/src/icons/MaximizeIcon.svelte";
function create_fragment155(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3");
      add_location(path, file155, 13, 245, 529);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-maximize " + /*customClass*/
      ctx[2]);
      add_location(svg, file155, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-maximize " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment155.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance155($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MaximizeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MaximizeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MaximizeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance155, create_fragment155, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MaximizeIcon",
      options,
      id: create_fragment155.name
    });
  }
  get size() {
    throw new Error("<MaximizeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MaximizeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MaximizeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MaximizeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MaximizeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MaximizeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MaximizeIcon_default = MaximizeIcon;

// node_modules/svelte-feather-icons/src/icons/MehIcon.svelte
var file156 = "node_modules/svelte-feather-icons/src/icons/MehIcon.svelte";
function create_fragment156(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file156, 13, 240, 524);
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "15");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "15");
      add_location(line0, file156, 13, 280, 564);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "9.01");
      attr_dev(line1, "y2", "9");
      add_location(line1, file156, 13, 324, 608);
      attr_dev(line2, "x1", "15");
      attr_dev(line2, "y1", "9");
      attr_dev(line2, "x2", "15.01");
      attr_dev(line2, "y2", "9");
      add_location(line2, file156, 13, 368, 652);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-meh " + /*customClass*/
      ctx[2]);
      add_location(svg, file156, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-meh " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment156.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance156($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MehIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MehIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MehIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance156, create_fragment156, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MehIcon",
      options,
      id: create_fragment156.name
    });
  }
  get size() {
    throw new Error("<MehIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MehIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MehIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MehIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MehIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MehIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MehIcon_default = MehIcon;

// node_modules/svelte-feather-icons/src/icons/MenuIcon.svelte
var file157 = "node_modules/svelte-feather-icons/src/icons/MenuIcon.svelte";
function create_fragment157(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "3");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "21");
      attr_dev(line0, "y2", "12");
      add_location(line0, file157, 13, 241, 525);
      attr_dev(line1, "x1", "3");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "21");
      attr_dev(line1, "y2", "6");
      add_location(line1, file157, 13, 285, 569);
      attr_dev(line2, "x1", "3");
      attr_dev(line2, "y1", "18");
      attr_dev(line2, "x2", "21");
      attr_dev(line2, "y2", "18");
      add_location(line2, file157, 13, 327, 611);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-menu " + /*customClass*/
      ctx[2]);
      add_location(svg, file157, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-menu " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment157.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance157($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MenuIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MenuIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance157, create_fragment157, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuIcon",
      options,
      id: create_fragment157.name
    });
  }
  get size() {
    throw new Error("<MenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuIcon_default = MenuIcon;

// node_modules/svelte-feather-icons/src/icons/MessageCircleIcon.svelte
var file158 = "node_modules/svelte-feather-icons/src/icons/MessageCircleIcon.svelte";
function create_fragment158(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z");
      add_location(path, file158, 13, 251, 535);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-message-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file158, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-message-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment158.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance158($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MessageCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MessageCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MessageCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance158, create_fragment158, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MessageCircleIcon",
      options,
      id: create_fragment158.name
    });
  }
  get size() {
    throw new Error("<MessageCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MessageCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MessageCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MessageCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MessageCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MessageCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MessageCircleIcon_default = MessageCircleIcon;

// node_modules/svelte-feather-icons/src/icons/MessageSquareIcon.svelte
var file159 = "node_modules/svelte-feather-icons/src/icons/MessageSquareIcon.svelte";
function create_fragment159(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z");
      add_location(path, file159, 13, 251, 535);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-message-square " + /*customClass*/
      ctx[2]);
      add_location(svg, file159, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-message-square " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment159.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance159($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MessageSquareIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MessageSquareIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MessageSquareIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance159, create_fragment159, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MessageSquareIcon",
      options,
      id: create_fragment159.name
    });
  }
  get size() {
    throw new Error("<MessageSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MessageSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MessageSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MessageSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MessageSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MessageSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MessageSquareIcon_default = MessageSquareIcon;

// node_modules/svelte-feather-icons/src/icons/MicOffIcon.svelte
var file160 = "node_modules/svelte-feather-icons/src/icons/MicOffIcon.svelte";
function create_fragment160(ctx) {
  let svg;
  let line0;
  let path0;
  let path1;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      path0 = svg_element("path");
      path1 = svg_element("path");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "1");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "23");
      attr_dev(line0, "y2", "23");
      add_location(line0, file160, 13, 244, 528);
      attr_dev(path0, "d", "M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6");
      add_location(path0, file160, 13, 287, 571);
      attr_dev(path1, "d", "M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23");
      add_location(path1, file160, 13, 359, 643);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "19");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "23");
      add_location(line1, file160, 13, 430, 714);
      attr_dev(line2, "x1", "8");
      attr_dev(line2, "y1", "23");
      attr_dev(line2, "x2", "16");
      attr_dev(line2, "y2", "23");
      add_location(line2, file160, 13, 475, 759);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-mic-off " + /*customClass*/
      ctx[2]);
      add_location(svg, file160, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-mic-off " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment160.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance160($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MicOffIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MicOffIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MicOffIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance160, create_fragment160, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MicOffIcon",
      options,
      id: create_fragment160.name
    });
  }
  get size() {
    throw new Error("<MicOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MicOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MicOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MicOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MicOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MicOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MicOffIcon_default = MicOffIcon;

// node_modules/svelte-feather-icons/src/icons/MicIcon.svelte
var file161 = "node_modules/svelte-feather-icons/src/icons/MicIcon.svelte";
function create_fragment161(ctx) {
  let svg;
  let path0;
  let path1;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z");
      add_location(path0, file161, 13, 240, 524);
      attr_dev(path1, "d", "M19 10v2a7 7 0 0 1-14 0v-2");
      add_location(path1, file161, 13, 310, 594);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "19");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "23");
      add_location(line0, file161, 13, 354, 638);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "23");
      attr_dev(line1, "x2", "16");
      attr_dev(line1, "y2", "23");
      add_location(line1, file161, 13, 399, 683);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-mic " + /*customClass*/
      ctx[2]);
      add_location(svg, file161, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-mic " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment161.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance161($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MicIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MicIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MicIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance161, create_fragment161, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MicIcon",
      options,
      id: create_fragment161.name
    });
  }
  get size() {
    throw new Error("<MicIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MicIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MicIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MicIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MicIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MicIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MicIcon_default = MicIcon;

// node_modules/svelte-feather-icons/src/icons/Minimize2Icon.svelte
var file162 = "node_modules/svelte-feather-icons/src/icons/Minimize2Icon.svelte";
function create_fragment162(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "4 14 10 14 10 20");
      add_location(polyline0, file162, 13, 247, 531);
      attr_dev(polyline1, "points", "20 10 14 10 14 4");
      add_location(polyline1, file162, 13, 294, 578);
      attr_dev(line0, "x1", "14");
      attr_dev(line0, "y1", "10");
      attr_dev(line0, "x2", "21");
      attr_dev(line0, "y2", "3");
      add_location(line0, file162, 13, 341, 625);
      attr_dev(line1, "x1", "3");
      attr_dev(line1, "y1", "21");
      attr_dev(line1, "x2", "10");
      attr_dev(line1, "y2", "14");
      add_location(line1, file162, 13, 385, 669);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-minimize-2 " + /*customClass*/
      ctx[2]);
      add_location(svg, file162, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-minimize-2 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment162.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance162($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Minimize2Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Minimize2Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var Minimize2Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance162, create_fragment162, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minimize2Icon",
      options,
      id: create_fragment162.name
    });
  }
  get size() {
    throw new Error("<Minimize2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Minimize2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Minimize2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Minimize2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Minimize2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Minimize2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Minimize2Icon_default = Minimize2Icon;

// node_modules/svelte-feather-icons/src/icons/MinimizeIcon.svelte
var file163 = "node_modules/svelte-feather-icons/src/icons/MinimizeIcon.svelte";
function create_fragment163(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3");
      add_location(path, file163, 13, 245, 529);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-minimize " + /*customClass*/
      ctx[2]);
      add_location(svg, file163, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-minimize " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment163.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance163($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MinimizeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MinimizeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MinimizeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance163, create_fragment163, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MinimizeIcon",
      options,
      id: create_fragment163.name
    });
  }
  get size() {
    throw new Error("<MinimizeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MinimizeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MinimizeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MinimizeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MinimizeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MinimizeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MinimizeIcon_default = MinimizeIcon;

// node_modules/svelte-feather-icons/src/icons/MinusCircleIcon.svelte
var file164 = "node_modules/svelte-feather-icons/src/icons/MinusCircleIcon.svelte";
function create_fragment164(ctx) {
  let svg;
  let circle;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file164, 13, 249, 533);
      attr_dev(line, "x1", "8");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "16");
      attr_dev(line, "y2", "12");
      add_location(line, file164, 13, 289, 573);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-minus-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file164, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-minus-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment164.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance164($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MinusCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MinusCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MinusCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance164, create_fragment164, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MinusCircleIcon",
      options,
      id: create_fragment164.name
    });
  }
  get size() {
    throw new Error("<MinusCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MinusCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MinusCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MinusCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MinusCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MinusCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MinusCircleIcon_default = MinusCircleIcon;

// node_modules/svelte-feather-icons/src/icons/MinusSquareIcon.svelte
var file165 = "node_modules/svelte-feather-icons/src/icons/MinusSquareIcon.svelte";
function create_fragment165(ctx) {
  let svg;
  let rect;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file165, 13, 249, 533);
      attr_dev(line, "x1", "8");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "16");
      attr_dev(line, "y2", "12");
      add_location(line, file165, 13, 311, 595);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-minus-square " + /*customClass*/
      ctx[2]);
      add_location(svg, file165, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-minus-square " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment165.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance165($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MinusSquareIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MinusSquareIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MinusSquareIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance165, create_fragment165, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MinusSquareIcon",
      options,
      id: create_fragment165.name
    });
  }
  get size() {
    throw new Error("<MinusSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MinusSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MinusSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MinusSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MinusSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MinusSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MinusSquareIcon_default = MinusSquareIcon;

// node_modules/svelte-feather-icons/src/icons/MinusIcon.svelte
var file166 = "node_modules/svelte-feather-icons/src/icons/MinusIcon.svelte";
function create_fragment166(ctx) {
  let svg;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "5");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "19");
      attr_dev(line, "y2", "12");
      add_location(line, file166, 13, 242, 526);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-minus " + /*customClass*/
      ctx[2]);
      add_location(svg, file166, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-minus " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment166.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance166($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MinusIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MinusIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MinusIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance166, create_fragment166, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MinusIcon",
      options,
      id: create_fragment166.name
    });
  }
  get size() {
    throw new Error("<MinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MinusIcon_default = MinusIcon;

// node_modules/svelte-feather-icons/src/icons/MonitorIcon.svelte
var file167 = "node_modules/svelte-feather-icons/src/icons/MonitorIcon.svelte";
function create_fragment167(ctx) {
  let svg;
  let rect;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file167, 13, 244, 528);
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "21");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "21");
      add_location(line0, file167, 13, 306, 590);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "17");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "21");
      add_location(line1, file167, 13, 350, 634);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-monitor " + /*customClass*/
      ctx[2]);
      add_location(svg, file167, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-monitor " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment167.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance167($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MonitorIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MonitorIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MonitorIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance167, create_fragment167, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MonitorIcon",
      options,
      id: create_fragment167.name
    });
  }
  get size() {
    throw new Error("<MonitorIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MonitorIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MonitorIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MonitorIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MonitorIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MonitorIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MonitorIcon_default = MonitorIcon;

// node_modules/svelte-feather-icons/src/icons/MoonIcon.svelte
var file168 = "node_modules/svelte-feather-icons/src/icons/MoonIcon.svelte";
function create_fragment168(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z");
      add_location(path, file168, 13, 241, 525);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-moon " + /*customClass*/
      ctx[2]);
      add_location(svg, file168, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-moon " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment168.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance168($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MoonIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MoonIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MoonIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance168, create_fragment168, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MoonIcon",
      options,
      id: create_fragment168.name
    });
  }
  get size() {
    throw new Error("<MoonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MoonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MoonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MoonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MoonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MoonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MoonIcon_default = MoonIcon;

// node_modules/svelte-feather-icons/src/icons/MoreHorizontalIcon.svelte
var file169 = "node_modules/svelte-feather-icons/src/icons/MoreHorizontalIcon.svelte";
function create_fragment169(ctx) {
  let svg;
  let circle0;
  let circle1;
  let circle2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      circle2 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "1");
      add_location(circle0, file169, 13, 252, 536);
      attr_dev(circle1, "cx", "19");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "1");
      add_location(circle1, file169, 13, 291, 575);
      attr_dev(circle2, "cx", "5");
      attr_dev(circle2, "cy", "12");
      attr_dev(circle2, "r", "1");
      add_location(circle2, file169, 13, 330, 614);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-more-horizontal " + /*customClass*/
      ctx[2]);
      add_location(svg, file169, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, circle2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-more-horizontal " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment169.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance169($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MoreHorizontalIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MoreHorizontalIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MoreHorizontalIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance169, create_fragment169, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MoreHorizontalIcon",
      options,
      id: create_fragment169.name
    });
  }
  get size() {
    throw new Error("<MoreHorizontalIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MoreHorizontalIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MoreHorizontalIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MoreHorizontalIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MoreHorizontalIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MoreHorizontalIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MoreHorizontalIcon_default = MoreHorizontalIcon;

// node_modules/svelte-feather-icons/src/icons/MoreVerticalIcon.svelte
var file170 = "node_modules/svelte-feather-icons/src/icons/MoreVerticalIcon.svelte";
function create_fragment170(ctx) {
  let svg;
  let circle0;
  let circle1;
  let circle2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      circle2 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "1");
      add_location(circle0, file170, 13, 250, 534);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "5");
      attr_dev(circle1, "r", "1");
      add_location(circle1, file170, 13, 289, 573);
      attr_dev(circle2, "cx", "12");
      attr_dev(circle2, "cy", "19");
      attr_dev(circle2, "r", "1");
      add_location(circle2, file170, 13, 327, 611);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-more-vertical " + /*customClass*/
      ctx[2]);
      add_location(svg, file170, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, circle2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-more-vertical " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment170.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance170($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MoreVerticalIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MoreVerticalIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MoreVerticalIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance170, create_fragment170, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MoreVerticalIcon",
      options,
      id: create_fragment170.name
    });
  }
  get size() {
    throw new Error("<MoreVerticalIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MoreVerticalIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MoreVerticalIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MoreVerticalIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MoreVerticalIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MoreVerticalIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MoreVerticalIcon_default = MoreVerticalIcon;

// node_modules/svelte-feather-icons/src/icons/MousePointerIcon.svelte
var file171 = "node_modules/svelte-feather-icons/src/icons/MousePointerIcon.svelte";
function create_fragment171(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z");
      add_location(path0, file171, 13, 250, 534);
      attr_dev(path1, "d", "M13 13l6 6");
      add_location(path1, file171, 13, 308, 592);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-mouse-pointer " + /*customClass*/
      ctx[2]);
      add_location(svg, file171, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-mouse-pointer " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment171.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance171($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MousePointerIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MousePointerIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MousePointerIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance171, create_fragment171, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MousePointerIcon",
      options,
      id: create_fragment171.name
    });
  }
  get size() {
    throw new Error("<MousePointerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MousePointerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MousePointerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MousePointerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MousePointerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MousePointerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MousePointerIcon_default = MousePointerIcon;

// node_modules/svelte-feather-icons/src/icons/MoveIcon.svelte
var file172 = "node_modules/svelte-feather-icons/src/icons/MoveIcon.svelte";
function create_fragment172(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let polyline2;
  let polyline3;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      polyline2 = svg_element("polyline");
      polyline3 = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      polyline2 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline2).forEach(detach_dev);
      polyline3 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline3).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "5 9 2 12 5 15");
      add_location(polyline0, file172, 13, 241, 525);
      attr_dev(polyline1, "points", "9 5 12 2 15 5");
      add_location(polyline1, file172, 13, 285, 569);
      attr_dev(polyline2, "points", "15 19 12 22 9 19");
      add_location(polyline2, file172, 13, 329, 613);
      attr_dev(polyline3, "points", "19 9 22 12 19 15");
      add_location(polyline3, file172, 13, 376, 660);
      attr_dev(line0, "x1", "2");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "22");
      attr_dev(line0, "y2", "12");
      add_location(line0, file172, 13, 423, 707);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "2");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "22");
      add_location(line1, file172, 13, 467, 751);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-move " + /*customClass*/
      ctx[2]);
      add_location(svg, file172, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
      append_hydration_dev(svg, polyline2);
      append_hydration_dev(svg, polyline3);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-move " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment172.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance172($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MoveIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MoveIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MoveIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance172, create_fragment172, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MoveIcon",
      options,
      id: create_fragment172.name
    });
  }
  get size() {
    throw new Error("<MoveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MoveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MoveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MoveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MoveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MoveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MoveIcon_default = MoveIcon;

// node_modules/svelte-feather-icons/src/icons/MusicIcon.svelte
var file173 = "node_modules/svelte-feather-icons/src/icons/MusicIcon.svelte";
function create_fragment173(ctx) {
  let svg;
  let path;
  let circle0;
  let circle1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 18V5l12-2v13");
      add_location(path, file173, 13, 242, 526);
      attr_dev(circle0, "cx", "6");
      attr_dev(circle0, "cy", "18");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file173, 13, 275, 559);
      attr_dev(circle1, "cx", "18");
      attr_dev(circle1, "cy", "16");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file173, 13, 313, 597);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-music " + /*customClass*/
      ctx[2]);
      add_location(svg, file173, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-music " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment173.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance173($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MusicIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MusicIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var MusicIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance173, create_fragment173, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MusicIcon",
      options,
      id: create_fragment173.name
    });
  }
  get size() {
    throw new Error("<MusicIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MusicIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<MusicIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<MusicIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MusicIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MusicIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MusicIcon_default = MusicIcon;

// node_modules/svelte-feather-icons/src/icons/Navigation2Icon.svelte
var file174 = "node_modules/svelte-feather-icons/src/icons/Navigation2Icon.svelte";
function create_fragment174(ctx) {
  let svg;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "12 2 19 21 12 17 5 21 12 2");
      add_location(polygon, file174, 13, 249, 533);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-navigation-2 " + /*customClass*/
      ctx[2]);
      add_location(svg, file174, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-navigation-2 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment174.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance174($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Navigation2Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Navigation2Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var Navigation2Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance174, create_fragment174, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navigation2Icon",
      options,
      id: create_fragment174.name
    });
  }
  get size() {
    throw new Error("<Navigation2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Navigation2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Navigation2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Navigation2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Navigation2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Navigation2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Navigation2Icon_default = Navigation2Icon;

// node_modules/svelte-feather-icons/src/icons/NavigationIcon.svelte
var file175 = "node_modules/svelte-feather-icons/src/icons/NavigationIcon.svelte";
function create_fragment175(ctx) {
  let svg;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "3 11 22 2 13 21 11 13 3 11");
      add_location(polygon, file175, 13, 247, 531);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-navigation " + /*customClass*/
      ctx[2]);
      add_location(svg, file175, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-navigation " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment175.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance175($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavigationIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NavigationIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var NavigationIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance175, create_fragment175, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavigationIcon",
      options,
      id: create_fragment175.name
    });
  }
  get size() {
    throw new Error("<NavigationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<NavigationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<NavigationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<NavigationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<NavigationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavigationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavigationIcon_default = NavigationIcon;

// node_modules/svelte-feather-icons/src/icons/OctagonIcon.svelte
var file176 = "node_modules/svelte-feather-icons/src/icons/OctagonIcon.svelte";
function create_fragment176(ctx) {
  let svg;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
      add_location(polygon, file176, 13, 244, 528);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-octagon " + /*customClass*/
      ctx[2]);
      add_location(svg, file176, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-octagon " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment176.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance176($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OctagonIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<OctagonIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var OctagonIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance176, create_fragment176, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OctagonIcon",
      options,
      id: create_fragment176.name
    });
  }
  get size() {
    throw new Error("<OctagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<OctagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<OctagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<OctagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<OctagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OctagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OctagonIcon_default = OctagonIcon;

// node_modules/svelte-feather-icons/src/icons/PackageIcon.svelte
var file177 = "node_modules/svelte-feather-icons/src/icons/PackageIcon.svelte";
function create_fragment177(ctx) {
  let svg;
  let line0;
  let path;
  let polyline;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "16.5");
      attr_dev(line0, "y1", "9.4");
      attr_dev(line0, "x2", "7.5");
      attr_dev(line0, "y2", "4.21");
      add_location(line0, file177, 13, 244, 528);
      attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
      add_location(path, file177, 13, 295, 579);
      attr_dev(polyline, "points", "3.27 6.96 12 12.01 20.73 6.96");
      add_location(polyline, file177, 13, 434, 718);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "22.08");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "12");
      add_location(line1, file177, 13, 494, 778);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-package " + /*customClass*/
      ctx[2]);
      add_location(svg, file177, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-package " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment177.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance177($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PackageIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PackageIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PackageIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance177, create_fragment177, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PackageIcon",
      options,
      id: create_fragment177.name
    });
  }
  get size() {
    throw new Error("<PackageIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PackageIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PackageIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PackageIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PackageIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PackageIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PackageIcon_default = PackageIcon;

// node_modules/svelte-feather-icons/src/icons/PaperclipIcon.svelte
var file178 = "node_modules/svelte-feather-icons/src/icons/PaperclipIcon.svelte";
function create_fragment178(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48");
      add_location(path, file178, 13, 246, 530);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-paperclip " + /*customClass*/
      ctx[2]);
      add_location(svg, file178, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-paperclip " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment178.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance178($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaperclipIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PaperclipIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PaperclipIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance178, create_fragment178, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaperclipIcon",
      options,
      id: create_fragment178.name
    });
  }
  get size() {
    throw new Error("<PaperclipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PaperclipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PaperclipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PaperclipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PaperclipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PaperclipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaperclipIcon_default = PaperclipIcon;

// node_modules/svelte-feather-icons/src/icons/PauseCircleIcon.svelte
var file179 = "node_modules/svelte-feather-icons/src/icons/PauseCircleIcon.svelte";
function create_fragment179(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file179, 13, 249, 533);
      attr_dev(line0, "x1", "10");
      attr_dev(line0, "y1", "15");
      attr_dev(line0, "x2", "10");
      attr_dev(line0, "y2", "9");
      add_location(line0, file179, 13, 289, 573);
      attr_dev(line1, "x1", "14");
      attr_dev(line1, "y1", "15");
      attr_dev(line1, "x2", "14");
      attr_dev(line1, "y2", "9");
      add_location(line1, file179, 13, 333, 617);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-pause-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file179, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-pause-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment179.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance179($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PauseCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PauseCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PauseCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance179, create_fragment179, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PauseCircleIcon",
      options,
      id: create_fragment179.name
    });
  }
  get size() {
    throw new Error("<PauseCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PauseCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PauseCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PauseCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PauseCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PauseCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PauseCircleIcon_default = PauseCircleIcon;

// node_modules/svelte-feather-icons/src/icons/PauseIcon.svelte
var file180 = "node_modules/svelte-feather-icons/src/icons/PauseIcon.svelte";
function create_fragment180(ctx) {
  let svg;
  let rect0;
  let rect1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect0 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect0).forEach(detach_dev);
      rect1 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect0, "x", "6");
      attr_dev(rect0, "y", "4");
      attr_dev(rect0, "width", "4");
      attr_dev(rect0, "height", "16");
      add_location(rect0, file180, 13, 242, 526);
      attr_dev(rect1, "x", "14");
      attr_dev(rect1, "y", "4");
      attr_dev(rect1, "width", "4");
      attr_dev(rect1, "height", "16");
      add_location(rect1, file180, 13, 289, 573);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-pause " + /*customClass*/
      ctx[2]);
      add_location(svg, file180, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect0);
      append_hydration_dev(svg, rect1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-pause " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment180.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance180($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PauseIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PauseIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PauseIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance180, create_fragment180, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PauseIcon",
      options,
      id: create_fragment180.name
    });
  }
  get size() {
    throw new Error("<PauseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PauseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PauseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PauseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PauseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PauseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PauseIcon_default = PauseIcon;

// node_modules/svelte-feather-icons/src/icons/PenToolIcon.svelte
var file181 = "node_modules/svelte-feather-icons/src/icons/PenToolIcon.svelte";
function create_fragment181(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12 19l7-7 3 3-7 7-3-3z");
      add_location(path0, file181, 13, 245, 529);
      attr_dev(path1, "d", "M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z");
      add_location(path1, file181, 13, 286, 570);
      attr_dev(path2, "d", "M2 2l7.586 7.586");
      add_location(path2, file181, 13, 343, 627);
      attr_dev(circle, "cx", "11");
      attr_dev(circle, "cy", "11");
      attr_dev(circle, "r", "2");
      add_location(circle, file181, 13, 377, 661);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-pen-tool " + /*customClass*/
      ctx[2]);
      add_location(svg, file181, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-pen-tool " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment181.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance181($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PenToolIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PenToolIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PenToolIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance181, create_fragment181, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PenToolIcon",
      options,
      id: create_fragment181.name
    });
  }
  get size() {
    throw new Error("<PenToolIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PenToolIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PenToolIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PenToolIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PenToolIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PenToolIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PenToolIcon_default = PenToolIcon;

// node_modules/svelte-feather-icons/src/icons/PercentIcon.svelte
var file182 = "node_modules/svelte-feather-icons/src/icons/PercentIcon.svelte";
function create_fragment182(ctx) {
  let svg;
  let line;
  let circle0;
  let circle1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "19");
      attr_dev(line, "y1", "5");
      attr_dev(line, "x2", "5");
      attr_dev(line, "y2", "19");
      add_location(line, file182, 13, 244, 528);
      attr_dev(circle0, "cx", "6.5");
      attr_dev(circle0, "cy", "6.5");
      attr_dev(circle0, "r", "2.5");
      add_location(circle0, file182, 13, 287, 571);
      attr_dev(circle1, "cx", "17.5");
      attr_dev(circle1, "cy", "17.5");
      attr_dev(circle1, "r", "2.5");
      add_location(circle1, file182, 13, 330, 614);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-percent " + /*customClass*/
      ctx[2]);
      add_location(svg, file182, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-percent " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment182.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance182($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PercentIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PercentIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PercentIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance182, create_fragment182, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PercentIcon",
      options,
      id: create_fragment182.name
    });
  }
  get size() {
    throw new Error("<PercentIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PercentIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PercentIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PercentIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PercentIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PercentIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PercentIcon_default = PercentIcon;

// node_modules/svelte-feather-icons/src/icons/PhoneCallIcon.svelte
var file183 = "node_modules/svelte-feather-icons/src/icons/PhoneCallIcon.svelte";
function create_fragment183(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file183, 13, 247, 531);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-phone-call " + /*customClass*/
      ctx[2]);
      add_location(svg, file183, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-phone-call " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment183.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance183($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PhoneCallIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PhoneCallIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PhoneCallIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance183, create_fragment183, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneCallIcon",
      options,
      id: create_fragment183.name
    });
  }
  get size() {
    throw new Error("<PhoneCallIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PhoneCallIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PhoneCallIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PhoneCallIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PhoneCallIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PhoneCallIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PhoneCallIcon_default = PhoneCallIcon;

// node_modules/svelte-feather-icons/src/icons/PhoneForwardedIcon.svelte
var file184 = "node_modules/svelte-feather-icons/src/icons/PhoneForwardedIcon.svelte";
function create_fragment184(ctx) {
  let svg;
  let polyline;
  let line;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "19 1 23 5 19 9");
      add_location(polyline, file184, 13, 252, 536);
      attr_dev(line, "x1", "15");
      attr_dev(line, "y1", "5");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "5");
      add_location(line, file184, 13, 297, 581);
      attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file184, 13, 340, 624);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-phone-forwarded " + /*customClass*/
      ctx[2]);
      add_location(svg, file184, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-phone-forwarded " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment184.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance184($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PhoneForwardedIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PhoneForwardedIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PhoneForwardedIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance184, create_fragment184, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneForwardedIcon",
      options,
      id: create_fragment184.name
    });
  }
  get size() {
    throw new Error("<PhoneForwardedIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PhoneForwardedIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PhoneForwardedIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PhoneForwardedIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PhoneForwardedIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PhoneForwardedIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PhoneForwardedIcon_default = PhoneForwardedIcon;

// node_modules/svelte-feather-icons/src/icons/PhoneIncomingIcon.svelte
var file185 = "node_modules/svelte-feather-icons/src/icons/PhoneIncomingIcon.svelte";
function create_fragment185(ctx) {
  let svg;
  let polyline;
  let line;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "16 2 16 8 22 8");
      add_location(polyline, file185, 13, 251, 535);
      attr_dev(line, "x1", "23");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "16");
      attr_dev(line, "y2", "8");
      add_location(line, file185, 13, 296, 580);
      attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file185, 13, 339, 623);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-phone-incoming " + /*customClass*/
      ctx[2]);
      add_location(svg, file185, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-phone-incoming " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment185.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance185($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PhoneIncomingIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PhoneIncomingIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PhoneIncomingIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance185, create_fragment185, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneIncomingIcon",
      options,
      id: create_fragment185.name
    });
  }
  get size() {
    throw new Error("<PhoneIncomingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PhoneIncomingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PhoneIncomingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PhoneIncomingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PhoneIncomingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PhoneIncomingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PhoneIncomingIcon_default = PhoneIncomingIcon;

// node_modules/svelte-feather-icons/src/icons/PhoneMissedIcon.svelte
var file186 = "node_modules/svelte-feather-icons/src/icons/PhoneMissedIcon.svelte";
function create_fragment186(ctx) {
  let svg;
  let line0;
  let line1;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "23");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "17");
      attr_dev(line0, "y2", "7");
      add_location(line0, file186, 13, 249, 533);
      attr_dev(line1, "x1", "17");
      attr_dev(line1, "y1", "1");
      attr_dev(line1, "x2", "23");
      attr_dev(line1, "y2", "7");
      add_location(line1, file186, 13, 292, 576);
      attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file186, 13, 335, 619);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-phone-missed " + /*customClass*/
      ctx[2]);
      add_location(svg, file186, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-phone-missed " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment186.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance186($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PhoneMissedIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PhoneMissedIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PhoneMissedIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance186, create_fragment186, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneMissedIcon",
      options,
      id: create_fragment186.name
    });
  }
  get size() {
    throw new Error("<PhoneMissedIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PhoneMissedIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PhoneMissedIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PhoneMissedIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PhoneMissedIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PhoneMissedIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PhoneMissedIcon_default = PhoneMissedIcon;

// node_modules/svelte-feather-icons/src/icons/PhoneOffIcon.svelte
var file187 = "node_modules/svelte-feather-icons/src/icons/PhoneOffIcon.svelte";
function create_fragment187(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91");
      add_location(path, file187, 13, 246, 530);
      attr_dev(line, "x1", "23");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "1");
      attr_dev(line, "y2", "23");
      add_location(line, file187, 13, 573, 857);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-phone-off " + /*customClass*/
      ctx[2]);
      add_location(svg, file187, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-phone-off " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment187.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance187($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PhoneOffIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PhoneOffIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PhoneOffIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance187, create_fragment187, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneOffIcon",
      options,
      id: create_fragment187.name
    });
  }
  get size() {
    throw new Error("<PhoneOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PhoneOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PhoneOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PhoneOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PhoneOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PhoneOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PhoneOffIcon_default = PhoneOffIcon;

// node_modules/svelte-feather-icons/src/icons/PhoneOutgoingIcon.svelte
var file188 = "node_modules/svelte-feather-icons/src/icons/PhoneOutgoingIcon.svelte";
function create_fragment188(ctx) {
  let svg;
  let polyline;
  let line;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "23 7 23 1 17 1");
      add_location(polyline, file188, 13, 251, 535);
      attr_dev(line, "x1", "16");
      attr_dev(line, "y1", "8");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "1");
      add_location(line, file188, 13, 296, 580);
      attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file188, 13, 339, 623);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-phone-outgoing " + /*customClass*/
      ctx[2]);
      add_location(svg, file188, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-phone-outgoing " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment188.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance188($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PhoneOutgoingIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PhoneOutgoingIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PhoneOutgoingIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance188, create_fragment188, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneOutgoingIcon",
      options,
      id: create_fragment188.name
    });
  }
  get size() {
    throw new Error("<PhoneOutgoingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PhoneOutgoingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PhoneOutgoingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PhoneOutgoingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PhoneOutgoingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PhoneOutgoingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PhoneOutgoingIcon_default = PhoneOutgoingIcon;

// node_modules/svelte-feather-icons/src/icons/PhoneIcon.svelte
var file189 = "node_modules/svelte-feather-icons/src/icons/PhoneIcon.svelte";
function create_fragment189(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file189, 13, 242, 526);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-phone " + /*customClass*/
      ctx[2]);
      add_location(svg, file189, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-phone " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment189.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance189($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PhoneIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PhoneIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PhoneIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance189, create_fragment189, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneIcon",
      options,
      id: create_fragment189.name
    });
  }
  get size() {
    throw new Error("<PhoneIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PhoneIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PhoneIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PhoneIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PhoneIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PhoneIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PhoneIcon_default = PhoneIcon;

// node_modules/svelte-feather-icons/src/icons/PieChartIcon.svelte
var file190 = "node_modules/svelte-feather-icons/src/icons/PieChartIcon.svelte";
function create_fragment190(ctx) {
  let svg;
  let path0;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M21.21 15.89A10 10 0 1 1 8 2.83");
      add_location(path0, file190, 13, 246, 530);
      attr_dev(path1, "d", "M22 12A10 10 0 0 0 12 2v10z");
      add_location(path1, file190, 13, 295, 579);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-pie-chart " + /*customClass*/
      ctx[2]);
      add_location(svg, file190, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-pie-chart " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment190.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance190($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PieChartIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PieChartIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PieChartIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance190, create_fragment190, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PieChartIcon",
      options,
      id: create_fragment190.name
    });
  }
  get size() {
    throw new Error("<PieChartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PieChartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PieChartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PieChartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PieChartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PieChartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PieChartIcon_default = PieChartIcon;

// node_modules/svelte-feather-icons/src/icons/PlayCircleIcon.svelte
var file191 = "node_modules/svelte-feather-icons/src/icons/PlayCircleIcon.svelte";
function create_fragment191(ctx) {
  let svg;
  let circle;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file191, 13, 248, 532);
      attr_dev(polygon, "points", "10 8 16 12 10 16 10 8");
      add_location(polygon, file191, 13, 288, 572);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-play-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file191, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-play-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment191.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance191($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PlayCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PlayCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PlayCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance191, create_fragment191, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PlayCircleIcon",
      options,
      id: create_fragment191.name
    });
  }
  get size() {
    throw new Error("<PlayCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PlayCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PlayCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PlayCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PlayCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PlayCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PlayCircleIcon_default = PlayCircleIcon;

// node_modules/svelte-feather-icons/src/icons/PlayIcon.svelte
var file192 = "node_modules/svelte-feather-icons/src/icons/PlayIcon.svelte";
function create_fragment192(ctx) {
  let svg;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "5 3 19 12 5 21 5 3");
      add_location(polygon, file192, 13, 241, 525);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-play " + /*customClass*/
      ctx[2]);
      add_location(svg, file192, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-play " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment192.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance192($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PlayIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PlayIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PlayIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance192, create_fragment192, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PlayIcon",
      options,
      id: create_fragment192.name
    });
  }
  get size() {
    throw new Error("<PlayIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PlayIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PlayIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PlayIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PlayIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PlayIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PlayIcon_default = PlayIcon;

// node_modules/svelte-feather-icons/src/icons/PlusCircleIcon.svelte
var file193 = "node_modules/svelte-feather-icons/src/icons/PlusCircleIcon.svelte";
function create_fragment193(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file193, 13, 248, 532);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "16");
      add_location(line0, file193, 13, 288, 572);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "16");
      attr_dev(line1, "y2", "12");
      add_location(line1, file193, 13, 332, 616);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-plus-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file193, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-plus-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment193.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance193($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PlusCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PlusCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PlusCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance193, create_fragment193, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PlusCircleIcon",
      options,
      id: create_fragment193.name
    });
  }
  get size() {
    throw new Error("<PlusCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PlusCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PlusCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PlusCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PlusCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PlusCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PlusCircleIcon_default = PlusCircleIcon;

// node_modules/svelte-feather-icons/src/icons/PlusSquareIcon.svelte
var file194 = "node_modules/svelte-feather-icons/src/icons/PlusSquareIcon.svelte";
function create_fragment194(ctx) {
  let svg;
  let rect;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file194, 13, 248, 532);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "16");
      add_location(line0, file194, 13, 310, 594);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "16");
      attr_dev(line1, "y2", "12");
      add_location(line1, file194, 13, 354, 638);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-plus-square " + /*customClass*/
      ctx[2]);
      add_location(svg, file194, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-plus-square " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment194.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance194($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PlusSquareIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PlusSquareIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PlusSquareIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance194, create_fragment194, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PlusSquareIcon",
      options,
      id: create_fragment194.name
    });
  }
  get size() {
    throw new Error("<PlusSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PlusSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PlusSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PlusSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PlusSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PlusSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PlusSquareIcon_default = PlusSquareIcon;

// node_modules/svelte-feather-icons/src/icons/PlusIcon.svelte
var file195 = "node_modules/svelte-feather-icons/src/icons/PlusIcon.svelte";
function create_fragment195(ctx) {
  let svg;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "5");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "19");
      add_location(line0, file195, 13, 241, 525);
      attr_dev(line1, "x1", "5");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "19");
      attr_dev(line1, "y2", "12");
      add_location(line1, file195, 13, 285, 569);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-plus " + /*customClass*/
      ctx[2]);
      add_location(svg, file195, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-plus " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment195.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance195($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PlusIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PlusIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PlusIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance195, create_fragment195, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PlusIcon",
      options,
      id: create_fragment195.name
    });
  }
  get size() {
    throw new Error("<PlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PlusIcon_default = PlusIcon;

// node_modules/svelte-feather-icons/src/icons/PocketIcon.svelte
var file196 = "node_modules/svelte-feather-icons/src/icons/PocketIcon.svelte";
function create_fragment196(ctx) {
  let svg;
  let path;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z");
      add_location(path, file196, 13, 243, 527);
      attr_dev(polyline, "points", "8 10 12 14 16 10");
      add_location(polyline, file196, 13, 336, 620);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-pocket " + /*customClass*/
      ctx[2]);
      add_location(svg, file196, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-pocket " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment196.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance196($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PocketIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PocketIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PocketIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance196, create_fragment196, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PocketIcon",
      options,
      id: create_fragment196.name
    });
  }
  get size() {
    throw new Error("<PocketIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PocketIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PocketIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PocketIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PocketIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PocketIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PocketIcon_default = PocketIcon;

// node_modules/svelte-feather-icons/src/icons/PowerIcon.svelte
var file197 = "node_modules/svelte-feather-icons/src/icons/PowerIcon.svelte";
function create_fragment197(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.36 6.64a9 9 0 1 1-12.73 0");
      add_location(path, file197, 13, 242, 526);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "2");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "12");
      add_location(line, file197, 13, 289, 573);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-power " + /*customClass*/
      ctx[2]);
      add_location(svg, file197, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-power " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment197.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance197($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PowerIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PowerIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PowerIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance197, create_fragment197, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PowerIcon",
      options,
      id: create_fragment197.name
    });
  }
  get size() {
    throw new Error("<PowerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PowerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PowerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PowerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PowerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PowerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PowerIcon_default = PowerIcon;

// node_modules/svelte-feather-icons/src/icons/PrinterIcon.svelte
var file198 = "node_modules/svelte-feather-icons/src/icons/PrinterIcon.svelte";
function create_fragment198(ctx) {
  let svg;
  let polyline;
  let path;
  let rect;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "6 9 6 2 18 2 18 9");
      add_location(polyline, file198, 13, 244, 528);
      attr_dev(path, "d", "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2");
      add_location(path, file198, 13, 292, 576);
      attr_dev(rect, "x", "6");
      attr_dev(rect, "y", "14");
      attr_dev(rect, "width", "12");
      attr_dev(rect, "height", "8");
      add_location(rect, file198, 13, 384, 668);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-printer " + /*customClass*/
      ctx[2]);
      add_location(svg, file198, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, rect);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-printer " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment198.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance198($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PrinterIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PrinterIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var PrinterIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance198, create_fragment198, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PrinterIcon",
      options,
      id: create_fragment198.name
    });
  }
  get size() {
    throw new Error("<PrinterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PrinterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PrinterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PrinterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PrinterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PrinterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PrinterIcon_default = PrinterIcon;

// node_modules/svelte-feather-icons/src/icons/RadioIcon.svelte
var file199 = "node_modules/svelte-feather-icons/src/icons/RadioIcon.svelte";
function create_fragment199(ctx) {
  let svg;
  let circle;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "2");
      add_location(circle, file199, 13, 242, 526);
      attr_dev(path, "d", "M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14");
      add_location(path, file199, 13, 281, 565);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-radio " + /*customClass*/
      ctx[2]);
      add_location(svg, file199, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-radio " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment199.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance199($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RadioIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var RadioIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance199, create_fragment199, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioIcon",
      options,
      id: create_fragment199.name
    });
  }
  get size() {
    throw new Error("<RadioIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<RadioIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<RadioIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<RadioIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<RadioIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<RadioIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioIcon_default = RadioIcon;

// node_modules/svelte-feather-icons/src/icons/RefreshCcwIcon.svelte
var file200 = "node_modules/svelte-feather-icons/src/icons/RefreshCcwIcon.svelte";
function create_fragment200(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "1 4 1 10 7 10");
      add_location(polyline0, file200, 13, 248, 532);
      attr_dev(polyline1, "points", "23 20 23 14 17 14");
      add_location(polyline1, file200, 13, 292, 576);
      attr_dev(path, "d", "M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15");
      add_location(path, file200, 13, 340, 624);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-refresh-ccw " + /*customClass*/
      ctx[2]);
      add_location(svg, file200, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-refresh-ccw " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment200.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance200($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RefreshCcwIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RefreshCcwIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var RefreshCcwIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance200, create_fragment200, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RefreshCcwIcon",
      options,
      id: create_fragment200.name
    });
  }
  get size() {
    throw new Error("<RefreshCcwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<RefreshCcwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<RefreshCcwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<RefreshCcwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<RefreshCcwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<RefreshCcwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RefreshCcwIcon_default = RefreshCcwIcon;

// node_modules/svelte-feather-icons/src/icons/RefreshCwIcon.svelte
var file201 = "node_modules/svelte-feather-icons/src/icons/RefreshCwIcon.svelte";
function create_fragment201(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "23 4 23 10 17 10");
      add_location(polyline0, file201, 13, 247, 531);
      attr_dev(polyline1, "points", "1 20 1 14 7 14");
      add_location(polyline1, file201, 13, 294, 578);
      attr_dev(path, "d", "M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15");
      add_location(path, file201, 13, 339, 623);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-refresh-cw " + /*customClass*/
      ctx[2]);
      add_location(svg, file201, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-refresh-cw " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment201.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance201($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RefreshCwIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RefreshCwIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var RefreshCwIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance201, create_fragment201, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RefreshCwIcon",
      options,
      id: create_fragment201.name
    });
  }
  get size() {
    throw new Error("<RefreshCwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<RefreshCwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<RefreshCwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<RefreshCwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<RefreshCwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<RefreshCwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RefreshCwIcon_default = RefreshCwIcon;

// node_modules/svelte-feather-icons/src/icons/RepeatIcon.svelte
var file202 = "node_modules/svelte-feather-icons/src/icons/RepeatIcon.svelte";
function create_fragment202(ctx) {
  let svg;
  let polyline0;
  let path0;
  let polyline1;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      path0 = svg_element("path");
      polyline1 = svg_element("polyline");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "17 1 21 5 17 9");
      add_location(polyline0, file202, 13, 243, 527);
      attr_dev(path0, "d", "M3 11V9a4 4 0 0 1 4-4h14");
      add_location(path0, file202, 13, 288, 572);
      attr_dev(polyline1, "points", "7 23 3 19 7 15");
      add_location(polyline1, file202, 13, 330, 614);
      attr_dev(path1, "d", "M21 13v2a4 4 0 0 1-4 4H3");
      add_location(path1, file202, 13, 375, 659);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-repeat " + /*customClass*/
      ctx[2]);
      add_location(svg, file202, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, polyline1);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-repeat " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment202.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance202($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RepeatIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RepeatIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var RepeatIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance202, create_fragment202, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RepeatIcon",
      options,
      id: create_fragment202.name
    });
  }
  get size() {
    throw new Error("<RepeatIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<RepeatIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<RepeatIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<RepeatIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<RepeatIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<RepeatIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RepeatIcon_default = RepeatIcon;

// node_modules/svelte-feather-icons/src/icons/RewindIcon.svelte
var file203 = "node_modules/svelte-feather-icons/src/icons/RewindIcon.svelte";
function create_fragment203(ctx) {
  let svg;
  let polygon0;
  let polygon1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon0 = svg_element("polygon");
      polygon1 = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon0 = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon0).forEach(detach_dev);
      polygon1 = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon0, "points", "11 19 2 12 11 5 11 19");
      add_location(polygon0, file203, 13, 243, 527);
      attr_dev(polygon1, "points", "22 19 13 12 22 5 22 19");
      add_location(polygon1, file203, 13, 293, 577);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-rewind " + /*customClass*/
      ctx[2]);
      add_location(svg, file203, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon0);
      append_hydration_dev(svg, polygon1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-rewind " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment203.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance203($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RewindIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RewindIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var RewindIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance203, create_fragment203, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RewindIcon",
      options,
      id: create_fragment203.name
    });
  }
  get size() {
    throw new Error("<RewindIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<RewindIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<RewindIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<RewindIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<RewindIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<RewindIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RewindIcon_default = RewindIcon;

// node_modules/svelte-feather-icons/src/icons/RotateCcwIcon.svelte
var file204 = "node_modules/svelte-feather-icons/src/icons/RotateCcwIcon.svelte";
function create_fragment204(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "1 4 1 10 7 10");
      add_location(polyline, file204, 13, 247, 531);
      attr_dev(path, "d", "M3.51 15a9 9 0 1 0 2.13-9.36L1 10");
      add_location(path, file204, 13, 291, 575);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-rotate-ccw " + /*customClass*/
      ctx[2]);
      add_location(svg, file204, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-rotate-ccw " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment204.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance204($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RotateCcwIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RotateCcwIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var RotateCcwIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance204, create_fragment204, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RotateCcwIcon",
      options,
      id: create_fragment204.name
    });
  }
  get size() {
    throw new Error("<RotateCcwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<RotateCcwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<RotateCcwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<RotateCcwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<RotateCcwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<RotateCcwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RotateCcwIcon_default = RotateCcwIcon;

// node_modules/svelte-feather-icons/src/icons/RotateCwIcon.svelte
var file205 = "node_modules/svelte-feather-icons/src/icons/RotateCwIcon.svelte";
function create_fragment205(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "23 4 23 10 17 10");
      add_location(polyline, file205, 13, 246, 530);
      attr_dev(path, "d", "M20.49 15a9 9 0 1 1-2.12-9.36L23 10");
      add_location(path, file205, 13, 293, 577);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-rotate-cw " + /*customClass*/
      ctx[2]);
      add_location(svg, file205, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-rotate-cw " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment205.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance205($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RotateCwIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RotateCwIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var RotateCwIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance205, create_fragment205, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RotateCwIcon",
      options,
      id: create_fragment205.name
    });
  }
  get size() {
    throw new Error("<RotateCwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<RotateCwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<RotateCwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<RotateCwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<RotateCwIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<RotateCwIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RotateCwIcon_default = RotateCwIcon;

// node_modules/svelte-feather-icons/src/icons/RssIcon.svelte
var file206 = "node_modules/svelte-feather-icons/src/icons/RssIcon.svelte";
function create_fragment206(ctx) {
  let svg;
  let path0;
  let path1;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M4 11a9 9 0 0 1 9 9");
      add_location(path0, file206, 13, 240, 524);
      attr_dev(path1, "d", "M4 4a16 16 0 0 1 16 16");
      add_location(path1, file206, 13, 277, 561);
      attr_dev(circle, "cx", "5");
      attr_dev(circle, "cy", "19");
      attr_dev(circle, "r", "1");
      add_location(circle, file206, 13, 317, 601);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-rss " + /*customClass*/
      ctx[2]);
      add_location(svg, file206, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-rss " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment206.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance206($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RssIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RssIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var RssIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance206, create_fragment206, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RssIcon",
      options,
      id: create_fragment206.name
    });
  }
  get size() {
    throw new Error("<RssIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<RssIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<RssIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<RssIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<RssIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<RssIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RssIcon_default = RssIcon;

// node_modules/svelte-feather-icons/src/icons/SaveIcon.svelte
var file207 = "node_modules/svelte-feather-icons/src/icons/SaveIcon.svelte";
function create_fragment207(ctx) {
  let svg;
  let path;
  let polyline0;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z");
      add_location(path, file207, 13, 241, 525);
      attr_dev(polyline0, "points", "17 21 17 13 7 13 7 21");
      add_location(polyline0, file207, 13, 322, 606);
      attr_dev(polyline1, "points", "7 3 7 8 15 8");
      add_location(polyline1, file207, 13, 374, 658);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-save " + /*customClass*/
      ctx[2]);
      add_location(svg, file207, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-save " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment207.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance207($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SaveIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SaveIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SaveIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance207, create_fragment207, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SaveIcon",
      options,
      id: create_fragment207.name
    });
  }
  get size() {
    throw new Error("<SaveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SaveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SaveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SaveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SaveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SaveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SaveIcon_default = SaveIcon;

// node_modules/svelte-feather-icons/src/icons/ScissorsIcon.svelte
var file208 = "node_modules/svelte-feather-icons/src/icons/ScissorsIcon.svelte";
function create_fragment208(ctx) {
  let svg;
  let circle0;
  let circle1;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "6");
      attr_dev(circle0, "cy", "6");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file208, 13, 245, 529);
      attr_dev(circle1, "cx", "6");
      attr_dev(circle1, "cy", "18");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file208, 13, 282, 566);
      attr_dev(line0, "x1", "20");
      attr_dev(line0, "y1", "4");
      attr_dev(line0, "x2", "8.12");
      attr_dev(line0, "y2", "15.88");
      add_location(line0, file208, 13, 320, 604);
      attr_dev(line1, "x1", "14.47");
      attr_dev(line1, "y1", "14.48");
      attr_dev(line1, "x2", "20");
      attr_dev(line1, "y2", "20");
      add_location(line1, file208, 13, 369, 653);
      attr_dev(line2, "x1", "8.12");
      attr_dev(line2, "y1", "8.12");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "12");
      add_location(line2, file208, 13, 420, 704);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-scissors " + /*customClass*/
      ctx[2]);
      add_location(svg, file208, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-scissors " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment208.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance208($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScissorsIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScissorsIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ScissorsIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance208, create_fragment208, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScissorsIcon",
      options,
      id: create_fragment208.name
    });
  }
  get size() {
    throw new Error("<ScissorsIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ScissorsIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ScissorsIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ScissorsIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ScissorsIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ScissorsIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScissorsIcon_default = ScissorsIcon;

// node_modules/svelte-feather-icons/src/icons/SearchIcon.svelte
var file209 = "node_modules/svelte-feather-icons/src/icons/SearchIcon.svelte";
function create_fragment209(ctx) {
  let svg;
  let circle;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "11");
      attr_dev(circle, "cy", "11");
      attr_dev(circle, "r", "8");
      add_location(circle, file209, 13, 243, 527);
      attr_dev(line, "x1", "21");
      attr_dev(line, "y1", "21");
      attr_dev(line, "x2", "16.65");
      attr_dev(line, "y2", "16.65");
      add_location(line, file209, 13, 282, 566);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-search " + /*customClass*/
      ctx[2]);
      add_location(svg, file209, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-search " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment209.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance209($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SearchIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SearchIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SearchIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance209, create_fragment209, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SearchIcon",
      options,
      id: create_fragment209.name
    });
  }
  get size() {
    throw new Error("<SearchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SearchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SearchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SearchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SearchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SearchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SearchIcon_default = SearchIcon;

// node_modules/svelte-feather-icons/src/icons/SendIcon.svelte
var file210 = "node_modules/svelte-feather-icons/src/icons/SendIcon.svelte";
function create_fragment210(ctx) {
  let svg;
  let line;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line = svg_element("line");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "22");
      attr_dev(line, "y1", "2");
      attr_dev(line, "x2", "11");
      attr_dev(line, "y2", "13");
      add_location(line, file210, 13, 241, 525);
      attr_dev(polygon, "points", "22 2 15 22 11 13 2 9 22 2");
      add_location(polygon, file210, 13, 285, 569);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-send " + /*customClass*/
      ctx[2]);
      add_location(svg, file210, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-send " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment210.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance210($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SendIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SendIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SendIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance210, create_fragment210, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SendIcon",
      options,
      id: create_fragment210.name
    });
  }
  get size() {
    throw new Error("<SendIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SendIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SendIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SendIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SendIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SendIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SendIcon_default = SendIcon;

// node_modules/svelte-feather-icons/src/icons/ServerIcon.svelte
var file211 = "node_modules/svelte-feather-icons/src/icons/ServerIcon.svelte";
function create_fragment211(ctx) {
  let svg;
  let rect0;
  let rect1;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect0 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect0).forEach(detach_dev);
      rect1 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect1).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect0, "x", "2");
      attr_dev(rect0, "y", "2");
      attr_dev(rect0, "width", "20");
      attr_dev(rect0, "height", "8");
      attr_dev(rect0, "rx", "2");
      attr_dev(rect0, "ry", "2");
      add_location(rect0, file211, 13, 243, 527);
      attr_dev(rect1, "x", "2");
      attr_dev(rect1, "y", "14");
      attr_dev(rect1, "width", "20");
      attr_dev(rect1, "height", "8");
      attr_dev(rect1, "rx", "2");
      attr_dev(rect1, "ry", "2");
      add_location(rect1, file211, 13, 304, 588);
      attr_dev(line0, "x1", "6");
      attr_dev(line0, "y1", "6");
      attr_dev(line0, "x2", "6.01");
      attr_dev(line0, "y2", "6");
      add_location(line0, file211, 13, 366, 650);
      attr_dev(line1, "x1", "6");
      attr_dev(line1, "y1", "18");
      attr_dev(line1, "x2", "6.01");
      attr_dev(line1, "y2", "18");
      add_location(line1, file211, 13, 410, 694);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-server " + /*customClass*/
      ctx[2]);
      add_location(svg, file211, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect0);
      append_hydration_dev(svg, rect1);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-server " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment211.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance211($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ServerIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ServerIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ServerIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance211, create_fragment211, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ServerIcon",
      options,
      id: create_fragment211.name
    });
  }
  get size() {
    throw new Error("<ServerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ServerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ServerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ServerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ServerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ServerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ServerIcon_default = ServerIcon;

// node_modules/svelte-feather-icons/src/icons/SettingsIcon.svelte
var file212 = "node_modules/svelte-feather-icons/src/icons/SettingsIcon.svelte";
function create_fragment212(ctx) {
  let svg;
  let circle;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "3");
      add_location(circle, file212, 13, 245, 529);
      attr_dev(path, "d", "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z");
      add_location(path, file212, 13, 284, 568);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-settings " + /*customClass*/
      ctx[2]);
      add_location(svg, file212, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-settings " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment212.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance212($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SettingsIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SettingsIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SettingsIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance212, create_fragment212, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SettingsIcon",
      options,
      id: create_fragment212.name
    });
  }
  get size() {
    throw new Error("<SettingsIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SettingsIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SettingsIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SettingsIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SettingsIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SettingsIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SettingsIcon_default = SettingsIcon;

// node_modules/svelte-feather-icons/src/icons/Share2Icon.svelte
var file213 = "node_modules/svelte-feather-icons/src/icons/Share2Icon.svelte";
function create_fragment213(ctx) {
  let svg;
  let circle0;
  let circle1;
  let circle2;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      circle2 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle2).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "18");
      attr_dev(circle0, "cy", "5");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file213, 13, 244, 528);
      attr_dev(circle1, "cx", "6");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file213, 13, 282, 566);
      attr_dev(circle2, "cx", "18");
      attr_dev(circle2, "cy", "19");
      attr_dev(circle2, "r", "3");
      add_location(circle2, file213, 13, 320, 604);
      attr_dev(line0, "x1", "8.59");
      attr_dev(line0, "y1", "13.51");
      attr_dev(line0, "x2", "15.42");
      attr_dev(line0, "y2", "17.49");
      add_location(line0, file213, 13, 359, 643);
      attr_dev(line1, "x1", "15.41");
      attr_dev(line1, "y1", "6.51");
      attr_dev(line1, "x2", "8.59");
      attr_dev(line1, "y2", "10.49");
      add_location(line1, file213, 13, 415, 699);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-share-2 " + /*customClass*/
      ctx[2]);
      add_location(svg, file213, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, circle2);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-share-2 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment213.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance213($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Share2Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Share2Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var Share2Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance213, create_fragment213, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Share2Icon",
      options,
      id: create_fragment213.name
    });
  }
  get size() {
    throw new Error("<Share2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Share2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Share2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Share2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Share2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Share2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Share2Icon_default = Share2Icon;

// node_modules/svelte-feather-icons/src/icons/ShareIcon.svelte
var file214 = "node_modules/svelte-feather-icons/src/icons/ShareIcon.svelte";
function create_fragment214(ctx) {
  let svg;
  let path;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8");
      add_location(path, file214, 13, 242, 526);
      attr_dev(polyline, "points", "16 6 12 2 8 6");
      add_location(polyline, file214, 13, 301, 585);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "2");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "15");
      add_location(line, file214, 13, 345, 629);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-share " + /*customClass*/
      ctx[2]);
      add_location(svg, file214, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-share " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment214.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance214($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ShareIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ShareIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ShareIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance214, create_fragment214, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ShareIcon",
      options,
      id: create_fragment214.name
    });
  }
  get size() {
    throw new Error("<ShareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ShareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ShareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ShareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ShareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ShareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ShareIcon_default = ShareIcon;

// node_modules/svelte-feather-icons/src/icons/ShieldOffIcon.svelte
var file215 = "node_modules/svelte-feather-icons/src/icons/ShieldOffIcon.svelte";
function create_fragment215(ctx) {
  let svg;
  let path0;
  let path1;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18");
      add_location(path0, file215, 13, 247, 531);
      attr_dev(path1, "d", "M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38");
      add_location(path1, file215, 13, 311, 595);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file215, 13, 387, 671);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-shield-off " + /*customClass*/
      ctx[2]);
      add_location(svg, file215, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-shield-off " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment215.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance215($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ShieldOffIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ShieldOffIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ShieldOffIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance215, create_fragment215, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ShieldOffIcon",
      options,
      id: create_fragment215.name
    });
  }
  get size() {
    throw new Error("<ShieldOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ShieldOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ShieldOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ShieldOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ShieldOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ShieldOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ShieldOffIcon_default = ShieldOffIcon;

// node_modules/svelte-feather-icons/src/icons/ShieldIcon.svelte
var file216 = "node_modules/svelte-feather-icons/src/icons/ShieldIcon.svelte";
function create_fragment216(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z");
      add_location(path, file216, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-shield " + /*customClass*/
      ctx[2]);
      add_location(svg, file216, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-shield " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment216.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance216($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ShieldIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ShieldIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ShieldIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance216, create_fragment216, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ShieldIcon",
      options,
      id: create_fragment216.name
    });
  }
  get size() {
    throw new Error("<ShieldIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ShieldIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ShieldIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ShieldIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ShieldIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ShieldIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ShieldIcon_default = ShieldIcon;

// node_modules/svelte-feather-icons/src/icons/ShoppingBagIcon.svelte
var file217 = "node_modules/svelte-feather-icons/src/icons/ShoppingBagIcon.svelte";
function create_fragment217(ctx) {
  let svg;
  let path0;
  let line;
  let path1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      line = svg_element("line");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z");
      add_location(path0, file217, 13, 249, 533);
      attr_dev(line, "x1", "3");
      attr_dev(line, "y1", "6");
      attr_dev(line, "x2", "21");
      attr_dev(line, "y2", "6");
      add_location(line, file217, 13, 317, 601);
      attr_dev(path1, "d", "M16 10a4 4 0 0 1-8 0");
      add_location(path1, file217, 13, 359, 643);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-shopping-bag " + /*customClass*/
      ctx[2]);
      add_location(svg, file217, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-shopping-bag " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment217.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance217($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ShoppingBagIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ShoppingBagIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ShoppingBagIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance217, create_fragment217, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ShoppingBagIcon",
      options,
      id: create_fragment217.name
    });
  }
  get size() {
    throw new Error("<ShoppingBagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ShoppingBagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ShoppingBagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ShoppingBagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ShoppingBagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ShoppingBagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ShoppingBagIcon_default = ShoppingBagIcon;

// node_modules/svelte-feather-icons/src/icons/ShoppingCartIcon.svelte
var file218 = "node_modules/svelte-feather-icons/src/icons/ShoppingCartIcon.svelte";
function create_fragment218(ctx) {
  let svg;
  let circle0;
  let circle1;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "9");
      attr_dev(circle0, "cy", "21");
      attr_dev(circle0, "r", "1");
      add_location(circle0, file218, 13, 250, 534);
      attr_dev(circle1, "cx", "20");
      attr_dev(circle1, "cy", "21");
      attr_dev(circle1, "r", "1");
      add_location(circle1, file218, 13, 288, 572);
      attr_dev(path, "d", "M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6");
      add_location(path, file218, 13, 327, 611);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-shopping-cart " + /*customClass*/
      ctx[2]);
      add_location(svg, file218, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-shopping-cart " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment218.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance218($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ShoppingCartIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ShoppingCartIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ShoppingCartIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance218, create_fragment218, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ShoppingCartIcon",
      options,
      id: create_fragment218.name
    });
  }
  get size() {
    throw new Error("<ShoppingCartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ShoppingCartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ShoppingCartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ShoppingCartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ShoppingCartIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ShoppingCartIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ShoppingCartIcon_default = ShoppingCartIcon;

// node_modules/svelte-feather-icons/src/icons/ShuffleIcon.svelte
var file219 = "node_modules/svelte-feather-icons/src/icons/ShuffleIcon.svelte";
function create_fragment219(ctx) {
  let svg;
  let polyline0;
  let line0;
  let polyline1;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      line0 = svg_element("line");
      polyline1 = svg_element("polyline");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "16 3 21 3 21 8");
      add_location(polyline0, file219, 13, 244, 528);
      attr_dev(line0, "x1", "4");
      attr_dev(line0, "y1", "20");
      attr_dev(line0, "x2", "21");
      attr_dev(line0, "y2", "3");
      add_location(line0, file219, 13, 289, 573);
      attr_dev(polyline1, "points", "21 16 21 21 16 21");
      add_location(polyline1, file219, 13, 332, 616);
      attr_dev(line1, "x1", "15");
      attr_dev(line1, "y1", "15");
      attr_dev(line1, "x2", "21");
      attr_dev(line1, "y2", "21");
      add_location(line1, file219, 13, 380, 664);
      attr_dev(line2, "x1", "4");
      attr_dev(line2, "y1", "4");
      attr_dev(line2, "x2", "9");
      attr_dev(line2, "y2", "9");
      add_location(line2, file219, 13, 425, 709);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-shuffle " + /*customClass*/
      ctx[2]);
      add_location(svg, file219, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, polyline1);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-shuffle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment219.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance219($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ShuffleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ShuffleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ShuffleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance219, create_fragment219, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ShuffleIcon",
      options,
      id: create_fragment219.name
    });
  }
  get size() {
    throw new Error("<ShuffleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ShuffleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ShuffleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ShuffleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ShuffleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ShuffleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ShuffleIcon_default = ShuffleIcon;

// node_modules/svelte-feather-icons/src/icons/SidebarIcon.svelte
var file220 = "node_modules/svelte-feather-icons/src/icons/SidebarIcon.svelte";
function create_fragment220(ctx) {
  let svg;
  let rect;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file220, 13, 244, 528);
      attr_dev(line, "x1", "9");
      attr_dev(line, "y1", "3");
      attr_dev(line, "x2", "9");
      attr_dev(line, "y2", "21");
      add_location(line, file220, 13, 306, 590);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-sidebar " + /*customClass*/
      ctx[2]);
      add_location(svg, file220, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-sidebar " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment220.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance220($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SidebarIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SidebarIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SidebarIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance220, create_fragment220, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SidebarIcon",
      options,
      id: create_fragment220.name
    });
  }
  get size() {
    throw new Error("<SidebarIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SidebarIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SidebarIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SidebarIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SidebarIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SidebarIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SidebarIcon_default = SidebarIcon;

// node_modules/svelte-feather-icons/src/icons/SkipBackIcon.svelte
var file221 = "node_modules/svelte-feather-icons/src/icons/SkipBackIcon.svelte";
function create_fragment221(ctx) {
  let svg;
  let polygon;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "19 20 9 12 19 4 19 20");
      add_location(polygon, file221, 13, 246, 530);
      attr_dev(line, "x1", "5");
      attr_dev(line, "y1", "19");
      attr_dev(line, "x2", "5");
      attr_dev(line, "y2", "5");
      add_location(line, file221, 13, 296, 580);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-skip-back " + /*customClass*/
      ctx[2]);
      add_location(svg, file221, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-skip-back " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment221.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance221($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkipBackIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SkipBackIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SkipBackIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance221, create_fragment221, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkipBackIcon",
      options,
      id: create_fragment221.name
    });
  }
  get size() {
    throw new Error("<SkipBackIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SkipBackIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SkipBackIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SkipBackIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SkipBackIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SkipBackIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SkipBackIcon_default = SkipBackIcon;

// node_modules/svelte-feather-icons/src/icons/SkipForwardIcon.svelte
var file222 = "node_modules/svelte-feather-icons/src/icons/SkipForwardIcon.svelte";
function create_fragment222(ctx) {
  let svg;
  let polygon;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "5 4 15 12 5 20 5 4");
      add_location(polygon, file222, 13, 249, 533);
      attr_dev(line, "x1", "19");
      attr_dev(line, "y1", "5");
      attr_dev(line, "x2", "19");
      attr_dev(line, "y2", "19");
      add_location(line, file222, 13, 296, 580);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-skip-forward " + /*customClass*/
      ctx[2]);
      add_location(svg, file222, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-skip-forward " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment222.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance222($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkipForwardIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SkipForwardIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SkipForwardIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance222, create_fragment222, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkipForwardIcon",
      options,
      id: create_fragment222.name
    });
  }
  get size() {
    throw new Error("<SkipForwardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SkipForwardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SkipForwardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SkipForwardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SkipForwardIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SkipForwardIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SkipForwardIcon_default = SkipForwardIcon;

// node_modules/svelte-feather-icons/src/icons/SlackIcon.svelte
var file223 = "node_modules/svelte-feather-icons/src/icons/SlackIcon.svelte";
function create_fragment223(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let path3;
  let path4;
  let path5;
  let path6;
  let path7;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      path5 = svg_element("path");
      path6 = svg_element("path");
      path7 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path3).forEach(detach_dev);
      path4 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path4).forEach(detach_dev);
      path5 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path5).forEach(detach_dev);
      path6 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path6).forEach(detach_dev);
      path7 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path7).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z");
      add_location(path0, file223, 13, 242, 526);
      attr_dev(path1, "d", "M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
      add_location(path1, file223, 13, 355, 639);
      attr_dev(path2, "d", "M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z");
      add_location(path2, file223, 13, 441, 725);
      attr_dev(path3, "d", "M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z");
      add_location(path3, file223, 13, 551, 835);
      attr_dev(path4, "d", "M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z");
      add_location(path4, file223, 13, 635, 919);
      attr_dev(path5, "d", "M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z");
      add_location(path5, file223, 13, 749, 1033);
      attr_dev(path6, "d", "M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z");
      add_location(path6, file223, 13, 836, 1120);
      attr_dev(path7, "d", "M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z");
      add_location(path7, file223, 13, 945, 1229);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-slack " + /*customClass*/
      ctx[2]);
      add_location(svg, file223, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, path3);
      append_hydration_dev(svg, path4);
      append_hydration_dev(svg, path5);
      append_hydration_dev(svg, path6);
      append_hydration_dev(svg, path7);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-slack " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment223.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance223($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlackIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SlackIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SlackIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance223, create_fragment223, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlackIcon",
      options,
      id: create_fragment223.name
    });
  }
  get size() {
    throw new Error("<SlackIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SlackIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SlackIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SlackIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SlackIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SlackIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlackIcon_default = SlackIcon;

// node_modules/svelte-feather-icons/src/icons/SlashIcon.svelte
var file224 = "node_modules/svelte-feather-icons/src/icons/SlashIcon.svelte";
function create_fragment224(ctx) {
  let svg;
  let circle;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file224, 13, 242, 526);
      attr_dev(line, "x1", "4.93");
      attr_dev(line, "y1", "4.93");
      attr_dev(line, "x2", "19.07");
      attr_dev(line, "y2", "19.07");
      add_location(line, file224, 13, 282, 566);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-slash " + /*customClass*/
      ctx[2]);
      add_location(svg, file224, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-slash " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment224.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance224($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlashIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SlashIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SlashIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance224, create_fragment224, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlashIcon",
      options,
      id: create_fragment224.name
    });
  }
  get size() {
    throw new Error("<SlashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SlashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SlashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SlashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SlashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SlashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlashIcon_default = SlashIcon;

// node_modules/svelte-feather-icons/src/icons/SlidersIcon.svelte
var file225 = "node_modules/svelte-feather-icons/src/icons/SlidersIcon.svelte";
function create_fragment225(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let line6;
  let line7;
  let line8;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      line6 = svg_element("line");
      line7 = svg_element("line");
      line8 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      line6 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line6).forEach(detach_dev);
      line7 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line7).forEach(detach_dev);
      line8 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line8).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "4");
      attr_dev(line0, "y1", "21");
      attr_dev(line0, "x2", "4");
      attr_dev(line0, "y2", "14");
      add_location(line0, file225, 13, 244, 528);
      attr_dev(line1, "x1", "4");
      attr_dev(line1, "y1", "10");
      attr_dev(line1, "x2", "4");
      attr_dev(line1, "y2", "3");
      add_location(line1, file225, 13, 287, 571);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "21");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "12");
      add_location(line2, file225, 13, 329, 613);
      attr_dev(line3, "x1", "12");
      attr_dev(line3, "y1", "8");
      attr_dev(line3, "x2", "12");
      attr_dev(line3, "y2", "3");
      add_location(line3, file225, 13, 374, 658);
      attr_dev(line4, "x1", "20");
      attr_dev(line4, "y1", "21");
      attr_dev(line4, "x2", "20");
      attr_dev(line4, "y2", "16");
      add_location(line4, file225, 13, 417, 701);
      attr_dev(line5, "x1", "20");
      attr_dev(line5, "y1", "12");
      attr_dev(line5, "x2", "20");
      attr_dev(line5, "y2", "3");
      add_location(line5, file225, 13, 462, 746);
      attr_dev(line6, "x1", "1");
      attr_dev(line6, "y1", "14");
      attr_dev(line6, "x2", "7");
      attr_dev(line6, "y2", "14");
      add_location(line6, file225, 13, 506, 790);
      attr_dev(line7, "x1", "9");
      attr_dev(line7, "y1", "8");
      attr_dev(line7, "x2", "15");
      attr_dev(line7, "y2", "8");
      add_location(line7, file225, 13, 549, 833);
      attr_dev(line8, "x1", "17");
      attr_dev(line8, "y1", "16");
      attr_dev(line8, "x2", "23");
      attr_dev(line8, "y2", "16");
      add_location(line8, file225, 13, 591, 875);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-sliders " + /*customClass*/
      ctx[2]);
      add_location(svg, file225, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
      append_hydration_dev(svg, line6);
      append_hydration_dev(svg, line7);
      append_hydration_dev(svg, line8);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-sliders " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment225.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance225($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlidersIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SlidersIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SlidersIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance225, create_fragment225, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlidersIcon",
      options,
      id: create_fragment225.name
    });
  }
  get size() {
    throw new Error("<SlidersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SlidersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SlidersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SlidersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SlidersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SlidersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlidersIcon_default = SlidersIcon;

// node_modules/svelte-feather-icons/src/icons/SmartphoneIcon.svelte
var file226 = "node_modules/svelte-feather-icons/src/icons/SmartphoneIcon.svelte";
function create_fragment226(ctx) {
  let svg;
  let rect;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "5");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "14");
      attr_dev(rect, "height", "20");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file226, 13, 247, 531);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "18");
      attr_dev(line, "x2", "12.01");
      attr_dev(line, "y2", "18");
      add_location(line, file226, 13, 309, 593);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-smartphone " + /*customClass*/
      ctx[2]);
      add_location(svg, file226, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-smartphone " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment226.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance226($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SmartphoneIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SmartphoneIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SmartphoneIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance226, create_fragment226, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SmartphoneIcon",
      options,
      id: create_fragment226.name
    });
  }
  get size() {
    throw new Error("<SmartphoneIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SmartphoneIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SmartphoneIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SmartphoneIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SmartphoneIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SmartphoneIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SmartphoneIcon_default = SmartphoneIcon;

// node_modules/svelte-feather-icons/src/icons/SmileIcon.svelte
var file227 = "node_modules/svelte-feather-icons/src/icons/SmileIcon.svelte";
function create_fragment227(ctx) {
  let svg;
  let circle;
  let path;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file227, 13, 242, 526);
      attr_dev(path, "d", "M8 14s1.5 2 4 2 4-2 4-2");
      add_location(path, file227, 13, 282, 566);
      attr_dev(line0, "x1", "9");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "9.01");
      attr_dev(line0, "y2", "9");
      add_location(line0, file227, 13, 323, 607);
      attr_dev(line1, "x1", "15");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "15.01");
      attr_dev(line1, "y2", "9");
      add_location(line1, file227, 13, 367, 651);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-smile " + /*customClass*/
      ctx[2]);
      add_location(svg, file227, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-smile " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment227.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance227($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SmileIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SmileIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SmileIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance227, create_fragment227, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SmileIcon",
      options,
      id: create_fragment227.name
    });
  }
  get size() {
    throw new Error("<SmileIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SmileIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SmileIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SmileIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SmileIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SmileIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SmileIcon_default = SmileIcon;

// node_modules/svelte-feather-icons/src/icons/SpeakerIcon.svelte
var file228 = "node_modules/svelte-feather-icons/src/icons/SpeakerIcon.svelte";
function create_fragment228(ctx) {
  let svg;
  let rect;
  let circle;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      circle = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "4");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "16");
      attr_dev(rect, "height", "20");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file228, 13, 244, 528);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "14");
      attr_dev(circle, "r", "4");
      add_location(circle, file228, 13, 306, 590);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "6");
      attr_dev(line, "x2", "12.01");
      attr_dev(line, "y2", "6");
      add_location(line, file228, 13, 345, 629);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-speaker " + /*customClass*/
      ctx[2]);
      add_location(svg, file228, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-speaker " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment228.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance228($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SpeakerIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SpeakerIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SpeakerIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance228, create_fragment228, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SpeakerIcon",
      options,
      id: create_fragment228.name
    });
  }
  get size() {
    throw new Error("<SpeakerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SpeakerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SpeakerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SpeakerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SpeakerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SpeakerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SpeakerIcon_default = SpeakerIcon;

// node_modules/svelte-feather-icons/src/icons/SquareIcon.svelte
var file229 = "node_modules/svelte-feather-icons/src/icons/SquareIcon.svelte";
function create_fragment229(ctx) {
  let svg;
  let rect;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file229, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-square " + /*customClass*/
      ctx[2]);
      add_location(svg, file229, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-square " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment229.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance229($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SquareIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SquareIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SquareIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance229, create_fragment229, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SquareIcon",
      options,
      id: create_fragment229.name
    });
  }
  get size() {
    throw new Error("<SquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SquareIcon_default = SquareIcon;

// node_modules/svelte-feather-icons/src/icons/StarIcon.svelte
var file230 = "node_modules/svelte-feather-icons/src/icons/StarIcon.svelte";
function create_fragment230(ctx) {
  let svg;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2");
      add_location(polygon, file230, 13, 241, 525);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-star " + /*customClass*/
      ctx[2]);
      add_location(svg, file230, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-star " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment230.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance230($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StarIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<StarIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var StarIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance230, create_fragment230, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StarIcon",
      options,
      id: create_fragment230.name
    });
  }
  get size() {
    throw new Error("<StarIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<StarIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<StarIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<StarIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<StarIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<StarIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StarIcon_default = StarIcon;

// node_modules/svelte-feather-icons/src/icons/StopCircleIcon.svelte
var file231 = "node_modules/svelte-feather-icons/src/icons/StopCircleIcon.svelte";
function create_fragment231(ctx) {
  let svg;
  let circle;
  let rect;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file231, 13, 248, 532);
      attr_dev(rect, "x", "9");
      attr_dev(rect, "y", "9");
      attr_dev(rect, "width", "6");
      attr_dev(rect, "height", "6");
      add_location(rect, file231, 13, 288, 572);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-stop-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file231, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, rect);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-stop-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment231.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance231($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StopCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<StopCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var StopCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance231, create_fragment231, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StopCircleIcon",
      options,
      id: create_fragment231.name
    });
  }
  get size() {
    throw new Error("<StopCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<StopCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<StopCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<StopCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<StopCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<StopCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StopCircleIcon_default = StopCircleIcon;

// node_modules/svelte-feather-icons/src/icons/SunIcon.svelte
var file232 = "node_modules/svelte-feather-icons/src/icons/SunIcon.svelte";
function create_fragment232(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let line6;
  let line7;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      line6 = svg_element("line");
      line7 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      line6 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line6).forEach(detach_dev);
      line7 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line7).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "5");
      add_location(circle, file232, 13, 240, 524);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "3");
      add_location(line0, file232, 13, 279, 563);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "21");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "23");
      add_location(line1, file232, 13, 322, 606);
      attr_dev(line2, "x1", "4.22");
      attr_dev(line2, "y1", "4.22");
      attr_dev(line2, "x2", "5.64");
      attr_dev(line2, "y2", "5.64");
      add_location(line2, file232, 13, 367, 651);
      attr_dev(line3, "x1", "18.36");
      attr_dev(line3, "y1", "18.36");
      attr_dev(line3, "x2", "19.78");
      attr_dev(line3, "y2", "19.78");
      add_location(line3, file232, 13, 420, 704);
      attr_dev(line4, "x1", "1");
      attr_dev(line4, "y1", "12");
      attr_dev(line4, "x2", "3");
      attr_dev(line4, "y2", "12");
      add_location(line4, file232, 13, 477, 761);
      attr_dev(line5, "x1", "21");
      attr_dev(line5, "y1", "12");
      attr_dev(line5, "x2", "23");
      attr_dev(line5, "y2", "12");
      add_location(line5, file232, 13, 520, 804);
      attr_dev(line6, "x1", "4.22");
      attr_dev(line6, "y1", "19.78");
      attr_dev(line6, "x2", "5.64");
      attr_dev(line6, "y2", "18.36");
      add_location(line6, file232, 13, 565, 849);
      attr_dev(line7, "x1", "18.36");
      attr_dev(line7, "y1", "5.64");
      attr_dev(line7, "x2", "19.78");
      attr_dev(line7, "y2", "4.22");
      add_location(line7, file232, 13, 620, 904);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-sun " + /*customClass*/
      ctx[2]);
      add_location(svg, file232, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
      append_hydration_dev(svg, line6);
      append_hydration_dev(svg, line7);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-sun " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment232.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance232($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SunIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SunIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SunIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance232, create_fragment232, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SunIcon",
      options,
      id: create_fragment232.name
    });
  }
  get size() {
    throw new Error("<SunIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SunIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SunIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SunIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SunIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SunIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SunIcon_default = SunIcon;

// node_modules/svelte-feather-icons/src/icons/SunriseIcon.svelte
var file233 = "node_modules/svelte-feather-icons/src/icons/SunriseIcon.svelte";
function create_fragment233(ctx) {
  let svg;
  let path;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 18a5 5 0 0 0-10 0");
      add_location(path, file233, 13, 244, 528);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "9");
      add_location(line0, file233, 13, 283, 567);
      attr_dev(line1, "x1", "4.22");
      attr_dev(line1, "y1", "10.22");
      attr_dev(line1, "x2", "5.64");
      attr_dev(line1, "y2", "11.64");
      add_location(line1, file233, 13, 326, 610);
      attr_dev(line2, "x1", "1");
      attr_dev(line2, "y1", "18");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "18");
      add_location(line2, file233, 13, 381, 665);
      attr_dev(line3, "x1", "21");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "23");
      attr_dev(line3, "y2", "18");
      add_location(line3, file233, 13, 424, 708);
      attr_dev(line4, "x1", "18.36");
      attr_dev(line4, "y1", "11.64");
      attr_dev(line4, "x2", "19.78");
      attr_dev(line4, "y2", "10.22");
      add_location(line4, file233, 13, 469, 753);
      attr_dev(line5, "x1", "23");
      attr_dev(line5, "y1", "22");
      attr_dev(line5, "x2", "1");
      attr_dev(line5, "y2", "22");
      add_location(line5, file233, 13, 526, 810);
      attr_dev(polyline, "points", "8 6 12 2 16 6");
      add_location(polyline, file233, 13, 570, 854);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-sunrise " + /*customClass*/
      ctx[2]);
      add_location(svg, file233, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-sunrise " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment233.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance233($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SunriseIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SunriseIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SunriseIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance233, create_fragment233, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SunriseIcon",
      options,
      id: create_fragment233.name
    });
  }
  get size() {
    throw new Error("<SunriseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SunriseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SunriseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SunriseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SunriseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SunriseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SunriseIcon_default = SunriseIcon;

// node_modules/svelte-feather-icons/src/icons/SunsetIcon.svelte
var file234 = "node_modules/svelte-feather-icons/src/icons/SunsetIcon.svelte";
function create_fragment234(ctx) {
  let svg;
  let path;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line5).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 18a5 5 0 0 0-10 0");
      add_location(path, file234, 13, 243, 527);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "2");
      add_location(line0, file234, 13, 282, 566);
      attr_dev(line1, "x1", "4.22");
      attr_dev(line1, "y1", "10.22");
      attr_dev(line1, "x2", "5.64");
      attr_dev(line1, "y2", "11.64");
      add_location(line1, file234, 13, 325, 609);
      attr_dev(line2, "x1", "1");
      attr_dev(line2, "y1", "18");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "18");
      add_location(line2, file234, 13, 380, 664);
      attr_dev(line3, "x1", "21");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "23");
      attr_dev(line3, "y2", "18");
      add_location(line3, file234, 13, 423, 707);
      attr_dev(line4, "x1", "18.36");
      attr_dev(line4, "y1", "11.64");
      attr_dev(line4, "x2", "19.78");
      attr_dev(line4, "y2", "10.22");
      add_location(line4, file234, 13, 468, 752);
      attr_dev(line5, "x1", "23");
      attr_dev(line5, "y1", "22");
      attr_dev(line5, "x2", "1");
      attr_dev(line5, "y2", "22");
      add_location(line5, file234, 13, 525, 809);
      attr_dev(polyline, "points", "16 5 12 9 8 5");
      add_location(polyline, file234, 13, 569, 853);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-sunset " + /*customClass*/
      ctx[2]);
      add_location(svg, file234, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
      append_hydration_dev(svg, line3);
      append_hydration_dev(svg, line4);
      append_hydration_dev(svg, line5);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-sunset " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment234.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance234($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SunsetIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SunsetIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var SunsetIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance234, create_fragment234, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SunsetIcon",
      options,
      id: create_fragment234.name
    });
  }
  get size() {
    throw new Error("<SunsetIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SunsetIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SunsetIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SunsetIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SunsetIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SunsetIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SunsetIcon_default = SunsetIcon;

// node_modules/svelte-feather-icons/src/icons/TableIcon.svelte
var file235 = "node_modules/svelte-feather-icons/src/icons/TableIcon.svelte";
function create_fragment235(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18");
      add_location(path, file235, 13, 242, 526);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-table " + /*customClass*/
      ctx[2]);
      add_location(svg, file235, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-table " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment235.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance235($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TableIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TableIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance235, create_fragment235, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableIcon",
      options,
      id: create_fragment235.name
    });
  }
  get size() {
    throw new Error("<TableIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TableIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TableIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TableIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TableIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TableIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableIcon_default = TableIcon;

// node_modules/svelte-feather-icons/src/icons/TabletIcon.svelte
var file236 = "node_modules/svelte-feather-icons/src/icons/TabletIcon.svelte";
function create_fragment236(ctx) {
  let svg;
  let rect;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "4");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "16");
      attr_dev(rect, "height", "20");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file236, 13, 243, 527);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "18");
      attr_dev(line, "x2", "12.01");
      attr_dev(line, "y2", "18");
      add_location(line, file236, 13, 305, 589);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-tablet " + /*customClass*/
      ctx[2]);
      add_location(svg, file236, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-tablet " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment236.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance236($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabletIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TabletIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TabletIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance236, create_fragment236, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabletIcon",
      options,
      id: create_fragment236.name
    });
  }
  get size() {
    throw new Error("<TabletIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TabletIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TabletIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TabletIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TabletIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabletIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabletIcon_default = TabletIcon;

// node_modules/svelte-feather-icons/src/icons/TagIcon.svelte
var file237 = "node_modules/svelte-feather-icons/src/icons/TagIcon.svelte";
function create_fragment237(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z");
      add_location(path, file237, 13, 240, 524);
      attr_dev(line, "x1", "7");
      attr_dev(line, "y1", "7");
      attr_dev(line, "x2", "7.01");
      attr_dev(line, "y2", "7");
      add_location(line, file237, 13, 336, 620);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-tag " + /*customClass*/
      ctx[2]);
      add_location(svg, file237, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-tag " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment237.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance237($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TagIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TagIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TagIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance237, create_fragment237, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TagIcon",
      options,
      id: create_fragment237.name
    });
  }
  get size() {
    throw new Error("<TagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TagIcon_default = TagIcon;

// node_modules/svelte-feather-icons/src/icons/TargetIcon.svelte
var file238 = "node_modules/svelte-feather-icons/src/icons/TargetIcon.svelte";
function create_fragment238(ctx) {
  let svg;
  let circle0;
  let circle1;
  let circle2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      circle2 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "10");
      add_location(circle0, file238, 13, 243, 527);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "6");
      add_location(circle1, file238, 13, 283, 567);
      attr_dev(circle2, "cx", "12");
      attr_dev(circle2, "cy", "12");
      attr_dev(circle2, "r", "2");
      add_location(circle2, file238, 13, 322, 606);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-target " + /*customClass*/
      ctx[2]);
      add_location(svg, file238, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, circle2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-target " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment238.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance238($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TargetIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TargetIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TargetIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance238, create_fragment238, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TargetIcon",
      options,
      id: create_fragment238.name
    });
  }
  get size() {
    throw new Error("<TargetIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TargetIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TargetIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TargetIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TargetIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TargetIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TargetIcon_default = TargetIcon;

// node_modules/svelte-feather-icons/src/icons/TerminalIcon.svelte
var file239 = "node_modules/svelte-feather-icons/src/icons/TerminalIcon.svelte";
function create_fragment239(ctx) {
  let svg;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "4 17 10 11 4 5");
      add_location(polyline, file239, 13, 245, 529);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "19");
      attr_dev(line, "x2", "20");
      attr_dev(line, "y2", "19");
      add_location(line, file239, 13, 290, 574);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-terminal " + /*customClass*/
      ctx[2]);
      add_location(svg, file239, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-terminal " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment239.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance239($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TerminalIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TerminalIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TerminalIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance239, create_fragment239, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TerminalIcon",
      options,
      id: create_fragment239.name
    });
  }
  get size() {
    throw new Error("<TerminalIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TerminalIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TerminalIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TerminalIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TerminalIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TerminalIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TerminalIcon_default = TerminalIcon;

// node_modules/svelte-feather-icons/src/icons/ThermometerIcon.svelte
var file240 = "node_modules/svelte-feather-icons/src/icons/ThermometerIcon.svelte";
function create_fragment240(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z");
      add_location(path, file240, 13, 248, 532);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-thermometer " + /*customClass*/
      ctx[2]);
      add_location(svg, file240, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-thermometer " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment240.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance240($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ThermometerIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ThermometerIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ThermometerIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance240, create_fragment240, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ThermometerIcon",
      options,
      id: create_fragment240.name
    });
  }
  get size() {
    throw new Error("<ThermometerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ThermometerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ThermometerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ThermometerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ThermometerIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ThermometerIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ThermometerIcon_default = ThermometerIcon;

// node_modules/svelte-feather-icons/src/icons/ThumbsDownIcon.svelte
var file241 = "node_modules/svelte-feather-icons/src/icons/ThumbsDownIcon.svelte";
function create_fragment241(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17");
      add_location(path, file241, 13, 248, 532);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-thumbs-down " + /*customClass*/
      ctx[2]);
      add_location(svg, file241, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-thumbs-down " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment241.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance241($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ThumbsDownIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ThumbsDownIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ThumbsDownIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance241, create_fragment241, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ThumbsDownIcon",
      options,
      id: create_fragment241.name
    });
  }
  get size() {
    throw new Error("<ThumbsDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ThumbsDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ThumbsDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ThumbsDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ThumbsDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ThumbsDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ThumbsDownIcon_default = ThumbsDownIcon;

// node_modules/svelte-feather-icons/src/icons/ThumbsUpIcon.svelte
var file242 = "node_modules/svelte-feather-icons/src/icons/ThumbsUpIcon.svelte";
function create_fragment242(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3");
      add_location(path, file242, 13, 246, 530);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-thumbs-up " + /*customClass*/
      ctx[2]);
      add_location(svg, file242, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-thumbs-up " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment242.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance242($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ThumbsUpIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ThumbsUpIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ThumbsUpIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance242, create_fragment242, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ThumbsUpIcon",
      options,
      id: create_fragment242.name
    });
  }
  get size() {
    throw new Error("<ThumbsUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ThumbsUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ThumbsUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ThumbsUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ThumbsUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ThumbsUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ThumbsUpIcon_default = ThumbsUpIcon;

// node_modules/svelte-feather-icons/src/icons/ToggleLeftIcon.svelte
var file243 = "node_modules/svelte-feather-icons/src/icons/ToggleLeftIcon.svelte";
function create_fragment243(ctx) {
  let svg;
  let rect;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "5");
      attr_dev(rect, "width", "22");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "rx", "7");
      attr_dev(rect, "ry", "7");
      add_location(rect, file243, 13, 248, 532);
      attr_dev(circle, "cx", "8");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "3");
      add_location(circle, file243, 13, 310, 594);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-toggle-left " + /*customClass*/
      ctx[2]);
      add_location(svg, file243, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-toggle-left " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment243.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance243($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToggleLeftIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ToggleLeftIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ToggleLeftIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance243, create_fragment243, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToggleLeftIcon",
      options,
      id: create_fragment243.name
    });
  }
  get size() {
    throw new Error("<ToggleLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ToggleLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ToggleLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ToggleLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ToggleLeftIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ToggleLeftIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToggleLeftIcon_default = ToggleLeftIcon;

// node_modules/svelte-feather-icons/src/icons/ToggleRightIcon.svelte
var file244 = "node_modules/svelte-feather-icons/src/icons/ToggleRightIcon.svelte";
function create_fragment244(ctx) {
  let svg;
  let rect;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "5");
      attr_dev(rect, "width", "22");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "rx", "7");
      attr_dev(rect, "ry", "7");
      add_location(rect, file244, 13, 249, 533);
      attr_dev(circle, "cx", "16");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "3");
      add_location(circle, file244, 13, 311, 595);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-toggle-right " + /*customClass*/
      ctx[2]);
      add_location(svg, file244, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-toggle-right " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment244.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance244($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToggleRightIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ToggleRightIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ToggleRightIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance244, create_fragment244, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToggleRightIcon",
      options,
      id: create_fragment244.name
    });
  }
  get size() {
    throw new Error("<ToggleRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ToggleRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ToggleRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ToggleRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ToggleRightIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ToggleRightIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToggleRightIcon_default = ToggleRightIcon;

// node_modules/svelte-feather-icons/src/icons/ToolIcon.svelte
var file245 = "node_modules/svelte-feather-icons/src/icons/ToolIcon.svelte";
function create_fragment245(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z");
      add_location(path, file245, 13, 241, 525);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-tool " + /*customClass*/
      ctx[2]);
      add_location(svg, file245, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-tool " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment245.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance245($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ToolIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ToolIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance245, create_fragment245, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolIcon",
      options,
      id: create_fragment245.name
    });
  }
  get size() {
    throw new Error("<ToolIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ToolIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ToolIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ToolIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ToolIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ToolIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToolIcon_default = ToolIcon;

// node_modules/svelte-feather-icons/src/icons/Trash2Icon.svelte
var file246 = "node_modules/svelte-feather-icons/src/icons/Trash2Icon.svelte";
function create_fragment246(ctx) {
  let svg;
  let polyline;
  let path;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "3 6 5 6 21 6");
      add_location(polyline, file246, 13, 244, 528);
      attr_dev(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
      add_location(path, file246, 13, 287, 571);
      attr_dev(line0, "x1", "10");
      attr_dev(line0, "y1", "11");
      attr_dev(line0, "x2", "10");
      attr_dev(line0, "y2", "17");
      add_location(line0, file246, 13, 383, 667);
      attr_dev(line1, "x1", "14");
      attr_dev(line1, "y1", "11");
      attr_dev(line1, "x2", "14");
      attr_dev(line1, "y2", "17");
      add_location(line1, file246, 13, 428, 712);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-trash-2 " + /*customClass*/
      ctx[2]);
      add_location(svg, file246, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-trash-2 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment246.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance246($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Trash2Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Trash2Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var Trash2Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance246, create_fragment246, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trash2Icon",
      options,
      id: create_fragment246.name
    });
  }
  get size() {
    throw new Error("<Trash2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Trash2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Trash2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Trash2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Trash2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Trash2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Trash2Icon_default = Trash2Icon;

// node_modules/svelte-feather-icons/src/icons/TrashIcon.svelte
var file247 = "node_modules/svelte-feather-icons/src/icons/TrashIcon.svelte";
function create_fragment247(ctx) {
  let svg;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "3 6 5 6 21 6");
      add_location(polyline, file247, 13, 242, 526);
      attr_dev(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
      add_location(path, file247, 13, 285, 569);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-trash " + /*customClass*/
      ctx[2]);
      add_location(svg, file247, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-trash " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment247.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance247($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TrashIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TrashIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TrashIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance247, create_fragment247, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrashIcon",
      options,
      id: create_fragment247.name
    });
  }
  get size() {
    throw new Error("<TrashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TrashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TrashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TrashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TrashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TrashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TrashIcon_default = TrashIcon;

// node_modules/svelte-feather-icons/src/icons/TrelloIcon.svelte
var file248 = "node_modules/svelte-feather-icons/src/icons/TrelloIcon.svelte";
function create_fragment248(ctx) {
  let svg;
  let rect0;
  let rect1;
  let rect2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      rect2 = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect0 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect0).forEach(detach_dev);
      rect1 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect1).forEach(detach_dev);
      rect2 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect0, "x", "3");
      attr_dev(rect0, "y", "3");
      attr_dev(rect0, "width", "18");
      attr_dev(rect0, "height", "18");
      attr_dev(rect0, "rx", "2");
      attr_dev(rect0, "ry", "2");
      add_location(rect0, file248, 13, 243, 527);
      attr_dev(rect1, "x", "7");
      attr_dev(rect1, "y", "7");
      attr_dev(rect1, "width", "3");
      attr_dev(rect1, "height", "9");
      add_location(rect1, file248, 13, 305, 589);
      attr_dev(rect2, "x", "14");
      attr_dev(rect2, "y", "7");
      attr_dev(rect2, "width", "3");
      attr_dev(rect2, "height", "5");
      add_location(rect2, file248, 13, 351, 635);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-trello " + /*customClass*/
      ctx[2]);
      add_location(svg, file248, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect0);
      append_hydration_dev(svg, rect1);
      append_hydration_dev(svg, rect2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-trello " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment248.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance248($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TrelloIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TrelloIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TrelloIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance248, create_fragment248, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrelloIcon",
      options,
      id: create_fragment248.name
    });
  }
  get size() {
    throw new Error("<TrelloIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TrelloIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TrelloIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TrelloIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TrelloIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TrelloIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TrelloIcon_default = TrelloIcon;

// node_modules/svelte-feather-icons/src/icons/TrendingDownIcon.svelte
var file249 = "node_modules/svelte-feather-icons/src/icons/TrendingDownIcon.svelte";
function create_fragment249(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "23 18 13.5 8.5 8.5 13.5 1 6");
      add_location(polyline0, file249, 13, 250, 534);
      attr_dev(polyline1, "points", "17 18 23 18 23 12");
      add_location(polyline1, file249, 13, 308, 592);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-trending-down " + /*customClass*/
      ctx[2]);
      add_location(svg, file249, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-trending-down " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment249.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance249($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TrendingDownIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TrendingDownIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TrendingDownIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance249, create_fragment249, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrendingDownIcon",
      options,
      id: create_fragment249.name
    });
  }
  get size() {
    throw new Error("<TrendingDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TrendingDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TrendingDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TrendingDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TrendingDownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TrendingDownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TrendingDownIcon_default = TrendingDownIcon;

// node_modules/svelte-feather-icons/src/icons/TrendingUpIcon.svelte
var file250 = "node_modules/svelte-feather-icons/src/icons/TrendingUpIcon.svelte";
function create_fragment250(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "23 6 13.5 15.5 8.5 10.5 1 18");
      add_location(polyline0, file250, 13, 248, 532);
      attr_dev(polyline1, "points", "17 6 23 6 23 12");
      add_location(polyline1, file250, 13, 307, 591);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-trending-up " + /*customClass*/
      ctx[2]);
      add_location(svg, file250, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-trending-up " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment250.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance250($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TrendingUpIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TrendingUpIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TrendingUpIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance250, create_fragment250, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrendingUpIcon",
      options,
      id: create_fragment250.name
    });
  }
  get size() {
    throw new Error("<TrendingUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TrendingUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TrendingUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TrendingUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TrendingUpIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TrendingUpIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TrendingUpIcon_default = TrendingUpIcon;

// node_modules/svelte-feather-icons/src/icons/TriangleIcon.svelte
var file251 = "node_modules/svelte-feather-icons/src/icons/TriangleIcon.svelte";
function create_fragment251(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z");
      add_location(path, file251, 13, 245, 529);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-triangle " + /*customClass*/
      ctx[2]);
      add_location(svg, file251, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-triangle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment251.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance251($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TriangleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TriangleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TriangleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance251, create_fragment251, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TriangleIcon",
      options,
      id: create_fragment251.name
    });
  }
  get size() {
    throw new Error("<TriangleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TriangleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TriangleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TriangleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TriangleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TriangleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TriangleIcon_default = TriangleIcon;

// node_modules/svelte-feather-icons/src/icons/TruckIcon.svelte
var file252 = "node_modules/svelte-feather-icons/src/icons/TruckIcon.svelte";
function create_fragment252(ctx) {
  let svg;
  let rect;
  let polygon;
  let circle0;
  let circle1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      polygon = svg_element("polygon");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "15");
      attr_dev(rect, "height", "13");
      add_location(rect, file252, 13, 242, 526);
      attr_dev(polygon, "points", "16 8 20 8 23 11 23 16 16 16 16 8");
      add_location(polygon, file252, 13, 290, 574);
      attr_dev(circle0, "cx", "5.5");
      attr_dev(circle0, "cy", "18.5");
      attr_dev(circle0, "r", "2.5");
      add_location(circle0, file252, 13, 351, 635);
      attr_dev(circle1, "cx", "18.5");
      attr_dev(circle1, "cy", "18.5");
      attr_dev(circle1, "r", "2.5");
      add_location(circle1, file252, 13, 395, 679);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-truck " + /*customClass*/
      ctx[2]);
      add_location(svg, file252, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-truck " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment252.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance252($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TruckIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TruckIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TruckIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance252, create_fragment252, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TruckIcon",
      options,
      id: create_fragment252.name
    });
  }
  get size() {
    throw new Error("<TruckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TruckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TruckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TruckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TruckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TruckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TruckIcon_default = TruckIcon;

// node_modules/svelte-feather-icons/src/icons/TvIcon.svelte
var file253 = "node_modules/svelte-feather-icons/src/icons/TvIcon.svelte";
function create_fragment253(ctx) {
  let svg;
  let rect;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "7");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "15");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file253, 13, 239, 523);
      attr_dev(polyline, "points", "17 2 12 7 7 2");
      add_location(polyline, file253, 13, 301, 585);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-tv " + /*customClass*/
      ctx[2]);
      add_location(svg, file253, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-tv " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment253.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance253($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TvIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TvIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TvIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance253, create_fragment253, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TvIcon",
      options,
      id: create_fragment253.name
    });
  }
  get size() {
    throw new Error("<TvIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TvIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TvIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TvIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TvIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TvIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TvIcon_default = TvIcon;

// node_modules/svelte-feather-icons/src/icons/TwitchIcon.svelte
var file254 = "node_modules/svelte-feather-icons/src/icons/TwitchIcon.svelte";
function create_fragment254(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7");
      add_location(path, file254, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-twitch " + /*customClass*/
      ctx[2]);
      add_location(svg, file254, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-twitch " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment254.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance254($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TwitchIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TwitchIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TwitchIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance254, create_fragment254, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TwitchIcon",
      options,
      id: create_fragment254.name
    });
  }
  get size() {
    throw new Error("<TwitchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TwitchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TwitchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TwitchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TwitchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TwitchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TwitchIcon_default = TwitchIcon;

// node_modules/svelte-feather-icons/src/icons/TwitterIcon.svelte
var file255 = "node_modules/svelte-feather-icons/src/icons/TwitterIcon.svelte";
function create_fragment255(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z");
      add_location(path, file255, 13, 244, 528);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-twitter " + /*customClass*/
      ctx[2]);
      add_location(svg, file255, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-twitter " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment255.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance255($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TwitterIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TwitterIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TwitterIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance255, create_fragment255, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TwitterIcon",
      options,
      id: create_fragment255.name
    });
  }
  get size() {
    throw new Error("<TwitterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TwitterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TwitterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TwitterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TwitterIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TwitterIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TwitterIcon_default = TwitterIcon;

// node_modules/svelte-feather-icons/src/icons/TypeIcon.svelte
var file256 = "node_modules/svelte-feather-icons/src/icons/TypeIcon.svelte";
function create_fragment256(ctx) {
  let svg;
  let polyline;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "4 7 4 4 20 4 20 7");
      add_location(polyline, file256, 13, 241, 525);
      attr_dev(line0, "x1", "9");
      attr_dev(line0, "y1", "20");
      attr_dev(line0, "x2", "15");
      attr_dev(line0, "y2", "20");
      add_location(line0, file256, 13, 289, 573);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "4");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "20");
      add_location(line1, file256, 13, 333, 617);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-type " + /*customClass*/
      ctx[2]);
      add_location(svg, file256, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-type " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment256.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance256($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TypeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TypeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var TypeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance256, create_fragment256, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TypeIcon",
      options,
      id: create_fragment256.name
    });
  }
  get size() {
    throw new Error("<TypeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TypeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<TypeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<TypeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TypeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TypeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TypeIcon_default = TypeIcon;

// node_modules/svelte-feather-icons/src/icons/UmbrellaIcon.svelte
var file257 = "node_modules/svelte-feather-icons/src/icons/UmbrellaIcon.svelte";
function create_fragment257(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7");
      add_location(path, file257, 13, 245, 529);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-umbrella " + /*customClass*/
      ctx[2]);
      add_location(svg, file257, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-umbrella " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment257.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance257($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UmbrellaIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UmbrellaIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UmbrellaIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance257, create_fragment257, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UmbrellaIcon",
      options,
      id: create_fragment257.name
    });
  }
  get size() {
    throw new Error("<UmbrellaIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UmbrellaIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UmbrellaIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UmbrellaIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UmbrellaIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UmbrellaIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UmbrellaIcon_default = UmbrellaIcon;

// node_modules/svelte-feather-icons/src/icons/UnderlineIcon.svelte
var file258 = "node_modules/svelte-feather-icons/src/icons/UnderlineIcon.svelte";
function create_fragment258(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3");
      add_location(path, file258, 13, 246, 530);
      attr_dev(line, "x1", "4");
      attr_dev(line, "y1", "21");
      attr_dev(line, "x2", "20");
      attr_dev(line, "y2", "21");
      add_location(line, file258, 13, 300, 584);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-underline " + /*customClass*/
      ctx[2]);
      add_location(svg, file258, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-underline " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment258.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance258($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UnderlineIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UnderlineIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UnderlineIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance258, create_fragment258, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UnderlineIcon",
      options,
      id: create_fragment258.name
    });
  }
  get size() {
    throw new Error("<UnderlineIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UnderlineIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UnderlineIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UnderlineIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UnderlineIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UnderlineIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UnderlineIcon_default = UnderlineIcon;

// node_modules/svelte-feather-icons/src/icons/UnlockIcon.svelte
var file259 = "node_modules/svelte-feather-icons/src/icons/UnlockIcon.svelte";
function create_fragment259(ctx) {
  let svg;
  let rect;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "11");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "11");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file259, 13, 243, 527);
      attr_dev(path, "d", "M7 11V7a5 5 0 0 1 9.9-1");
      add_location(path, file259, 13, 306, 590);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-unlock " + /*customClass*/
      ctx[2]);
      add_location(svg, file259, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-unlock " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment259.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance259($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UnlockIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UnlockIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UnlockIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance259, create_fragment259, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UnlockIcon",
      options,
      id: create_fragment259.name
    });
  }
  get size() {
    throw new Error("<UnlockIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UnlockIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UnlockIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UnlockIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UnlockIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UnlockIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UnlockIcon_default = UnlockIcon;

// node_modules/svelte-feather-icons/src/icons/UploadCloudIcon.svelte
var file260 = "node_modules/svelte-feather-icons/src/icons/UploadCloudIcon.svelte";
function create_fragment260(ctx) {
  let svg;
  let polyline0;
  let line;
  let path;
  let polyline1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      line = svg_element("line");
      path = svg_element("path");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "16 16 12 12 8 16");
      add_location(polyline0, file260, 13, 249, 533);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "21");
      add_location(line, file260, 13, 296, 580);
      attr_dev(path, "d", "M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3");
      add_location(path, file260, 13, 341, 625);
      attr_dev(polyline1, "points", "16 16 12 12 8 16");
      add_location(polyline1, file260, 13, 409, 693);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-upload-cloud " + /*customClass*/
      ctx[2]);
      add_location(svg, file260, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, line);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-upload-cloud " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment260.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance260($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UploadCloudIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UploadCloudIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UploadCloudIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance260, create_fragment260, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UploadCloudIcon",
      options,
      id: create_fragment260.name
    });
  }
  get size() {
    throw new Error("<UploadCloudIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UploadCloudIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UploadCloudIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UploadCloudIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UploadCloudIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UploadCloudIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UploadCloudIcon_default = UploadCloudIcon;

// node_modules/svelte-feather-icons/src/icons/UploadIcon.svelte
var file261 = "node_modules/svelte-feather-icons/src/icons/UploadIcon.svelte";
function create_fragment261(ctx) {
  let svg;
  let path;
  let polyline;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
      add_location(path, file261, 13, 243, 527);
      attr_dev(polyline, "points", "17 8 12 3 7 8");
      add_location(polyline, file261, 13, 302, 586);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "3");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "15");
      add_location(line, file261, 13, 346, 630);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-upload " + /*customClass*/
      ctx[2]);
      add_location(svg, file261, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-upload " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment261.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance261($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UploadIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UploadIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UploadIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance261, create_fragment261, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UploadIcon",
      options,
      id: create_fragment261.name
    });
  }
  get size() {
    throw new Error("<UploadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UploadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UploadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UploadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UploadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UploadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UploadIcon_default = UploadIcon;

// node_modules/svelte-feather-icons/src/icons/UserCheckIcon.svelte
var file262 = "node_modules/svelte-feather-icons/src/icons/UserCheckIcon.svelte";
function create_fragment262(ctx) {
  let svg;
  let path;
  let circle;
  let polyline;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
      add_location(path, file262, 13, 247, 531);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file262, 13, 306, 590);
      attr_dev(polyline, "points", "17 11 19 13 23 9");
      add_location(polyline, file262, 13, 345, 629);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-user-check " + /*customClass*/
      ctx[2]);
      add_location(svg, file262, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polyline);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-user-check " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment262.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance262($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UserCheckIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UserCheckIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UserCheckIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance262, create_fragment262, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserCheckIcon",
      options,
      id: create_fragment262.name
    });
  }
  get size() {
    throw new Error("<UserCheckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UserCheckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UserCheckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UserCheckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UserCheckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UserCheckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UserCheckIcon_default = UserCheckIcon;

// node_modules/svelte-feather-icons/src/icons/UserMinusIcon.svelte
var file263 = "node_modules/svelte-feather-icons/src/icons/UserMinusIcon.svelte";
function create_fragment263(ctx) {
  let svg;
  let path;
  let circle;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      circle = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
      add_location(path, file263, 13, 247, 531);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file263, 13, 306, 590);
      attr_dev(line, "x1", "23");
      attr_dev(line, "y1", "11");
      attr_dev(line, "x2", "17");
      attr_dev(line, "y2", "11");
      add_location(line, file263, 13, 345, 629);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-user-minus " + /*customClass*/
      ctx[2]);
      add_location(svg, file263, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-user-minus " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment263.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance263($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UserMinusIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UserMinusIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UserMinusIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance263, create_fragment263, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserMinusIcon",
      options,
      id: create_fragment263.name
    });
  }
  get size() {
    throw new Error("<UserMinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UserMinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UserMinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UserMinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UserMinusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UserMinusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UserMinusIcon_default = UserMinusIcon;

// node_modules/svelte-feather-icons/src/icons/UserPlusIcon.svelte
var file264 = "node_modules/svelte-feather-icons/src/icons/UserPlusIcon.svelte";
function create_fragment264(ctx) {
  let svg;
  let path;
  let circle;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
      add_location(path, file264, 13, 246, 530);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file264, 13, 305, 589);
      attr_dev(line0, "x1", "20");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "20");
      attr_dev(line0, "y2", "14");
      add_location(line0, file264, 13, 344, 628);
      attr_dev(line1, "x1", "23");
      attr_dev(line1, "y1", "11");
      attr_dev(line1, "x2", "17");
      attr_dev(line1, "y2", "11");
      add_location(line1, file264, 13, 388, 672);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-user-plus " + /*customClass*/
      ctx[2]);
      add_location(svg, file264, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-user-plus " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment264.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance264($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UserPlusIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UserPlusIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UserPlusIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance264, create_fragment264, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserPlusIcon",
      options,
      id: create_fragment264.name
    });
  }
  get size() {
    throw new Error("<UserPlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UserPlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UserPlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UserPlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UserPlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UserPlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UserPlusIcon_default = UserPlusIcon;

// node_modules/svelte-feather-icons/src/icons/UserXIcon.svelte
var file265 = "node_modules/svelte-feather-icons/src/icons/UserXIcon.svelte";
function create_fragment265(ctx) {
  let svg;
  let path;
  let circle;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
      add_location(path, file265, 13, 243, 527);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file265, 13, 302, 586);
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "23");
      attr_dev(line0, "y2", "13");
      add_location(line0, file265, 13, 341, 625);
      attr_dev(line1, "x1", "23");
      attr_dev(line1, "y1", "8");
      attr_dev(line1, "x2", "18");
      attr_dev(line1, "y2", "13");
      add_location(line1, file265, 13, 385, 669);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-user-x " + /*customClass*/
      ctx[2]);
      add_location(svg, file265, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-user-x " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment265.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance265($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UserXIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UserXIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UserXIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance265, create_fragment265, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserXIcon",
      options,
      id: create_fragment265.name
    });
  }
  get size() {
    throw new Error("<UserXIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UserXIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UserXIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UserXIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UserXIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UserXIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UserXIcon_default = UserXIcon;

// node_modules/svelte-feather-icons/src/icons/UserIcon.svelte
var file266 = "node_modules/svelte-feather-icons/src/icons/UserIcon.svelte";
function create_fragment266(ctx) {
  let svg;
  let path;
  let circle;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2");
      add_location(path, file266, 13, 241, 525);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file266, 13, 300, 584);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-user " + /*customClass*/
      ctx[2]);
      add_location(svg, file266, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, circle);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-user " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment266.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance266($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UserIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UserIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UserIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance266, create_fragment266, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserIcon",
      options,
      id: create_fragment266.name
    });
  }
  get size() {
    throw new Error("<UserIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UserIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UserIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UserIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UserIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UserIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UserIcon_default = UserIcon;

// node_modules/svelte-feather-icons/src/icons/UsersIcon.svelte
var file267 = "node_modules/svelte-feather-icons/src/icons/UsersIcon.svelte";
function create_fragment267(ctx) {
  let svg;
  let path0;
  let circle;
  let path1;
  let path2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      circle = svg_element("circle");
      path1 = svg_element("path");
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
      add_location(path0, file267, 13, 242, 526);
      attr_dev(circle, "cx", "9");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file267, 13, 301, 585);
      attr_dev(path1, "d", "M23 21v-2a4 4 0 0 0-3-3.87");
      add_location(path1, file267, 13, 338, 622);
      attr_dev(path2, "d", "M16 3.13a4 4 0 0 1 0 7.75");
      add_location(path2, file267, 13, 382, 666);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-users " + /*customClass*/
      ctx[2]);
      add_location(svg, file267, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-users " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment267.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance267($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UsersIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UsersIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var UsersIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance267, create_fragment267, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UsersIcon",
      options,
      id: create_fragment267.name
    });
  }
  get size() {
    throw new Error("<UsersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<UsersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<UsersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<UsersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UsersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UsersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UsersIcon_default = UsersIcon;

// node_modules/svelte-feather-icons/src/icons/VideoOffIcon.svelte
var file268 = "node_modules/svelte-feather-icons/src/icons/VideoOffIcon.svelte";
function create_fragment268(ctx) {
  let svg;
  let path;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10");
      add_location(path, file268, 13, 246, 530);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file268, 13, 361, 645);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-video-off " + /*customClass*/
      ctx[2]);
      add_location(svg, file268, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-video-off " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment268.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance268($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VideoOffIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VideoOffIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var VideoOffIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance268, create_fragment268, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VideoOffIcon",
      options,
      id: create_fragment268.name
    });
  }
  get size() {
    throw new Error("<VideoOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<VideoOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<VideoOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<VideoOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<VideoOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<VideoOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VideoOffIcon_default = VideoOffIcon;

// node_modules/svelte-feather-icons/src/icons/VideoIcon.svelte
var file269 = "node_modules/svelte-feather-icons/src/icons/VideoIcon.svelte";
function create_fragment269(ctx) {
  let svg;
  let polygon;
  let rect;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "23 7 16 12 23 17 23 7");
      add_location(polygon, file269, 13, 242, 526);
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "5");
      attr_dev(rect, "width", "15");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file269, 13, 292, 576);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-video " + /*customClass*/
      ctx[2]);
      add_location(svg, file269, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, rect);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-video " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment269.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance269($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VideoIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VideoIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var VideoIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance269, create_fragment269, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VideoIcon",
      options,
      id: create_fragment269.name
    });
  }
  get size() {
    throw new Error("<VideoIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<VideoIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<VideoIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<VideoIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<VideoIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<VideoIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VideoIcon_default = VideoIcon;

// node_modules/svelte-feather-icons/src/icons/VoicemailIcon.svelte
var file270 = "node_modules/svelte-feather-icons/src/icons/VoicemailIcon.svelte";
function create_fragment270(ctx) {
  let svg;
  let circle0;
  let circle1;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle1).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "5.5");
      attr_dev(circle0, "cy", "11.5");
      attr_dev(circle0, "r", "4.5");
      add_location(circle0, file270, 13, 246, 530);
      attr_dev(circle1, "cx", "18.5");
      attr_dev(circle1, "cy", "11.5");
      attr_dev(circle1, "r", "4.5");
      add_location(circle1, file270, 13, 290, 574);
      attr_dev(line, "x1", "5.5");
      attr_dev(line, "y1", "16");
      attr_dev(line, "x2", "18.5");
      attr_dev(line, "y2", "16");
      add_location(line, file270, 13, 335, 619);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-voicemail " + /*customClass*/
      ctx[2]);
      add_location(svg, file270, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-voicemail " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment270.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance270($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VoicemailIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VoicemailIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var VoicemailIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance270, create_fragment270, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VoicemailIcon",
      options,
      id: create_fragment270.name
    });
  }
  get size() {
    throw new Error("<VoicemailIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<VoicemailIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<VoicemailIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<VoicemailIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<VoicemailIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<VoicemailIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VoicemailIcon_default = VoicemailIcon;

// node_modules/svelte-feather-icons/src/icons/Volume1Icon.svelte
var file271 = "node_modules/svelte-feather-icons/src/icons/Volume1Icon.svelte";
function create_fragment271(ctx) {
  let svg;
  let polygon;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
      add_location(polygon, file271, 13, 245, 529);
      attr_dev(path, "d", "M15.54 8.46a5 5 0 0 1 0 7.07");
      add_location(path, file271, 13, 307, 591);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-volume-1 " + /*customClass*/
      ctx[2]);
      add_location(svg, file271, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-volume-1 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment271.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance271($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Volume1Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Volume1Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var Volume1Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance271, create_fragment271, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Volume1Icon",
      options,
      id: create_fragment271.name
    });
  }
  get size() {
    throw new Error("<Volume1Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Volume1Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Volume1Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Volume1Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Volume1Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Volume1Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Volume1Icon_default = Volume1Icon;

// node_modules/svelte-feather-icons/src/icons/Volume2Icon.svelte
var file272 = "node_modules/svelte-feather-icons/src/icons/Volume2Icon.svelte";
function create_fragment272(ctx) {
  let svg;
  let polygon;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
      add_location(polygon, file272, 13, 245, 529);
      attr_dev(path, "d", "M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07");
      add_location(path, file272, 13, 307, 591);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-volume-2 " + /*customClass*/
      ctx[2]);
      add_location(svg, file272, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-volume-2 " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment272.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance272($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Volume2Icon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Volume2Icon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var Volume2Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance272, create_fragment272, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Volume2Icon",
      options,
      id: create_fragment272.name
    });
  }
  get size() {
    throw new Error("<Volume2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Volume2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Volume2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Volume2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Volume2Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Volume2Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Volume2Icon_default = Volume2Icon;

// node_modules/svelte-feather-icons/src/icons/VolumeXIcon.svelte
var file273 = "node_modules/svelte-feather-icons/src/icons/VolumeXIcon.svelte";
function create_fragment273(ctx) {
  let svg;
  let polygon;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
      add_location(polygon, file273, 13, 245, 529);
      attr_dev(line0, "x1", "23");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "17");
      attr_dev(line0, "y2", "15");
      add_location(line0, file273, 13, 307, 591);
      attr_dev(line1, "x1", "17");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "23");
      attr_dev(line1, "y2", "15");
      add_location(line1, file273, 13, 351, 635);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-volume-x " + /*customClass*/
      ctx[2]);
      add_location(svg, file273, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-volume-x " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment273.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance273($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VolumeXIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VolumeXIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var VolumeXIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance273, create_fragment273, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VolumeXIcon",
      options,
      id: create_fragment273.name
    });
  }
  get size() {
    throw new Error("<VolumeXIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<VolumeXIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<VolumeXIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<VolumeXIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<VolumeXIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<VolumeXIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VolumeXIcon_default = VolumeXIcon;

// node_modules/svelte-feather-icons/src/icons/VolumeIcon.svelte
var file274 = "node_modules/svelte-feather-icons/src/icons/VolumeIcon.svelte";
function create_fragment274(ctx) {
  let svg;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
      add_location(polygon, file274, 13, 243, 527);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-volume " + /*customClass*/
      ctx[2]);
      add_location(svg, file274, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-volume " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment274.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance274($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VolumeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VolumeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var VolumeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance274, create_fragment274, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VolumeIcon",
      options,
      id: create_fragment274.name
    });
  }
  get size() {
    throw new Error("<VolumeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<VolumeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<VolumeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<VolumeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<VolumeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<VolumeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VolumeIcon_default = VolumeIcon;

// node_modules/svelte-feather-icons/src/icons/WatchIcon.svelte
var file275 = "node_modules/svelte-feather-icons/src/icons/WatchIcon.svelte";
function create_fragment275(ctx) {
  let svg;
  let circle;
  let polyline;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "7");
      add_location(circle, file275, 13, 242, 526);
      attr_dev(polyline, "points", "12 9 12 12 13.5 13.5");
      add_location(polyline, file275, 13, 281, 565);
      attr_dev(path, "d", "M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83");
      add_location(path, file275, 13, 332, 616);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-watch " + /*customClass*/
      ctx[2]);
      add_location(svg, file275, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, polyline);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-watch " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment275.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance275($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WatchIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<WatchIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var WatchIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance275, create_fragment275, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WatchIcon",
      options,
      id: create_fragment275.name
    });
  }
  get size() {
    throw new Error("<WatchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<WatchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<WatchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<WatchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<WatchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<WatchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WatchIcon_default = WatchIcon;

// node_modules/svelte-feather-icons/src/icons/WifiOffIcon.svelte
var file276 = "node_modules/svelte-feather-icons/src/icons/WifiOffIcon.svelte";
function create_fragment276(ctx) {
  let svg;
  let line0;
  let path0;
  let path1;
  let path2;
  let path3;
  let path4;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path3).forEach(detach_dev);
      path4 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path4).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "1");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "23");
      attr_dev(line0, "y2", "23");
      add_location(line0, file276, 13, 245, 529);
      attr_dev(path0, "d", "M16.72 11.06A10.94 10.94 0 0 1 19 12.55");
      add_location(path0, file276, 13, 288, 572);
      attr_dev(path1, "d", "M5 12.55a10.94 10.94 0 0 1 5.17-2.39");
      add_location(path1, file276, 13, 345, 629);
      attr_dev(path2, "d", "M10.71 5.05A16 16 0 0 1 22.58 9");
      add_location(path2, file276, 13, 399, 683);
      attr_dev(path3, "d", "M1.42 9a15.91 15.91 0 0 1 4.7-2.88");
      add_location(path3, file276, 13, 448, 732);
      attr_dev(path4, "d", "M8.53 16.11a6 6 0 0 1 6.95 0");
      add_location(path4, file276, 13, 500, 784);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "20");
      attr_dev(line1, "x2", "12.01");
      attr_dev(line1, "y2", "20");
      add_location(line1, file276, 13, 546, 830);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-wifi-off " + /*customClass*/
      ctx[2]);
      add_location(svg, file276, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, path3);
      append_hydration_dev(svg, path4);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-wifi-off " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment276.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance276($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WifiOffIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<WifiOffIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var WifiOffIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance276, create_fragment276, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WifiOffIcon",
      options,
      id: create_fragment276.name
    });
  }
  get size() {
    throw new Error("<WifiOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<WifiOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<WifiOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<WifiOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<WifiOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<WifiOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WifiOffIcon_default = WifiOffIcon;

// node_modules/svelte-feather-icons/src/icons/WifiIcon.svelte
var file277 = "node_modules/svelte-feather-icons/src/icons/WifiIcon.svelte";
function create_fragment277(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M5 12.55a11 11 0 0 1 14.08 0");
      add_location(path0, file277, 13, 241, 525);
      attr_dev(path1, "d", "M1.42 9a16 16 0 0 1 21.16 0");
      add_location(path1, file277, 13, 287, 571);
      attr_dev(path2, "d", "M8.53 16.11a6 6 0 0 1 6.95 0");
      add_location(path2, file277, 13, 332, 616);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "20");
      attr_dev(line, "x2", "12.01");
      attr_dev(line, "y2", "20");
      add_location(line, file277, 13, 378, 662);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-wifi " + /*customClass*/
      ctx[2]);
      add_location(svg, file277, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-wifi " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment277.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance277($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WifiIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<WifiIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var WifiIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance277, create_fragment277, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WifiIcon",
      options,
      id: create_fragment277.name
    });
  }
  get size() {
    throw new Error("<WifiIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<WifiIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<WifiIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<WifiIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<WifiIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<WifiIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WifiIcon_default = WifiIcon;

// node_modules/svelte-feather-icons/src/icons/WindIcon.svelte
var file278 = "node_modules/svelte-feather-icons/src/icons/WindIcon.svelte";
function create_fragment278(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2");
      add_location(path, file278, 13, 241, 525);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-wind " + /*customClass*/
      ctx[2]);
      add_location(svg, file278, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-wind " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment278.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance278($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WindIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<WindIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var WindIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance278, create_fragment278, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WindIcon",
      options,
      id: create_fragment278.name
    });
  }
  get size() {
    throw new Error("<WindIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<WindIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<WindIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<WindIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<WindIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<WindIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WindIcon_default = WindIcon;

// node_modules/svelte-feather-icons/src/icons/XCircleIcon.svelte
var file279 = "node_modules/svelte-feather-icons/src/icons/XCircleIcon.svelte";
function create_fragment279(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file279, 13, 245, 529);
      attr_dev(line0, "x1", "15");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "9");
      attr_dev(line0, "y2", "15");
      add_location(line0, file279, 13, 285, 569);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "15");
      attr_dev(line1, "y2", "15");
      add_location(line1, file279, 13, 328, 612);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-x-circle " + /*customClass*/
      ctx[2]);
      add_location(svg, file279, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-x-circle " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment279.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance279($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XCircleIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XCircleIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var XCircleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance279, create_fragment279, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XCircleIcon",
      options,
      id: create_fragment279.name
    });
  }
  get size() {
    throw new Error("<XCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<XCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<XCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<XCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<XCircleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<XCircleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var XCircleIcon_default = XCircleIcon;

// node_modules/svelte-feather-icons/src/icons/XOctagonIcon.svelte
var file280 = "node_modules/svelte-feather-icons/src/icons/XOctagonIcon.svelte";
function create_fragment280(ctx) {
  let svg;
  let polygon;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
      add_location(polygon, file280, 13, 246, 530);
      attr_dev(line0, "x1", "15");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "9");
      attr_dev(line0, "y2", "15");
      add_location(line0, file280, 13, 345, 629);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "15");
      attr_dev(line1, "y2", "15");
      add_location(line1, file280, 13, 388, 672);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-x-octagon " + /*customClass*/
      ctx[2]);
      add_location(svg, file280, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-x-octagon " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment280.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance280($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XOctagonIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XOctagonIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var XOctagonIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance280, create_fragment280, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XOctagonIcon",
      options,
      id: create_fragment280.name
    });
  }
  get size() {
    throw new Error("<XOctagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<XOctagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<XOctagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<XOctagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<XOctagonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<XOctagonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var XOctagonIcon_default = XOctagonIcon;

// node_modules/svelte-feather-icons/src/icons/XSquareIcon.svelte
var file281 = "node_modules/svelte-feather-icons/src/icons/XSquareIcon.svelte";
function create_fragment281(ctx) {
  let svg;
  let rect;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file281, 13, 245, 529);
      attr_dev(line0, "x1", "9");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "15");
      attr_dev(line0, "y2", "15");
      add_location(line0, file281, 13, 307, 591);
      attr_dev(line1, "x1", "15");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "9");
      attr_dev(line1, "y2", "15");
      add_location(line1, file281, 13, 350, 634);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-x-square " + /*customClass*/
      ctx[2]);
      add_location(svg, file281, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-x-square " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment281.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance281($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XSquareIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XSquareIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var XSquareIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance281, create_fragment281, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XSquareIcon",
      options,
      id: create_fragment281.name
    });
  }
  get size() {
    throw new Error("<XSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<XSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<XSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<XSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<XSquareIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<XSquareIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var XSquareIcon_default = XSquareIcon;

// node_modules/svelte-feather-icons/src/icons/XIcon.svelte
var file282 = "node_modules/svelte-feather-icons/src/icons/XIcon.svelte";
function create_fragment282(ctx) {
  let svg;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "6");
      attr_dev(line0, "x2", "6");
      attr_dev(line0, "y2", "18");
      add_location(line0, file282, 13, 238, 522);
      attr_dev(line1, "x1", "6");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "18");
      attr_dev(line1, "y2", "18");
      add_location(line1, file282, 13, 281, 565);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-x " + /*customClass*/
      ctx[2]);
      add_location(svg, file282, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-x " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment282.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance282($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var XIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance282, create_fragment282, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XIcon",
      options,
      id: create_fragment282.name
    });
  }
  get size() {
    throw new Error("<XIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<XIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<XIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<XIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<XIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<XIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var XIcon_default = XIcon;

// node_modules/svelte-feather-icons/src/icons/YoutubeIcon.svelte
var file283 = "node_modules/svelte-feather-icons/src/icons/YoutubeIcon.svelte";
function create_fragment283(ctx) {
  let svg;
  let path;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z");
      add_location(path, file283, 13, 244, 528);
      attr_dev(polygon, "points", "9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02");
      add_location(polygon, file283, 13, 519, 803);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-youtube " + /*customClass*/
      ctx[2]);
      add_location(svg, file283, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-youtube " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment283.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance283($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("YoutubeIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<YoutubeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var YoutubeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance283, create_fragment283, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "YoutubeIcon",
      options,
      id: create_fragment283.name
    });
  }
  get size() {
    throw new Error("<YoutubeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<YoutubeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<YoutubeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<YoutubeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<YoutubeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<YoutubeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var YoutubeIcon_default = YoutubeIcon;

// node_modules/svelte-feather-icons/src/icons/ZapOffIcon.svelte
var file284 = "node_modules/svelte-feather-icons/src/icons/ZapOffIcon.svelte";
function create_fragment284(ctx) {
  let svg;
  let polyline0;
  let polyline1;
  let polyline2;
  let line;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      polyline2 = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polyline0 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline1).forEach(detach_dev);
      polyline2 = claim_svg_element(svg_nodes, "polyline", { points: true });
      children(polyline2).forEach(detach_dev);
      line = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "12.41 6.75 13 2 10.57 4.92");
      add_location(polyline0, file284, 13, 244, 528);
      attr_dev(polyline1, "points", "18.57 12.91 21 10 15.66 10");
      add_location(polyline1, file284, 13, 301, 585);
      attr_dev(polyline2, "points", "8 8 3 14 12 14 11 22 16 16");
      add_location(polyline2, file284, 13, 358, 642);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file284, 13, 415, 699);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-zap-off " + /*customClass*/
      ctx[2]);
      add_location(svg, file284, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polyline0);
      append_hydration_dev(svg, polyline1);
      append_hydration_dev(svg, polyline2);
      append_hydration_dev(svg, line);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-zap-off " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment284.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance284($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ZapOffIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ZapOffIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ZapOffIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance284, create_fragment284, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ZapOffIcon",
      options,
      id: create_fragment284.name
    });
  }
  get size() {
    throw new Error("<ZapOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ZapOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ZapOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ZapOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ZapOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ZapOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ZapOffIcon_default = ZapOffIcon;

// node_modules/svelte-feather-icons/src/icons/ZapIcon.svelte
var file285 = "node_modules/svelte-feather-icons/src/icons/ZapIcon.svelte";
function create_fragment285(ctx) {
  let svg;
  let polygon;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      polygon = claim_svg_element(svg_nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "13 2 3 14 12 14 11 22 21 10 12 10 13 2");
      add_location(polygon, file285, 13, 240, 524);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-zap " + /*customClass*/
      ctx[2]);
      add_location(svg, file285, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, polygon);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-zap " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment285.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance285($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ZapIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ZapIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ZapIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance285, create_fragment285, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ZapIcon",
      options,
      id: create_fragment285.name
    });
  }
  get size() {
    throw new Error("<ZapIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ZapIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ZapIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ZapIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ZapIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ZapIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ZapIcon_default = ZapIcon;

// node_modules/svelte-feather-icons/src/icons/ZoomInIcon.svelte
var file286 = "node_modules/svelte-feather-icons/src/icons/ZoomInIcon.svelte";
function create_fragment286(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let line2;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "11");
      attr_dev(circle, "cy", "11");
      attr_dev(circle, "r", "8");
      add_location(circle, file286, 13, 244, 528);
      attr_dev(line0, "x1", "21");
      attr_dev(line0, "y1", "21");
      attr_dev(line0, "x2", "16.65");
      attr_dev(line0, "y2", "16.65");
      add_location(line0, file286, 13, 283, 567);
      attr_dev(line1, "x1", "11");
      attr_dev(line1, "y1", "8");
      attr_dev(line1, "x2", "11");
      attr_dev(line1, "y2", "14");
      add_location(line1, file286, 13, 334, 618);
      attr_dev(line2, "x1", "8");
      attr_dev(line2, "y1", "11");
      attr_dev(line2, "x2", "14");
      attr_dev(line2, "y2", "11");
      add_location(line2, file286, 13, 378, 662);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-zoom-in " + /*customClass*/
      ctx[2]);
      add_location(svg, file286, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
      append_hydration_dev(svg, line2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-zoom-in " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment286.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance286($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ZoomInIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ZoomInIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ZoomInIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance286, create_fragment286, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ZoomInIcon",
      options,
      id: create_fragment286.name
    });
  }
  get size() {
    throw new Error("<ZoomInIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ZoomInIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ZoomInIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ZoomInIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ZoomInIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ZoomInIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ZoomInIcon_default = ZoomInIcon;

// node_modules/svelte-feather-icons/src/icons/ZoomOutIcon.svelte
var file287 = "node_modules/svelte-feather-icons/src/icons/ZoomOutIcon.svelte";
function create_fragment287(ctx) {
  let svg;
  let circle;
  let line0;
  let line1;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        stroke: true,
        "stroke-width": true,
        "stroke-linecap": true,
        "stroke-linejoin": true,
        class: true
      });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "11");
      attr_dev(circle, "cy", "11");
      attr_dev(circle, "r", "8");
      add_location(circle, file287, 13, 245, 529);
      attr_dev(line0, "x1", "21");
      attr_dev(line0, "y1", "21");
      attr_dev(line0, "x2", "16.65");
      attr_dev(line0, "y2", "16.65");
      add_location(line0, file287, 13, 284, 568);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "11");
      attr_dev(line1, "x2", "14");
      attr_dev(line1, "y2", "11");
      add_location(line1, file287, 13, 335, 619);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx[0]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx[0]
      );
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(
        svg,
        "stroke-width",
        /*strokeWidth*/
        ctx[1]
      );
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      attr_dev(svg, "class", svg_class_value = "feather feather-zoom-out " + /*customClass*/
      ctx[2]);
      add_location(svg, file287, 13, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
      append_hydration_dev(svg, line0);
      append_hydration_dev(svg, line1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*size*/
      1) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx2[0]
        );
      }
      if (dirty & /*strokeWidth*/
      2) {
        attr_dev(
          svg,
          "stroke-width",
          /*strokeWidth*/
          ctx2[1]
        );
      }
      if (dirty & /*customClass*/
      4 && svg_class_value !== (svg_class_value = "feather feather-zoom-out " + /*customClass*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment287.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance287($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ZoomOutIcon", slots, []);
  let { size = "24" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    size = size.slice(-1) === "x" ? size.slice(0, size.length - 1) + "em" : parseInt(size) + "px";
  }
  const writable_props = ["size", "strokeWidth", "class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ZoomOutIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("class" in $$props2)
      $$invalidate(2, customClass = $$props2.class);
  };
  $$self.$capture_state = () => ({ size, strokeWidth, customClass });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
    if ("customClass" in $$props2)
      $$invalidate(2, customClass = $$props2.customClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, strokeWidth, customClass];
}
var ZoomOutIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance287, create_fragment287, safe_not_equal, { size: 0, strokeWidth: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ZoomOutIcon",
      options,
      id: create_fragment287.name
    });
  }
  get size() {
    throw new Error("<ZoomOutIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ZoomOutIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<ZoomOutIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<ZoomOutIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ZoomOutIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ZoomOutIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ZoomOutIcon_default = ZoomOutIcon;
export {
  ActivityIcon_default as ActivityIcon,
  AirplayIcon_default as AirplayIcon,
  AlertCircleIcon_default as AlertCircleIcon,
  AlertOctagonIcon_default as AlertOctagonIcon,
  AlertTriangleIcon_default as AlertTriangleIcon,
  AlignCenterIcon_default as AlignCenterIcon,
  AlignJustifyIcon_default as AlignJustifyIcon,
  AlignLeftIcon_default as AlignLeftIcon,
  AlignRightIcon_default as AlignRightIcon,
  AnchorIcon_default as AnchorIcon,
  ApertureIcon_default as ApertureIcon,
  ArchiveIcon_default as ArchiveIcon,
  ArrowDownCircleIcon_default as ArrowDownCircleIcon,
  ArrowDownIcon_default as ArrowDownIcon,
  ArrowDownLeftIcon_default as ArrowDownLeftIcon,
  ArrowDownRightIcon_default as ArrowDownRightIcon,
  ArrowLeftCircleIcon_default as ArrowLeftCircleIcon,
  ArrowLeftIcon_default as ArrowLeftIcon,
  ArrowRightCircleIcon_default as ArrowRightCircleIcon,
  ArrowRightIcon_default as ArrowRightIcon,
  ArrowUpCircleIcon_default as ArrowUpCircleIcon,
  ArrowUpIcon_default as ArrowUpIcon,
  ArrowUpLeftIcon_default as ArrowUpLeftIcon,
  ArrowUpRightIcon_default as ArrowUpRightIcon,
  AtSignIcon_default as AtSignIcon,
  AwardIcon_default as AwardIcon,
  BarChart2Icon_default as BarChart2Icon,
  BarChartIcon_default as BarChartIcon,
  BatteryChargingIcon_default as BatteryChargingIcon,
  BatteryIcon_default as BatteryIcon,
  BellIcon_default as BellIcon,
  BellOffIcon_default as BellOffIcon,
  BluetoothIcon_default as BluetoothIcon,
  BoldIcon_default as BoldIcon,
  BookIcon_default as BookIcon,
  BookOpenIcon_default as BookOpenIcon,
  BookmarkIcon_default as BookmarkIcon,
  BoxIcon_default as BoxIcon,
  BriefcaseIcon_default as BriefcaseIcon,
  CalendarIcon_default as CalendarIcon,
  CameraIcon_default as CameraIcon,
  CameraOffIcon_default as CameraOffIcon,
  CastIcon_default as CastIcon,
  CheckCircleIcon_default as CheckCircleIcon,
  CheckIcon_default as CheckIcon,
  CheckSquareIcon_default as CheckSquareIcon,
  ChevronDownIcon_default as ChevronDownIcon,
  ChevronLeftIcon_default as ChevronLeftIcon,
  ChevronRightIcon_default as ChevronRightIcon,
  ChevronUpIcon_default as ChevronUpIcon,
  ChevronsDownIcon_default as ChevronsDownIcon,
  ChevronsLeftIcon_default as ChevronsLeftIcon,
  ChevronsRightIcon_default as ChevronsRightIcon,
  ChevronsUpIcon_default as ChevronsUpIcon,
  ChromeIcon_default as ChromeIcon,
  CircleIcon_default as CircleIcon,
  ClipboardIcon_default as ClipboardIcon,
  ClockIcon_default as ClockIcon,
  CloudDrizzleIcon_default as CloudDrizzleIcon,
  CloudIcon_default as CloudIcon,
  CloudLightningIcon_default as CloudLightningIcon,
  CloudOffIcon_default as CloudOffIcon,
  CloudRainIcon_default as CloudRainIcon,
  CloudSnowIcon_default as CloudSnowIcon,
  CodeIcon_default as CodeIcon,
  CodepenIcon_default as CodepenIcon,
  CodesandboxIcon_default as CodesandboxIcon,
  CoffeeIcon_default as CoffeeIcon,
  ColumnsIcon_default as ColumnsIcon,
  CommandIcon_default as CommandIcon,
  CompassIcon_default as CompassIcon,
  CopyIcon_default as CopyIcon,
  CornerDownLeftIcon_default as CornerDownLeftIcon,
  CornerDownRightIcon_default as CornerDownRightIcon,
  CornerLeftDownIcon_default as CornerLeftDownIcon,
  CornerLeftUpIcon_default as CornerLeftUpIcon,
  CornerRightDownIcon_default as CornerRightDownIcon,
  CornerRightUpIcon_default as CornerRightUpIcon,
  CornerUpLeftIcon_default as CornerUpLeftIcon,
  CornerUpRightIcon_default as CornerUpRightIcon,
  CpuIcon_default as CpuIcon,
  CreditCardIcon_default as CreditCardIcon,
  CropIcon_default as CropIcon,
  CrosshairIcon_default as CrosshairIcon,
  DatabaseIcon_default as DatabaseIcon,
  DeleteIcon_default as DeleteIcon,
  DiscIcon_default as DiscIcon,
  DivideCircleIcon_default as DivideCircleIcon,
  DivideIcon_default as DivideIcon,
  DivideSquareIcon_default as DivideSquareIcon,
  DollarSignIcon_default as DollarSignIcon,
  DownloadCloudIcon_default as DownloadCloudIcon,
  DownloadIcon_default as DownloadIcon,
  DribbbleIcon_default as DribbbleIcon,
  DropletIcon_default as DropletIcon,
  Edit2Icon_default as Edit2Icon,
  Edit3Icon_default as Edit3Icon,
  EditIcon_default as EditIcon,
  ExternalLinkIcon_default as ExternalLinkIcon,
  EyeIcon_default as EyeIcon,
  EyeOffIcon_default as EyeOffIcon,
  FacebookIcon_default as FacebookIcon,
  FastForwardIcon_default as FastForwardIcon,
  FeatherIcon_default as FeatherIcon,
  FigmaIcon_default as FigmaIcon,
  FileIcon_default as FileIcon,
  FileMinusIcon_default as FileMinusIcon,
  FilePlusIcon_default as FilePlusIcon,
  FileTextIcon_default as FileTextIcon,
  FilmIcon_default as FilmIcon,
  FilterIcon_default as FilterIcon,
  FlagIcon_default as FlagIcon,
  FolderIcon_default as FolderIcon,
  FolderMinusIcon_default as FolderMinusIcon,
  FolderPlusIcon_default as FolderPlusIcon,
  FramerIcon_default as FramerIcon,
  FrownIcon_default as FrownIcon,
  GiftIcon_default as GiftIcon,
  GitBranchIcon_default as GitBranchIcon,
  GitCommitIcon_default as GitCommitIcon,
  GitMergeIcon_default as GitMergeIcon,
  GitPullRequestIcon_default as GitPullRequestIcon,
  GithubIcon_default as GithubIcon,
  GitlabIcon_default as GitlabIcon,
  GlobeIcon_default as GlobeIcon,
  GridIcon_default as GridIcon,
  HardDriveIcon_default as HardDriveIcon,
  HashIcon_default as HashIcon,
  HeadphonesIcon_default as HeadphonesIcon,
  HeartIcon_default as HeartIcon,
  HelpCircleIcon_default as HelpCircleIcon,
  HexagonIcon_default as HexagonIcon,
  HomeIcon_default as HomeIcon,
  ImageIcon_default as ImageIcon,
  InboxIcon_default as InboxIcon,
  InfoIcon_default as InfoIcon,
  InstagramIcon_default as InstagramIcon,
  ItalicIcon_default as ItalicIcon,
  KeyIcon_default as KeyIcon,
  LayersIcon_default as LayersIcon,
  LayoutIcon_default as LayoutIcon,
  LifeBuoyIcon_default as LifeBuoyIcon,
  Link2Icon_default as Link2Icon,
  LinkIcon_default as LinkIcon,
  LinkedinIcon_default as LinkedinIcon,
  ListIcon_default as ListIcon,
  LoaderIcon_default as LoaderIcon,
  LockIcon_default as LockIcon,
  LogInIcon_default as LogInIcon,
  LogOutIcon_default as LogOutIcon,
  MailIcon_default as MailIcon,
  MapIcon_default as MapIcon,
  MapPinIcon_default as MapPinIcon,
  Maximize2Icon_default as Maximize2Icon,
  MaximizeIcon_default as MaximizeIcon,
  MehIcon_default as MehIcon,
  MenuIcon_default as MenuIcon,
  MessageCircleIcon_default as MessageCircleIcon,
  MessageSquareIcon_default as MessageSquareIcon,
  MicIcon_default as MicIcon,
  MicOffIcon_default as MicOffIcon,
  Minimize2Icon_default as Minimize2Icon,
  MinimizeIcon_default as MinimizeIcon,
  MinusCircleIcon_default as MinusCircleIcon,
  MinusIcon_default as MinusIcon,
  MinusSquareIcon_default as MinusSquareIcon,
  MonitorIcon_default as MonitorIcon,
  MoonIcon_default as MoonIcon,
  MoreHorizontalIcon_default as MoreHorizontalIcon,
  MoreVerticalIcon_default as MoreVerticalIcon,
  MousePointerIcon_default as MousePointerIcon,
  MoveIcon_default as MoveIcon,
  MusicIcon_default as MusicIcon,
  Navigation2Icon_default as Navigation2Icon,
  NavigationIcon_default as NavigationIcon,
  OctagonIcon_default as OctagonIcon,
  PackageIcon_default as PackageIcon,
  PaperclipIcon_default as PaperclipIcon,
  PauseCircleIcon_default as PauseCircleIcon,
  PauseIcon_default as PauseIcon,
  PenToolIcon_default as PenToolIcon,
  PercentIcon_default as PercentIcon,
  PhoneCallIcon_default as PhoneCallIcon,
  PhoneForwardedIcon_default as PhoneForwardedIcon,
  PhoneIcon_default as PhoneIcon,
  PhoneIncomingIcon_default as PhoneIncomingIcon,
  PhoneMissedIcon_default as PhoneMissedIcon,
  PhoneOffIcon_default as PhoneOffIcon,
  PhoneOutgoingIcon_default as PhoneOutgoingIcon,
  PieChartIcon_default as PieChartIcon,
  PlayCircleIcon_default as PlayCircleIcon,
  PlayIcon_default as PlayIcon,
  PlusCircleIcon_default as PlusCircleIcon,
  PlusIcon_default as PlusIcon,
  PlusSquareIcon_default as PlusSquareIcon,
  PocketIcon_default as PocketIcon,
  PowerIcon_default as PowerIcon,
  PrinterIcon_default as PrinterIcon,
  RadioIcon_default as RadioIcon,
  RefreshCcwIcon_default as RefreshCcwIcon,
  RefreshCwIcon_default as RefreshCwIcon,
  RepeatIcon_default as RepeatIcon,
  RewindIcon_default as RewindIcon,
  RotateCcwIcon_default as RotateCcwIcon,
  RotateCwIcon_default as RotateCwIcon,
  RssIcon_default as RssIcon,
  SaveIcon_default as SaveIcon,
  ScissorsIcon_default as ScissorsIcon,
  SearchIcon_default as SearchIcon,
  SendIcon_default as SendIcon,
  ServerIcon_default as ServerIcon,
  SettingsIcon_default as SettingsIcon,
  Share2Icon_default as Share2Icon,
  ShareIcon_default as ShareIcon,
  ShieldIcon_default as ShieldIcon,
  ShieldOffIcon_default as ShieldOffIcon,
  ShoppingBagIcon_default as ShoppingBagIcon,
  ShoppingCartIcon_default as ShoppingCartIcon,
  ShuffleIcon_default as ShuffleIcon,
  SidebarIcon_default as SidebarIcon,
  SkipBackIcon_default as SkipBackIcon,
  SkipForwardIcon_default as SkipForwardIcon,
  SlackIcon_default as SlackIcon,
  SlashIcon_default as SlashIcon,
  SlidersIcon_default as SlidersIcon,
  SmartphoneIcon_default as SmartphoneIcon,
  SmileIcon_default as SmileIcon,
  SpeakerIcon_default as SpeakerIcon,
  SquareIcon_default as SquareIcon,
  StarIcon_default as StarIcon,
  StopCircleIcon_default as StopCircleIcon,
  SunIcon_default as SunIcon,
  SunriseIcon_default as SunriseIcon,
  SunsetIcon_default as SunsetIcon,
  TableIcon_default as TableIcon,
  TabletIcon_default as TabletIcon,
  TagIcon_default as TagIcon,
  TargetIcon_default as TargetIcon,
  TerminalIcon_default as TerminalIcon,
  ThermometerIcon_default as ThermometerIcon,
  ThumbsDownIcon_default as ThumbsDownIcon,
  ThumbsUpIcon_default as ThumbsUpIcon,
  ToggleLeftIcon_default as ToggleLeftIcon,
  ToggleRightIcon_default as ToggleRightIcon,
  ToolIcon_default as ToolIcon,
  Trash2Icon_default as Trash2Icon,
  TrashIcon_default as TrashIcon,
  TrelloIcon_default as TrelloIcon,
  TrendingDownIcon_default as TrendingDownIcon,
  TrendingUpIcon_default as TrendingUpIcon,
  TriangleIcon_default as TriangleIcon,
  TruckIcon_default as TruckIcon,
  TvIcon_default as TvIcon,
  TwitchIcon_default as TwitchIcon,
  TwitterIcon_default as TwitterIcon,
  TypeIcon_default as TypeIcon,
  UmbrellaIcon_default as UmbrellaIcon,
  UnderlineIcon_default as UnderlineIcon,
  UnlockIcon_default as UnlockIcon,
  UploadCloudIcon_default as UploadCloudIcon,
  UploadIcon_default as UploadIcon,
  UserCheckIcon_default as UserCheckIcon,
  UserIcon_default as UserIcon,
  UserMinusIcon_default as UserMinusIcon,
  UserPlusIcon_default as UserPlusIcon,
  UserXIcon_default as UserXIcon,
  UsersIcon_default as UsersIcon,
  VideoIcon_default as VideoIcon,
  VideoOffIcon_default as VideoOffIcon,
  VoicemailIcon_default as VoicemailIcon,
  Volume1Icon_default as Volume1Icon,
  Volume2Icon_default as Volume2Icon,
  VolumeIcon_default as VolumeIcon,
  VolumeXIcon_default as VolumeXIcon,
  WatchIcon_default as WatchIcon,
  WifiIcon_default as WifiIcon,
  WifiOffIcon_default as WifiOffIcon,
  WindIcon_default as WindIcon,
  XCircleIcon_default as XCircleIcon,
  XIcon_default as XIcon,
  XOctagonIcon_default as XOctagonIcon,
  XSquareIcon_default as XSquareIcon,
  YoutubeIcon_default as YoutubeIcon,
  ZapIcon_default as ZapIcon,
  ZapOffIcon_default as ZapOffIcon,
  ZoomInIcon_default as ZoomInIcon,
  ZoomOutIcon_default as ZoomOutIcon
};
//# sourceMappingURL=svelte-feather-icons.js.map
