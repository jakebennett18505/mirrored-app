{
  "version": 3,
  "sources": ["../../jose/dist/browser/runtime/webcrypto.js", "../../jose/dist/browser/lib/buffer_utils.js", "../../jose/dist/browser/runtime/base64url.js", "../../jose/dist/browser/runtime/random.js", "../../jose/dist/browser/jwe/flattened/encrypt.js", "../../jose/dist/browser/lib/secs.js", "../../jose/dist/browser/util/base64url.js", "../../node_modules/.pnpm/cookie@0.5.0/node_modules/cookie/index.js", "../../@supabase/auth-helpers-shared/src/browserCookieStorage.ts", "../../@supabase/auth-helpers-shared/src/utils/cookies.ts", "../../@supabase/auth-helpers-shared/src/utils/helpers.ts", "../../@supabase/auth-helpers-shared/src/utils/constants.ts", "../../@supabase/auth-helpers-shared/src/chunker.ts", "../../@supabase/auth-helpers-shared/src/cookieAuthStorageAdapter.ts", "../../@supabase/auth-helpers-shared/src/createClient.ts", "../../@supabase/auth-helpers-sveltekit/src/supabaseLoadClient.ts", "../../@supabase/auth-helpers-sveltekit/src/loadStorageAdapter.ts", "../../@supabase/auth-helpers-sveltekit/src/supabaseServerClient.ts", "../../@supabase/auth-helpers-sveltekit/src/serverStorageAdapter.ts"],
  "sourcesContent": ["export default crypto;\nexport const isCryptoKey = (key) => key instanceof CryptoKey;\n", "import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    buffers.forEach((buffer) => {\n        buf.set(buffer, i);\n        i += buffer.length;\n    });\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n", "import { encoder, decoder } from '../lib/buffer_utils.js';\nexport const encodeBase64 = (input) => {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n};\nexport const encode = (input) => {\n    return encodeBase64(input).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\nexport const decodeBase64 = (encoded) => {\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n};\nexport const decode = (input) => {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch (_a) {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n};\n", "import crypto from './webcrypto.js';\nexport default crypto.getRandomValues.bind(crypto);\n", "import { encode as base64url } from '../../runtime/base64url.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport { deflate } from '../../runtime/zlib.js';\nimport generateIv from '../../lib/iv.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport const unprotected = Symbol();\nexport class FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            if (!this._protectedHeader || !this._protectedHeader.zip) {\n                throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            }\n            if (joseHeader.zip !== 'DEF') {\n                throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n            }\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (alg === 'dir') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n            }\n        }\n        else if (alg === 'ECDH-ES') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n            }\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else {\n                    if (!this._protectedHeader) {\n                        this.setProtectedHeader(parameters);\n                    }\n                    else {\n                        this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                    }\n                }\n            }\n        }\n        this._iv || (this._iv = generateIv(enc));\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = base64url(this._aad);\n            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        let ciphertext;\n        let tag;\n        if (joseHeader.zip === 'DEF') {\n            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n            ({ ciphertext, tag } = await encrypt(enc, deflated, cek, this._iv, additionalData));\n        }\n        else {\n            ;\n            ({ ciphertext, tag } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));\n        }\n        const jwe = {\n            ciphertext: base64url(ciphertext),\n            iv: base64url(this._iv),\n            tag: base64url(tag),\n        };\n        if (encryptedKey) {\n            jwe.encrypted_key = base64url(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n", "const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[1]);\n    const unit = matched[2].toLowerCase();\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            return Math.round(value);\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            return Math.round(value * minute);\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            return Math.round(value * hour);\n        case 'day':\n        case 'days':\n        case 'd':\n            return Math.round(value * day);\n        case 'week':\n        case 'weeks':\n        case 'w':\n            return Math.round(value * week);\n        default:\n            return Math.round(value * year);\n    }\n};\n", "import * as base64url from '../runtime/base64url.js';\nexport const encode = base64url.encode;\nexport const decode = base64url.decode;\n", "/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar __toString = Object.prototype.toString\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var dec = opt.decode || decode;\n\n  var index = 0\n  while (index < str.length) {\n    var eqIdx = str.indexOf('=', index)\n\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break\n    }\n\n    var endIdx = str.indexOf(';', index)\n\n    if (endIdx === -1) {\n      endIdx = str.length\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(';', eqIdx - 1) + 1\n      continue\n    }\n\n    var key = str.slice(index, eqIdx).trim()\n\n    // only assign once\n    if (undefined === obj[key]) {\n      var val = str.slice(eqIdx + 1, endIdx).trim()\n\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1)\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n\n    index = endIdx + 1\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    var expires = opt.expires\n\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + expires.toUTCString()\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.priority) {\n    var priority = typeof opt.priority === 'string'\n      ? opt.priority.toLowerCase()\n      : opt.priority\n\n    switch (priority) {\n      case 'low':\n        str += '; Priority=Low'\n        break\n      case 'medium':\n        str += '; Priority=Medium'\n        break\n      case 'high':\n        str += '; Priority=High'\n        break\n      default:\n        throw new TypeError('option priority is invalid')\n    }\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction decode (str) {\n  return str.indexOf('%') !== -1\n    ? decodeURIComponent(str)\n    : str\n}\n\n/**\n * URL-encode value.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction encode (val) {\n  return encodeURIComponent(val)\n}\n\n/**\n * Determine if value is a Date.\n *\n * @param {*} val\n * @private\n */\n\nfunction isDate (val) {\n  return __toString.call(val) === '[object Date]' ||\n    val instanceof Date\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n", "import { parse, serialize } from 'cookie';\nimport { CookieAuthStorageAdapter } from './cookieAuthStorageAdapter';\nimport { CookieOptions } from './types';\nimport { isBrowser } from './utils';\n\nexport class BrowserCookieAuthStorageAdapter extends CookieAuthStorageAdapter {\n\tconstructor(cookieOptions?: CookieOptions) {\n\t\tsuper(cookieOptions);\n\t}\n\n\tprotected getCookie(name: string) {\n\t\tif (!isBrowser()) return null;\n\n\t\tconst cookies = parse(document.cookie);\n\t\treturn cookies[name];\n\t}\n\n\tprotected setCookie(name: string, value: string) {\n\t\tif (!isBrowser()) return null;\n\n\t\tdocument.cookie = serialize(name, value, {\n\t\t\t...this.cookieOptions,\n\t\t\thttpOnly: false\n\t\t});\n\t}\n\n\tprotected deleteCookie(name: string) {\n\t\tif (!isBrowser()) return null;\n\n\t\tdocument.cookie = serialize(name, '', {\n\t\t\t...this.cookieOptions,\n\t\t\tmaxAge: 0,\n\t\t\thttpOnly: false\n\t\t});\n\t}\n}\n", "import { Session } from '@supabase/supabase-js';\nimport { parse, serialize } from 'cookie';\nimport { base64url } from 'jose';\n\nexport { parse as parseCookies, serialize as serializeCookie };\n\n/**\n * Based on the environment and the request we know if a secure cookie can be set.\n */\nexport function isSecureEnvironment(headerHost?: string | string[]) {\n\tif (!headerHost) {\n\t\tthrow new Error('The \"host\" request header is not available');\n\t}\n\n\tconst headerHostStr = Array.isArray(headerHost) ? headerHost[0] : headerHost;\n\n\tconst host = (headerHostStr.indexOf(':') > -1 && headerHostStr.split(':')[0]) || headerHostStr;\n\tif (['localhost', '127.0.0.1'].indexOf(host) > -1 || host.endsWith('.local')) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport function parseSupabaseCookie(str: string | null | undefined): Partial<Session> | null {\n\tif (!str) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst session = JSON.parse(str);\n\t\tif (!session) {\n\t\t\treturn null;\n\t\t}\n\t\t// Support previous cookie which was a stringified session object.\n\t\tif (session.constructor.name === 'Object') {\n\t\t\treturn session;\n\t\t}\n\t\tif (session.constructor.name !== 'Array') {\n\t\t\tthrow new Error(`Unexpected format: ${session.constructor.name}`);\n\t\t}\n\n\t\tconst [_header, payloadStr, _signature] = session[0].split('.');\n\t\tconst payload = base64url.decode(payloadStr);\n\t\tconst decoder = new TextDecoder();\n\n\t\tconst { exp, sub, ...user } = JSON.parse(decoder.decode(payload));\n\n\t\treturn {\n\t\t\texpires_at: exp,\n\t\t\texpires_in: exp - Math.round(Date.now() / 1000),\n\t\t\ttoken_type: 'bearer',\n\t\t\taccess_token: session[0],\n\t\t\trefresh_token: session[1],\n\t\t\tprovider_token: session[2],\n\t\t\tprovider_refresh_token: session[3],\n\t\t\tuser: {\n\t\t\t\tid: sub,\n\t\t\t\tfactors: session[4],\n\t\t\t\t...user\n\t\t\t}\n\t\t};\n\t} catch (err) {\n\t\tconsole.warn('Failed to parse cookie string:', err);\n\t\treturn null;\n\t}\n}\n\nexport function stringifySupabaseSession(session: Session): string {\n\treturn JSON.stringify([\n\t\tsession.access_token,\n\t\tsession.refresh_token,\n\t\tsession.provider_token,\n\t\tsession.provider_refresh_token,\n\t\tsession.user?.factors ?? null\n\t]);\n}\n", "export function isBrowser() {\n\treturn typeof window !== 'undefined' && typeof window.document !== 'undefined';\n}\n", "import { DefaultCookieOptions } from '../types';\n\nexport const DEFAULT_COOKIE_OPTIONS: DefaultCookieOptions = {\n\tpath: '/',\n\tsameSite: 'lax',\n\tmaxAge: 60 * 60 * 24 * 365 * 1000\n};\n", "interface Chunk {\n\tname: string;\n\tvalue: string;\n}\n\nfunction createChunkRegExp(chunkSize: number) {\n\treturn new RegExp('.{1,' + chunkSize + '}', 'g');\n}\n\nconst MAX_CHUNK_SIZE = 3180;\nconst MAX_CHUNK_REGEXP = createChunkRegExp(MAX_CHUNK_SIZE);\n\n/**\n * create chunks from a string and return an array of object\n */\nexport function createChunks(key: string, value: string, chunkSize?: number): Chunk[] {\n\tconst re = chunkSize !== undefined ? createChunkRegExp(chunkSize) : MAX_CHUNK_REGEXP;\n\n\t// check the length of the string to work out if it should be returned or chunked\n\tconst chunkCount = Math.ceil(value.length / (chunkSize ?? MAX_CHUNK_SIZE));\n\n\tif (chunkCount === 1) {\n\t\treturn [{ name: key, value }];\n\t}\n\n\tconst chunks: Chunk[] = [];\n\t// split string into a array based on the regex\n\tconst values = value.match(re);\n\tvalues?.forEach((value, i) => {\n\t\tconst name: string = `${key}.${i}`;\n\t\tchunks.push({ name, value });\n\t});\n\n\treturn chunks;\n}\n\n// Get fully constructed chunks\nexport function combineChunks(\n\tkey: string,\n\tretrieveChunk: (name: string) => string | null | undefined = () => {\n\t\treturn null;\n\t}\n) {\n\tlet values: string[] = [];\n\tfor (let i = 0; ; i++) {\n\t\tconst chunkName = `${key}.${i}`;\n\t\tconst chunk = retrieveChunk(chunkName);\n\n\t\tif (!chunk) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvalues.push(chunk);\n\t}\n\n\treturn values.length ? values.join('') : null;\n}\n", "import { GoTrueClientOptions, Session } from '@supabase/supabase-js';\nimport { DEFAULT_COOKIE_OPTIONS, parseSupabaseCookie, stringifySupabaseSession } from './utils';\nimport { CookieOptions, DefaultCookieOptions } from './types';\nimport { combineChunks, createChunks } from './chunker';\n\nexport interface StorageAdapter extends Exclude<GoTrueClientOptions['storage'], undefined> {}\n\nexport abstract class CookieAuthStorageAdapter implements StorageAdapter {\n\tprotected readonly cookieOptions: DefaultCookieOptions;\n\n\tconstructor(cookieOptions?: CookieOptions) {\n\t\tthis.cookieOptions = {\n\t\t\t...DEFAULT_COOKIE_OPTIONS,\n\t\t\t...cookieOptions,\n\t\t\tmaxAge: DEFAULT_COOKIE_OPTIONS.maxAge\n\t\t};\n\t}\n\n\tprotected abstract getCookie(name: string): string | undefined | null;\n\tprotected abstract setCookie(name: string, value: string): void;\n\tprotected abstract deleteCookie(name: string): void;\n\n\tgetItem(key: string): string | Promise<string | null> | null {\n\t\tconst value = this.getCookie(key);\n\n\t\t// pkce code verifier\n\t\tif (key.endsWith('-code-verifier') && value) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (value) {\n\t\t\treturn JSON.stringify(parseSupabaseCookie(value));\n\t\t}\n\n\t\tconst chunks = combineChunks(key, (chunkName) => {\n\t\t\treturn this.getCookie(chunkName);\n\t\t});\n\n\t\treturn chunks !== null ? JSON.stringify(parseSupabaseCookie(chunks)) : null;\n\t}\n\n\tsetItem(key: string, value: string): void | Promise<void> {\n\t\t// pkce code verifier\n\t\tif (key.endsWith('-code-verifier')) {\n\t\t\tthis.setCookie(key, value);\n\t\t\treturn;\n\t\t}\n\n\t\tlet session: Session = JSON.parse(value);\n\t\tconst sessionStr = stringifySupabaseSession(session);\n\n\t\t// split session string before setting cookie\n\t\tconst sessionChunks = createChunks(key, sessionStr);\n\n\t\tsessionChunks.forEach((sess) => {\n\t\t\tthis.setCookie(sess.name, sess.value);\n\t\t});\n\t}\n\n\tremoveItem(key: string): void | Promise<void> {\n\t\tthis._deleteSingleCookie(key);\n\t\tthis._deleteChunkedCookies(key);\n\t}\n\n\tprivate _deleteSingleCookie(key: string) {\n\t\tif (this.getCookie(key)) {\n\t\t\tthis.deleteCookie(key);\n\t\t}\n\t}\n\n\tprivate _deleteChunkedCookies(key: string, from = 0) {\n\t\tfor (let i = from; ; i++) {\n\t\t\tconst cookieName = `${key}.${i}`;\n\t\t\tconst value = this.getCookie(cookieName);\n\n\t\t\tif (value === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.deleteCookie(cookieName);\n\t\t}\n\t}\n}\n", "import { createClient } from '@supabase/supabase-js';\nimport { SupabaseClientOptionsWithoutAuth } from './types';\nimport { isBrowser } from './utils';\nimport { StorageAdapter } from './cookieAuthStorageAdapter';\nimport { GenericSchema } from '@supabase/supabase-js/dist/module/lib/types';\n\nexport function createSupabaseClient<\n\tDatabase = any,\n\tSchemaName extends string & keyof Database = 'public' extends keyof Database\n\t\t? 'public'\n\t\t: string & keyof Database,\n\tSchema extends GenericSchema = Database[SchemaName] extends GenericSchema\n\t\t? Database[SchemaName]\n\t\t: any\n>(\n\tsupabaseUrl: string,\n\tsupabaseKey: string,\n\toptions: SupabaseClientOptionsWithoutAuth<SchemaName> & {\n\t\tauth: {\n\t\t\tstorage: StorageAdapter;\n\t\t\tstorageKey?: string;\n\t\t};\n\t}\n) {\n\tconst browser = isBrowser();\n\n\treturn createClient<Database, SchemaName, Schema>(supabaseUrl, supabaseKey, {\n\t\t...options,\n\t\tauth: {\n\t\t\tflowType: 'pkce',\n\t\t\tautoRefreshToken: browser,\n\t\t\tdetectSessionInUrl: browser,\n\t\t\tpersistSession: true,\n\t\t\tstorage: options.auth.storage,\n\n\t\t\t// fix this in supabase-js\n\t\t\t...(options.auth?.storageKey\n\t\t\t\t? {\n\t\t\t\t\t\tstorageKey: options.auth.storageKey\n\t\t\t\t  }\n\t\t\t\t: {})\n\t\t}\n\t});\n}\n", "import {\n\tCookieOptionsWithName,\n\tcreateSupabaseClient,\n\tisBrowser,\n\tSupabaseClientOptionsWithoutAuth\n} from '@supabase/auth-helpers-shared';\nimport { Session, SupabaseClient } from '@supabase/supabase-js';\nimport { LoadEvent } from '@sveltejs/kit';\nimport { SvelteKitLoadAuthStorageAdapter } from './loadStorageAdapter';\nimport { GenericSchema } from '@supabase/supabase-js/dist/module/lib/types';\n\nlet cachedBrowserClient: SupabaseClient<any, string> | undefined;\n\n/**\n * ## Authenticated Supabase client\n *\n * Returns a new authenticated Supabase client.\n *\n * When running in the browser it will create a single instance\n * that is returned for subsequent runs.\n *\n * ### Example:\n *\n * ```ts\n * import { invalidate } from '$app/navigation';\n * import { PUBLIC_SUPABASE_ANON_KEY, PUBLIC_SUPABASE_URL } from '$env/static/public';\n * import { createSupabaseLoadClient } from '@supabase/auth-helpers-sveltekit';\n * import type { LayoutLoad } from './$types';\n *\n * export const load: LayoutLoad = async ({ fetch, data, depends }) => {\n *   depends('supabase:auth');\n *\n *   const supabase = createSupabaseLoadClient({\n *     supabaseUrl: PUBLIC_SUPABASE_URL,\n *     supabaseKey: PUBLIC_SUPABASE_ANON_KEY,\n *     event: { fetch },\n *     serverSession: data.session,\n *     onAuthStateChange() {\n *       invalidate('supabase:auth');\n *     }\n *   });\n *\n *   const {\n *     data: { session }\n * \t} = await supabase.auth.getSession();\n *\n *   return { supabase, session };\n * };\n *\n * ```\n */\nexport function createSupabaseLoadClient<\n\tDatabase = any,\n\tSchemaName extends string & keyof Database = 'public' extends keyof Database\n\t\t? 'public'\n\t\t: string & keyof Database,\n\tSchema extends GenericSchema = Database[SchemaName] extends GenericSchema\n\t\t? Database[SchemaName]\n\t\t: any\n>({\n\tsupabaseUrl,\n\tsupabaseKey,\n\tevent,\n\tserverSession,\n\toptions,\n\tcookieOptions\n}: {\n\tsupabaseUrl: string;\n\t/**\n\t * The supabase key. Make sure you **always** use the ANON_KEY.\n\t */\n\tsupabaseKey: string;\n\tevent: Pick<LoadEvent, 'fetch'>;\n\t/**\n\t * The initial session from the server.\n\t */\n\tserverSession: Session | null;\n\toptions?: SupabaseClientOptionsWithoutAuth<SchemaName>;\n\tcookieOptions?: CookieOptionsWithName;\n}): SupabaseClient<Database, SchemaName, Schema> {\n\tconst browser = isBrowser();\n\tif (browser && cachedBrowserClient) {\n\t\treturn cachedBrowserClient as SupabaseClient<Database, SchemaName, Schema>;\n\t}\n\tconst client = createSupabaseClient<Database, SchemaName, Schema>(supabaseUrl, supabaseKey, {\n\t\t...options,\n\t\tglobal: {\n\t\t\tfetch: event.fetch,\n\t\t\t...options?.global,\n\t\t\theaders: {\n\t\t\t\t...options?.global?.headers,\n\t\t\t\t'X-Client-Info': `${PACKAGE_NAME}@${PACKAGE_VERSION}`\n\t\t\t}\n\t\t},\n\t\tauth: {\n\t\t\tstorage: new SvelteKitLoadAuthStorageAdapter(serverSession, cookieOptions)\n\t\t}\n\t});\n\n\tif (browser) {\n\t\tcachedBrowserClient = client;\n\t}\n\n\treturn client;\n}\n", "import {\n\tBrowserCookieAuthStorageAdapter,\n\tCookieOptions,\n\tisBrowser\n} from '@supabase/auth-helpers-shared';\nimport { Session } from '@supabase/supabase-js';\n\nexport class SvelteKitLoadAuthStorageAdapter extends BrowserCookieAuthStorageAdapter {\n\tconstructor(\n\t\tprivate readonly serverSession: Session | null = null,\n\t\tcookieOptions?: CookieOptions\n\t) {\n\t\tsuper(cookieOptions);\n\t}\n\n\tgetItem(key: string) {\n\t\tif (!isBrowser()) {\n\t\t\treturn JSON.stringify(this.serverSession);\n\t\t}\n\t\treturn super.getItem(key);\n\t}\n}\n", "import {\n\tCookieOptionsWithName,\n\tSupabaseClientOptionsWithoutAuth,\n\tcreateSupabaseClient\n} from '@supabase/auth-helpers-shared';\nimport { RequestEvent } from '@sveltejs/kit';\nimport { SvelteKitServerAuthStorageAdapter } from './serverStorageAdapter';\nimport { GenericSchema } from '@supabase/supabase-js/dist/module/lib/types';\nimport { SupabaseClient } from '@supabase/supabase-js';\n\n/**\n * ## Authenticated Supabase client\n * ### Handle\n *\n * ```ts\n * import { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY } from '$env/static/public';\n * import { createSupabaseServerClient } from '@supabase/auth-helpers-sveltekit';\n * import type { Handle } from '@sveltejs/kit';\n *\n * export const handle: Handle = async ({ event, resolve }) => {\n *   event.locals.supabase = createSupabaseServerClient({\n *     supabaseUrl: PUBLIC_SUPABASE_URL,\n *     supabaseKey: PUBLIC_SUPABASE_ANON_KEY,\n *     event\n *   });\n *\n *   event.locals.getSession = async () => {\n *     const {\n *       data: { session }\n *     } = await event.locals.supabase.auth.getSession();\n *     return session;\n *   };\n *\n *   return resolve(event, {\n *     filterSerializedResponseHeaders(name) {\n *       return name === 'content-range';\n *     }\n *   });\n * };\n * ```\n *\n * ### Types\n *\n * ```ts\n * import { SupabaseClient, Session } from '@supabase/supabase-js';\n *\n * declare global {\n *   namespace App {\n *     interface Locals {\n *       supabase: SupabaseClient;\n *       getSession(): Promise<Session | null>;\n *     }\n *     // interface PageData {}\n *     // interface Error {}\n *     // interface Platform {}\n *   }\n * }\n *\n * export {};\n * ```\n */\nexport function createSupabaseServerClient<\n\tDatabase = any,\n\tSchemaName extends string & keyof Database = 'public' extends keyof Database\n\t\t? 'public'\n\t\t: string & keyof Database,\n\tSchema extends GenericSchema = Database[SchemaName] extends GenericSchema\n\t\t? Database[SchemaName]\n\t\t: any\n>({\n\tsupabaseUrl,\n\tsupabaseKey,\n\tevent,\n\toptions,\n\tcookieOptions,\n\texpiryMargin\n}: {\n\tsupabaseUrl: string;\n\tsupabaseKey: string;\n\tevent: Pick<RequestEvent, 'cookies'>;\n\toptions?: SupabaseClientOptionsWithoutAuth<SchemaName>;\n\tcookieOptions?: CookieOptionsWithName;\n\texpiryMargin?: number;\n}): SupabaseClient<Database, SchemaName, Schema> {\n\tconst client = createSupabaseClient<Database, SchemaName, Schema>(supabaseUrl, supabaseKey, {\n\t\t...options,\n\t\tglobal: {\n\t\t\t...options?.global,\n\t\t\theaders: {\n\t\t\t\t...options?.global?.headers,\n\t\t\t\t'X-Client-Info': `${PACKAGE_NAME}@${PACKAGE_VERSION}`\n\t\t\t}\n\t\t},\n\t\tauth: {\n\t\t\tstorage: new SvelteKitServerAuthStorageAdapter(event, cookieOptions, expiryMargin)\n\t\t}\n\t});\n\n\treturn client;\n}\n", "import { CookieAuthStorageAdapter, CookieOptions } from '@supabase/auth-helpers-shared';\nimport { Session } from '@supabase/supabase-js';\nimport { RequestEvent } from '@sveltejs/kit';\n\nexport class SvelteKitServerAuthStorageAdapter extends CookieAuthStorageAdapter {\n\tprivate isInitialDelete = true;\n\tprivate currentSession: Partial<Session> | null = null;\n\n\tconstructor(\n\t\tprivate readonly event: Pick<RequestEvent, 'cookies'>,\n\t\tcookieOptions?: CookieOptions,\n\t\tprivate readonly expiryMargin: number = 60\n\t) {\n\t\tsuper(cookieOptions);\n\t}\n\n\tprotected getCookie(name: string) {\n\t\treturn this.event.cookies.get(name);\n\t}\n\n\tprotected setCookie(name: string, value: string) {\n\t\tthis.event.cookies.set(name, value, {\n\t\t\thttpOnly: false,\n\t\t\t...this.cookieOptions\n\t\t});\n\t}\n\n\tprotected deleteCookie(name: string) {\n\t\tthis.event.cookies.delete(name, {\n\t\t\thttpOnly: false,\n\t\t\t...this.cookieOptions\n\t\t});\n\t}\n\n\tasync getItem(key: string) {\n\t\tconst sessionStr = await super.getItem(key);\n\t\tif (!sessionStr) {\n\t\t\tthis.currentSession = null;\n\t\t\treturn null;\n\t\t}\n\n\t\tconst session: Session | null = JSON.parse(sessionStr);\n\t\tthis.currentSession = session;\n\n\t\tif (session?.expires_at) {\n\t\t\t// shorten the session lifetime so it does not expire on the server\n\t\t\tsession.expires_at -= this.expiryMargin;\n\t\t}\n\t\treturn JSON.stringify(session);\n\t}\n\n\tremoveItem(key: string) {\n\t\tif (this.isInitialDelete && this.currentSession?.expires_at) {\n\t\t\tconst now = Math.round(Date.now() / 1000);\n\t\t\tif (this.currentSession.expires_at < now + 10) {\n\t\t\t\tthis.isInitialDelete = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsuper.removeItem(key);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["base64url_exports", "decode", "encode", "encode", "decode", "parse", "serialize", "decode", "encode", "import_cookie", "base64url_exports", "decoder", "value", "isBrowser", "createSupabaseClient"]
}
